<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>ReactPropsMocks</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>ReactPropsMocks</h1><p>Welcome to ReactPropsMocks</p><ul><!--TOC_Start--><li><a href="#proper-mocking">Proper Mocking</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="proper-mocking"></a>
<h2>Proper Mocking</h2>
<p>I made some progress on mocking our <strong>fetch</strong>  calls with jest. Recall that our goal is to create a mock implementation of <strong>fetch</strong> that does not make an HTTP REST call over the network. This allows us to run our tests even if our server is not, or cannot, run.</p>
<p>This new implementation allows us to use <strong><em>exactly</em></strong> the same code in <strong>App.js</strong> when we are testing and when we are running our app normally. In particular, here are the imports in <strong>App.js</strong>, or wherever we are calling <strong>fetch</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./App.css'</span>;
</code></pre>
<p>And here is our call to <strong>fetch</strong>:</p>
<pre><code class="lang-javascript">fetch(<span class="hljs-string">'/api/foo'</span>)
    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'GETONE-FETCH-ONE'</span>);
        <span class="hljs-keyword">return</span> response.json();
    }).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(json)</span> {</span>
        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'GETONE-FETCH-TWO'</span>);
        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'parsed json'</span>, json);
        that.setState(foo =&gt; (json));
    }).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ex)</span> {</span>
        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'parsing failed'</span>, ex);
    });
</code></pre>
<p>As you can see, this code is back to our initial syntax. In particular, we are no longer passing this as the first parameter:</p>
<pre><code class="lang-javascript">fetch(<span class="hljs-keyword">this</span>, <span class="hljs-string">'/api/user'</span>) &lt;===== WE NO LONGER NEED <span class="hljs-keyword">this</span>. COMPARE TO CODE ABOVE.
fetch(<span class="hljs-string">'/api/user'</span>) &lt;===== THIS IS HOW IT SHOULD LOOK NOW.
</code></pre>
<p>So how do we perform this miracle? To make a long story short: we use the mock library built into Jest. Here is how to proceed:</p>
<ul>
<li>Create a new folder in the root of your project called: <strong>__mocks__</strong><ul>
<li>Two underscores, the word mocks, two more underscores</li>
</ul>
</li>
<li>Create a file in that directory called <strong>fetch.js</strong></li>
</ul>
<p>First lets create a simple module called <strong>default_data.js</strong> that contains the data we will use in our mock:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> getData = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> {
    <span class="hljs-keyword">switch</span> (url) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/api/foo'</span>:
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>,
                <span class="hljs-attr">file</span>: <span class="hljs-string">'api.js'</span>
            };

        <span class="hljs-keyword">case</span> <span class="hljs-string">'/api/user'</span>:
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">error</span>: {},
                <span class="hljs-attr">response</span>: {},
                <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({
                    <span class="hljs-attr">login</span>: <span class="hljs-string">'Robin Dudette'</span>
                })
            };

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> {}
    }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> getData;
</code></pre>
<p>This code simply creates sets of data that mimic what our server would return given a call to a specific <strong>url</strong>.</p>
<p>Below is the source code for our new mock for <strong>fetch</strong>. Put it in a file called <strong>fetch-mock.js</strong>. Note in particular the call to [jest.genMockFromModule][gmm]. That call asks Jest to generate a mock object for the module we want to replace with a mock:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> getData <span class="hljs-keyword">from</span> <span class="hljs-string">'./mock-data'</span>;

<span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> whatwgFetch = jest.genMockFromModule(<span class="hljs-string">'whatwg-fetch'</span>);

<span class="hljs-keyword">var</span> fetch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>{

    <span class="hljs-keyword">var</span> objectState = getData(url);

    <span class="hljs-keyword">var</span> response = {};
    response.json = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> objectState;
    };

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"FETCH STATER"</span>, objectState);
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'FETCH TEST ONE'</span>, func(response));
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
                    <span class="hljs-comment">//func(JSON.stringify(stater));</span>
                    func(objectState);
                    <span class="hljs-keyword">return</span> {
                        <span class="hljs-attr">catch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

                        }
                    }
                }
            }
        }
    }
};

whatwgFetch.fetch = fetch;
<span class="hljs-built_in">window</span>.fetch = fetch;

<span class="hljs-built_in">module</span>.exports = whatwgFetch;
</code></pre>
<p>Over time, you can comment out the calls to <strong>console.log</strong>. But they might be helpful at first when you are trying to understand what is going on. Note in particular that we are now putting calls to the callbacks (func) passed into our labyrinthine series of <strong>return</strong> statements. The most important is the second call to <strong>then</strong> where we pass back the <strong>stater</strong> object. Recall that this is used as follows in our call to <strong>fetch</strong>:</p>
<pre><code class="lang-javascript">.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'GETONE-FETCH-TWO'</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parsed json'</span>, json);
    that.setState(<span class="hljs-function"><span class="hljs-params">foo</span> =&gt;</span> (json));
})
</code></pre>
</div></body></html>