<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>ReactPropsShow</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>ReactPropsShow</h1><p>Welcome to ReactPropsShow</p><ul><!--TOC_Start--><li><a href="#react-props-show">React Props Show</a></li>
<li><a href="#creating-showuserinfo">Creating ShowUserInfo</a></li>
<li><a href="#component-children">Component Children</a></li>
<li><a href="#too-many-fields">Too Many Fields</a></li>
<li><a href="#generating-fields">Generating Fields</a></li>
<li><a href="#field-definitions">Field Definitions</a></li>
<li><a href="#process-fields">Processing Field Definitions</a></li>
<li><a href="#default-values-for-the-state">Default Values for the State</a></li>
<li><a href="#using-elfelements">Using ElfElements</a></li>
<li><a href="#passing-fields-to-showuserinfo">Passing Fields to ShowUserInfo</a></li>
<li><a href="#passing-events">Passing Events</a></li>
<li><a href="#turn-it-in">Turn it in</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="react-props-show"></a>
<h1>React Props Show</h1>
<p>Learn to create a component that can automatically generate the HTML elements displayed in its Render method.</p>
<p>We have several major goals in this assignment. To learn how to:</p>
<ul>
<li>Learn about Nested components</li>
<li>Pass state from the parent to the child componen</li>
<li>To build a set of HTML controls based on a specification</li>
</ul>
<a class="anchor" id="creating-showuserinfo"></a>
<h2>Creating ShowUserInfo</h2>
<p>Make a copy of <strong>GetUserInfo</strong> and call it <strong>ShowUserInfo</strong>. Open your new file in an editor (probably WebStorm) and change instances of the variable <strong>GetUserInfo</strong> to <strong>ShowUserInfo</strong>. There will be at least two such instances.</p>
<p>For now, you can leave most of <strong>ShowUserInfo</strong> as is, except for removing the method that queries the server with <strong>fetch</strong>. That method stays in <strong>GetUserInfo</strong>.</p>
<p>Open <strong>GetUserInfo</strong> in your editor and change the <strong>render</strong> method to look something like this:</p>
<pre>import fieldDefinitions from './field-definitions';

// CODE OMITTED

render() {
        return (
            <div className="App">
                <ShowUserInfo
                    fields={fieldDefinitions}
                    gitUser={this.state.gitUser}
                />
            </div>
        );
    }
</pre>
<p>This will not be our final solution, but it is a start. But before we try to get any further, we should set up our tests.</p>
<a class="anchor" id="component-children"></a>
<h2>Component Children</h2>
<p>Once we understood the difference between testing with <strong>shallow</strong> and <strong>mount</strong>, we are free to create a component that has a child Component. We did so when we broke up the <strong>GetUserInfo</strong> component into two pieces:</p>
<ul>
<li><strong>GetUserInfo</strong>: This owns and handles the data</li>
<li><strong>ShowUserInfo</strong>: This component displays the data</li>
</ul>
<p>As menmtioned earlier, the words that the React DOCS use are as a bit like following: &quot;There should always be one canonical place where state is maintained.&quot; In our case, that is <strong>GetUserInfo</strong>. It will have state. It was also share that state with other components, in our case, <strong>ShowUserInfo</strong>. Quite often, and in our case, <strong>ShowUserInfo</strong> should have no state. If it does have state, it is not related to the properties that it receives from <strong>GetUserInfo</strong>.</p>
<p><strong>NOTE</strong>: <em>fetch stays in GetUserInfo because we are using that component to handle cases in which data changes. Specifically, <strong>fetch</strong> retrieves data from the server and we use that data to change state. We use <strong>GetUserInfo</strong> when we want to manipulate data, and <strong>ShowUserInfo</strong> when we want to display data. This follows the rule &quot;Each component should have only one reason to change.&quot; Or, to say the same thing somewhere differently: &quot;Each class should do one thing and do it well.&quot; A third rule that applies here is specific to React: &quot;There should be one place, and one place only, where data maintains state and can be mutated.&quot; Other components have <strong>props</strong> and are, at least in theory, immutable.</em></p>
<p>The state passed by <strong>GetUserInfo</strong> to <strong>ShowUserInfio</strong> enters the constructor in the form of <strong>props:</strong></p>
<pre>class ShowUserInfo extends Component {
    constructor(props) {
        super(props);
    }
}
</pre>
<p>As you know, this state contains two objects:</p>
<ul>
<li>fields: A definition of the fields to display</li>
<li>gitUser: The data retrieved from GitHub</li>
</ul>
<a class="anchor" id="too-many-fields"></a>
<h2>Too Many Fields</h2>
<p>Code that looks like this is easy to use if you have just a few fields.</p>
<pre>render() {
        return (
            <div className="App">

                <p className="App-intro">
                    state.userLogin: {this.state.userLogin}
                </p>

               <button className="getUser" onClick={this.getUser}>Get User</button>
            </div>
        );
    }
</pre>
<p>Here I have only one field, called <strong>userLogin</strong>. It is fairly easy to write code that displays this one field.</p>
<p>If you have many fields, as we will when we query Git, the task becomes more difficult. In such cases, it might be helpful to automatically generate the fields.</p>
<p><strong>NOTE</strong>: <em>A second reason to automatically generate fields is that it helps us to create regular, well formed code. Our code is easier to read if IDs. CLASSNAMES and attributes always come in a certain order, and if we follow certain coding practices such as using the same techniques for handling labels.</em></p>
<a class="anchor" id="generating-fields"></a>
<h2>Generating Fields</h2>
<p>To automatically generate code for working with our fields requires two files:</p>
<ul>
<li>One that describes the fields we want to create (field-definitions.js)</li>
<li>One that knows how to create fields of a certain type. (ElfElements.js)</li>
</ul>
<a class="anchor" id="field-definitions"></a>
<h2>Field Definitions</h2>
<p>Here is the <strong>src/field-definitions.js</strong>:</p>
<pre>/**
 * Created by charlie on 4/20/17.
 */

/*eslint no-unused-vars: "off" */
const unknown = 'unknown';
const PARAGRAPH=0;
const TEXT=1;
const DEFAULT=PARAGRAPH;
const types = ['paragraph', 'text'];

export default [
    {
        id: 'login',
        label: 'loginName',
        type: types[DEFAULT],
        sample: 'login-' + unknown
    },{
        id: 'avatar_url',
        label: 'Avatar Url',
        type: types[DEFAULT],
        sample: 'ai' + unknown
    },
    {
        id: 'url',
        label: 'Url',
        type: types[DEFAULT],
        sample: 'url' + unknown
    },
    {
        id: 'html_url',
        label: 'HTML Url',
        type: types[DEFAULT],
        sample: 'htmlUrl' + unknown
    },
    {
        id: 'followers_url',
        label: 'Followers URL',
        type: types[DEFAULT],
        sample: 'followersUrl' + unknown
    }
]
</pre>
<p>You probably recognize this data, as it mirrors some of the fields from our initial user query of GitHub. Recall that you run code like this to view the data:</p>
<pre>curl https://api.github.com/users/charliecalvert
</pre>
<ul>
<li><strong>id</strong> is the HTML id attribute for your control</li>
<li><strong>label</strong> is the text to put in the label for our control</li>
<li><strong>type</strong> is the element kind, such as P, TEXT, TEXTAREA, etc.<ul>
<li>We will make TEXT controls INPUT controls of type <strong>text</strong></li>
</ul>
</li>
<li><strong>sample</strong> is the default text to display in the control</li>
</ul>
<a class="anchor" id="process-fields"></a>
<h2>Processing Field Definitions</h2>
<p>Here is a simple <strong>Component</strong> that knows how to read this file and return HTML elements of the right type and shape:</p>
<pre>import React, {Component} from 'react';
import '../css/forms.css';
import Debug from '../elf-logger';
const logger = new Debug(false);

class ElfElements extends Component {
    constructor(props) {
        logger.log('FORM INPUT', 'constructor called', props);
        super(props);
        logger.log('FORM PROPS', this.props);
    }

    render() {
        const common = {
            id: this.props.id,
            value: this.props.defaultValue,
            onChange: this.props.onChange
        };

        switch (this.props.type) {

            case 'year':
                return (
                    <input
                        {...common}
                        type="number"
                        value={this.props.value || new Date().getFullYear()}
                    />
                );

            case 'paragraph':
                return <p
                    className='ElfFormParagraph'
                    id={this.props.id}

                    onChange={this.props.onChange}
                >{this.props.value}</p>;

            case 'textarea':
                return <textarea {...common} className='ElfFormInput' value={this.props.value} />;

            case 'text': {
                return <input
                    className='ElfFormInput'
                    id={this.props.id}
                    value={this.props.value}
                    type={this.props.type}
                    onChange={this.props.onChange}
                />;
            }

            default:
                return <input {...common} type="text"/>;
        }
    }
}

export default ElfElements;
</pre>
<p>For instance, the first definition in <strong>field-definitions</strong> return something like this JSX/HTML:</p>
<pre><p class="ElfFormParagraph" id="login">login-unknown</p>
</pre>
<a class="anchor" id="default-values-for-the-state"></a>
<h2>Default Values for the State</h2>
<p>We should properly initialize <strong>this.state</strong> in <strong>GetUserInfo</strong>. Fortunately, with our new <strong>field-definitions</strong>, we have a relatively painless way to do so. Here is the updated constructor for <strong>GetUserInfo</strong>:</p>
<pre>constructor() {
    super();
    const tempGitUser = {};
    for (let value of fieldDefinitions) {
        tempGitUser[value.id] = value.sample;
    }
    this.state = {
        gitUser: tempGitUser
    };

    logger.log('GetUserInfo constructor called.')
}
</pre>
<p>We first create an empty object, then iterator over the <strong>fieldDefinitions</strong> array, and create new objects with a single property.  for <strong>tempGitUser</strong>. For instance, we can create a property set to the value of the <strong>fieldDefinitions.id</strong> property to the value of the <strong>fieldDefinitions.sample</strong> property.</p>
<p><strong>NOTE</strong>: <em>This ability to easily and dynamically add properties to an object based solely on pairs of strings is a powerful feature of JavaScript. We wish we could write code like this, but we can&#39;t since we don&#39;t know the property names until runtime</em>:</p>
<pre> tempGitUser[0].login = 'login-unknown'
</pre>
<p> We can, however, achieve the same result by execute this code:</p>
<pre>tempGitUser[value.id] = value.sample;
</pre>
<p>Suppose we are looking at this member of the <strong>fieldDefinitions</strong> array:</p>
<pre>{
    id: 'login',
    label: 'loginName',
    type: types[DEFAULT],
    sample: 'login-' + unknown
},
</pre>
<p>Our code would adds a property to <strong>tempGitUser</strong> that look something like this:</p>
<pre>{'login': 'login-unknown'}
</pre>
<p>Each iteration of the loop adds one more property to the <strong>tempGitUser</strong> object. The end result is that we have default values for all the paragraph fields in our JSX.</p>
<a class="anchor" id="using-elfelements"></a>
<h2>Using ElfElements</h2>
<p>We can understand some of what is going on here, but how did the control the write data. We do it like this:</p>
<pre>import React, {Component} from 'react';
import '../css/forms.css';
import 'whatwg-fetch';
import Debug from '../elf-logger';
import ElfElements from './ElfElements';
const logger = new Debug(false);

class ShowUserInfo extends Component {
    constructor(props) {
        super(props);
        //this.shouldUpdate = true;
        logger.log('ShowUserInfo constructor called.');
        logger.log('ShowUserInfo props.' + JSON.stringify(this.props.userData, null, 4));
    }

    getForm = (field, index) => {
        return (
            <div className="ElfFormRow" key={field.id}>
               <label className="ElfFormLabel" htmlFor={field.id}>{field.label}:</label>
               <ElfElements {...field}
                        value={this.props.gitUser[field.id]}
                        onChange={this.props.onChange}
               />
            </div>
        )
    };

    render() {

        return (
            <form className="Form">{
                this.props.fields.map((field, index) => {
                    return this.getForm(field, index)
                })
            }
            <button className="getUser" onClick={this.props.onChange}>Get User</button>
            </form>
        )
    }
}

export default ShowUserInfo;
</pre>
<a class="anchor" id="passing-fields-to-showuserinfo"></a>
<h2>Passing Fields to ShowUserInfo</h2>
<p>The props shown in the <strong>constructor</strong> of <strong>ShowUserInfo</strong> is the state passed from <strong>GetUserInfo</strong>. Here is the relevant code from <strong>GetUserInfo</strong>:</p>
<pre>import fieldDefinitions from './field-definitions';

// CODE OMITTED

render() {
        return (
            <div className="App">
                <ShowUserInfo
                    fields={fieldDefinitions}
                    gitUser={this.state.gitUser}
                    onChange={this.getUser}
                />
            </div>
        );
    }
</pre>
<p>As you can see, <strong>GetUserInfo</strong> passes in three pieces of state to <strong>ShowUserInfo</strong>. These become the <strong>props</strong> seen in the constructor of <strong>ShowUserInfo</strong>. They are used when <strong>ShowUserInfo</strong> generates its code.</p>
<p>We got fields by loading a file that we created. The <strong>gitUser</strong> comes from querying our server. But what is <strong>onChange</strong>? Lets tackle it in the last section of this document.</p>
<a class="anchor" id="passing-events"></a>
<h2>Passing Events</h2>
<p>The parent component, in this case <strong>GetUserInfo</strong> controls the data. In particular, we maintain the data in <strong>GetUserInfo&#39;s</strong> state, and we change it with this method:</p>
<pre>getUser = (event) => {
  const that = this;
  fetch('/api/user')
  .then(function(response) {
    return response.json();
  }).then(function(json) {
    logger.log('parsed json', json);
    var gitUser = JSON.parse(json.gitUser);
    that.setState({
      gitUser: gitUser
    });
    etc....
</pre>
<p>You will need to <strong>event.preventDefault()</strong> at the end of this method.</p>
<p>As mentioned earlier, we pass this method as a prop from <strong>GetUserInfo</strong> to <strong>ShowUserInfo</strong>:</p>
<pre><ShowUserInfo
    fields={fieldDefinitions}
    gitUser={this.state.gitUser}
    onChange={this.getUser}
/>
</pre>
<p>Then we use it in <strong>ShowUserInfo</strong> like this:</p>
<pre><button id="getUser" onClick={this.props.onChange}>Get User</button>
</pre>
<p>Given our knowledge of JavaScript, it is fairly simple to see how <strong>this.props.onChange</strong> becomes a call to the <strong>GetUserInfo.getUser</strong> The key fact, which is hard to grasp at first is how the changes made by that method are propagated back down to <strong>ShowUserInfo</strong>.</p>
<p>Obviously the task is handled by React. In particular, when we call <strong>setState</strong>, as we do in <strong>getUser</strong>, then two things happen:</p>
<ul>
<li><strong>GetUserInfo</strong>&#39;s <strong>render</strong> method is called.</li>
<li><strong>ShowUserInfo</strong>&#39;s <strong>render</strong> method is called</li>
</ul>
<p>It is the latter call that might not be intuitively obvious to us. It happens because <strong>ShowUserInfo</strong> is a child of <strong>GetUserInfo</strong> and hence react knows that properly re-rendering <strong>GetUserInfo</strong> involves also re-rendering <strong>ShowUserInfo</strong>.</p>
<a class="anchor" id="turn-it-in"></a>
<h2>Turn it in</h2>
<p>Add, commit, push. Tell me what directory your code is in. Then either tag it and give me the tag, or put it in a branch. For instance, after you pushed, issue this command:</p>
<p>  git branch Week04-ReactPropsShow</p>
<p>There is not even a need for you to ever switch to that branch. You can just continue working in your current branch, which is probably <strong>master</strong>. When it comes time to grade your work, I can open your branch and take a look. Or perhaps I will simply look at your most recent code instead. For that reason, you might submit two pieces of information:</p>
<ul>
<li>The branch you put the assignment in</li>
<li>The branch you are working in</li>
</ul>
<p>For instance:</p>
<ul>
<li>Assigment Branch: Week04-ReactPropsShow</li>
<li>Working Branmch: master</li>
</ul>
</div></body></html>