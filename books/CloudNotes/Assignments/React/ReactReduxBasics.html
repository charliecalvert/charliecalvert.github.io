<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>ReactReduxBasics</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>ReactReduxBasics</h1><p>Welcome to ReactReduxBasics</p><ul><!--TOC_Start--><li><a href="#react-redux-basics">React Redux Basics</a></li>
<li><a href="#redux">Redux</a></li>
<li><a href="#dispatch">Dispatch</a></li>
<li><a href="#store-state">Store state</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#actions">Actions</a></li>
<li><a href="#the-reducer">The Reducer</a></li>
<li><a href="#subscribe">Subscribe</a></li>
<li><a href="#simple-redux">Simple Redux</a></li>
<li><a href="#set-up-index">Set up Index</a></li>
<li><a href="#redux-with-props">Redux with props</a></li>
<li><a href="#appnoprops">AppNoProps</a></li>
<li><a href="#mapdispatchtoprops">MapDispatchToProps</a></li>
<li><a href="#break-out-connect">Break out Connect</a></li>
<li><a href="#updated-spokesman">Updated spokesman</a></li>
<li><a href="#final-index">Final Index</a></li>
<li><a href="#turn-it-in">Turn it in</a></li>
<li><a href="#local-storage">Local Storage</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="react-redux-basics"></a>
<h1>React Redux Basics</h1>
<p>Install:</p>
<pre>npm install --save redux react-redux redux-devtools
</pre>
<a class="anchor" id="redux"></a>
<h2>Redux</h2>
<p>The overall goal is to:</p>
<ul>
<li>Put all our state in one place</li>
<li>Make state immutable. You can completely rebuild it, but you can&#39;t modify it.<ul>
<li>If you want to update it, you completely rebuild state</li>
</ul>
</li>
</ul>
<p>There is only one place where you rebuild state: the <strong>reducer</strong>. Hence there is never any question of where something happened in a big application. It could only have happened in the <strong>reducer</strong>. I explain reducers later in this document.</p>
<p>A Redux tracks your app&#39;s state. It has the following methods:</p>
<ul>
<li>subscribe,</li>
<li>dispatch,</li>
<li>getState</li>
</ul>
<a class="anchor" id="dispatch"></a>
<h2>Dispatch</h2>
<p>We change state by &quot;dispatching&quot; an action. (You can log, serialize or store actions.)</p>
<p>Here is a typical call to <strong>dispatch</strong>:</p>
<pre>dispatch({
  type: 'GIT_USER',
  gitUser: gitUser
});
</pre>
<p>We name the action by giving it a <strong>type</strong>. And in this case, we have optionally included some data that will be used a <strong>reducer</strong> when it rebuilds state.</p>
<a class="anchor" id="store-state"></a>
<h2>Store state</h2>
<p>Redux maintains your application&#39;s <strong>state</strong> in something called a <strong>store</strong>.</p>
<pre>import {createStore} from 'redux';

let store = createStore(spokesman);
</pre>
<a class="anchor" id="example"></a>
<h2>Example</h2>
<p>In the next few sections we will put together an example.</p>
<a class="anchor" id="actions"></a>
<h2>Actions</h2>
<p>Lets begin by designing some simple actions:</p>
<pre>let verify = { type: 'VERIFY' }
let deny = { type: 'DENY' }
let noComment = { type: 'NO COMMENT' }
</pre>
<p>Note that there is no data associated with this actions. This means the actions are simple enough that they can re-build state without any additional information other than the action itself.</p>
<a class="anchor" id="the-reducer"></a>
<h2>The Reducer</h2>
<p>This we will use in serveral places, so save it as <strong>spokesman.js</strong>:</p>
<pre>
const spokesman = (state = { statement: 'No comment' }, action) => {
    switch (action.type) {
        case 'VERIFY':
            return { statement: 'We stand by it. In fact, we invented it.' };
        case 'DENY':
            return { statement: 'We deny everything. We have never heard of it.' };
        case 'NO COMMENT':
            return {statement: 'No comment.'};
        default:
            return state;
    }
};

export default spokesman;
</pre>
<p>Notice that this application has a very simple <strong>state</strong> object:</p>
<pre>state = { statement: 'No comment' }
</pre>
<p>That&#39;s it. That is the only moving part in the application. There are no other variables that can change that have any effect outside of the component in which they are declared.</p>
<p>In a for loop, we often declare a variable called <strong>i</strong>:</p>
<pre>  for (let i = 0; i < 3; i++) {}
</pre>
<p>We don&#39;t need to put <strong>i</strong> in our state since it is not used by any other components. In fact, it is only used this one place in one method.</p>
<p>But <strong>statement</strong> is different. It is used by multiple modules, or at least we are pretending it is the type of data will be used in various places throughout the app.</p>
<p>Noe that our <strong>reducer</strong> modifies <strong>statement</strong> by completely rebuilding <strong>state</strong>. And this is the only place in the application where <strong>statement</strong> can be modified.</p>
<a class="anchor" id="dispatch"></a>
<h2>Dispatch</h2>
<p>Here is an example call to <strong>dispatch</strong>:</p>
<pre>store.dispatch({ type: 'VERIFY' });
</pre>
<p>This message is <em>dispatched</em> to our reducer. The reducer responds by modifying the state like this:</p>
<pre>{ statement: 'We stand by it. In fact, we invented it.' };
</pre>
<a class="anchor" id="subscribe"></a>
<h2>Subscribe</h2>
<p>When the state changes, several parts of your app might want to be notified. You track changes to state by monitoring calls to subscribe():</p>
<pre>import {createStore} from 'redux';

let store = createStore(spokesman);

store.subscribe(() => {
    this.setState((prevState) => {
        const storeState = this.props.store.getState();        
        return {statement: storeState.statement}
    });
});
</pre>
<p>Now you can modify the UI based on the changes.</p>
<a class="anchor" id="simple-redux"></a>
<h2>Simple Redux</h2>
<p>At heart, Redux is very simple. Consider this <em>fake</em> Redux implementation. It is not Redux itself, but it is Redux-like. Save it as <strong>SimpleRedux.js</strong>:</p>
<pre>import React, { Component } from 'react';
import spokesman from './spokesman';

class SimpleRedux extends Component {

    state = spokesman(undefined, {});

    dispatch(action) {
        this.setState( (prevState) => spokesman(prevState, action));
    }

    verifyStatement = () => {
        this.dispatch({ type: 'VERIFY' });
    };

    denyEverything = () => {
        this.dispatch({ type: 'DENY' });
    };

    noComment = () => {
        this.dispatch({ type: 'NO COMMENT' });
    };

    render() {
        return (
            <div>
                <h1>Political Science Fake Redux</h1>

                <p>This component does not use redux. It uses something redux-like.</p>
                {this.state.statement}
                <hr />
                <button onClick={this.verifyStatement}>Verify</button>
                <button onClick={this.denyEverything}>Deny</button>
                <button onClick={this.noComment}>No Comment</button>
            </div>
        )
    }
}

export default SimpleRedux;
</pre>
<a class="anchor" id="set-up-index"></a>
<h2>Set up Index</h2>
<p>In <strong>index.js</strong>, we want to do two things:</p>
<ul>
<li>Create our <strong>store</strong></li>
<li>Wrap the entire app in a Provider so that all parts of the app can independently access the <strong>store</strong> and other features of Redux.</li>
</ul>
<p>In this code we are also displaying our <strong>SimpleRedux</strong> file, but it has nothing to do with implementing the real Redux. We only display it so that we can see it in action.</p>
<pre>import spokesman from './spokesman';
import {Provider} from 'react-redux';
import {createStore} from 'redux';
import SimpleRedux from 'SimpleRedux';

let store = createStore(spokesman);
ReactDOM.render(
    <div>
        <Provider store={store}>
            <div>
                <App />
                <SimpleRedux/>
            </div>
        </Provider>
    </div>
    , document.getElementById('root'));
</pre>
<a class="anchor" id="redux-with-props"></a>
<h2>Redux with props</h2>
<p>In its pure form, each component that wants to access Redux can do so on its own, without looking at <strong>props</strong>, and without peering into any other modules. But you can, if you want, pass down the Redux state in props. This is not the &quot;right&quot; way to do Redux. Yet, on the other hand, it is not wrong. Redux provides much more flexibility than a monolithic tool like <strong>Angular.</strong> So if you want to pass down <strong>state</strong> with <strong>props</strong>, go ahead and do it. But there is a &quot;better&quot; way, which will be explained later in this document.</p>
<pre>constructor(props) {
        super(props);
        this.state = {
            statement: 'No comment'
        };
        this.props.store.subscribe(() => {
            const storeState = this.props.store.getState();
            this.setState((prevState) => {
                return {statement: storeState.statement}
            });
        })
    }

    verifyStatement = () => {
        this.props.store.dispatch({ type: 'VERIFY' });
    };

    // IMPLEMENT denyEverything AND noComment HERE.

    <h1>Political Science Props Redux</h1>
    render() {
            return (
                <div className="App">

               <p>This component does not use redux. It uses something redux-like.</p>
               {this.state.statement}
               <hr />
               <button onClick={this.verifyStatement}>Verify</button>
               <button onClick={this.denyEverything}>Deny</button>
               <button onClick={this.noComment}>No Comment</button>
               </div>
        );
    }
</pre>
<p>Notice that we do everything Redux-related on the <strong>store</strong> object passed as props from <strong>index.js</strong>:</p>
<pre>const storeState = this.props.store.getState();
this.props.store.dispatch({ type: 'VERIFY' });
</pre>
<p>To make the above work, your <strong>index.js</strong> might look like this:</p>
<pre>ReactDOM.render(
    <div>
        <Provider store={store}>
            <div>
                <App store={store}/>
                <hr /> <hr />
                <FakeRedux />
            </div>
        </Provider>
    </div>,
    document.getElementById('root'));
</pre>
<a class="anchor" id="appnoprops"></a>
<h2>AppNoProps</h2>
<p>So what is the better way? What do we do if we want to create a component that does not get <strong>props</strong>, but does have access to the Redux data store?</p>
<p>We begin by importing connect at the top of the component that we want to give access to the Redux <strong>store</strong>:</p>
<pre>import {connect} from 'react-redux';
</pre>
<p>Remove <strong>subscribe</strong> from the <strong>constructor</strong>, or create a <strong>constructor</strong> that does not call <strong>subscribe</strong>:</p>
<pre>constructor(props) {
    super(props);
    this.state = {
        statement: 'No comment'
    };
}
</pre>
<p>Now we use <strong>connect</strong> to <em>connect</em> our component to the Redux data <strong>store</strong>. We do this by adding the following code at the bottom of the component:</p>
<pre>const mapStateToProps = (state) => {
    return {
        statement: state.statement
    }
};

AppNoProps = connect(mapStateToProps)(AppNoProps);
</pre>
<p>And now we no longer get <strong>store</strong> in the <strong>props</strong> passed from <strong>index.js</strong>. Here was the old code:</p>
<pre>verifyStatement = () => {
    this.props.store.dispatch({ type: 'VERIFY' });
};
</pre>
<p>And here is the new code that does not rely on a <strong>store</strong>. Instead, dispatch is build in because we use <strong>connect</strong>:</p>
<pre>verifyStatement = () => {
    this.props.dispatch({ type: 'VERIFY' });
};
</pre>
<a class="anchor" id="mapdispatchtoprops"></a>
<h2>MapDispatchToProps</h2>
<p>Here is code that uses a method of <strong>connect</strong> called <strong>mapDispatchToProps</strong>. This allows us to define simple <strong>dispatch</strong> methods that are triggered by button clicks:</p>
<pre>import React from 'react';
import logo from './logo.svg';
import './App.css';
import {connect} from 'react-redux';
// We change state by "dispatching" an action.
// You can log, serialize or store actions.

let AppConnect = ({statement, deny, verify, noComment}) => {

    return (
        <div className="App">
            <div className="App-header">
                <img src={logo} className="App-logo" alt="logo"/>
                <h2>Welcome to React and Redux</h2>
            </div>
            <p className="App-intro">
                This AppConnect component uses Redux and connect.
            </p>
            <h1>Political Science</h1>
            {statement}
            <hr />
            <button onClick={verify}>Verify</button>
            <button onClick={deny}>Deny</button>
            <button onClick={noComment}>No Comment</button>

        </div>
    );
    //}
};

const mapStateToProps = (state) => {
    return {
        statement: state.statement
    }
};

const mapDispatchToProps = (dispatch) => {
    return {
        deny: () => {
            dispatch({type: 'DENY'})
        },
        verify: () => {
            dispatch({type: 'VERIFY'})
        },
        noComment: () => {
            dispatch({type: 'NO COMMENT'})
        }
    }
};

AppConnect = connect(
    mapStateToProps,
    mapDispatchToProps
)(AppConnect);

export default AppConnect;
</pre>
<p>Notice that we are using an arrow method rather than a component, and notice that it takes parameters, filled in by React, that represent the various methods and properties used by Redux.</p>
<p>Here is the arrow function:</p>
<pre>let AppConnect = ({statement, deny, verify, noComment}) => { ... }
</pre>
<p>And here where we use them in our JSX:</p>
<pre>{statement}
<hr />
<button onClick={verify}>Verify</button>
<button onClick={deny}>Deny</button>
<button onClick={noComment}>No Comment</button>
</pre>
<a class="anchor" id="break-out-connect"></a>
<h2>Break out Connect</h2>
<p>We can now break out our code into two pieces:</p>
<ul>
<li>One file contains <strong>JSX</strong> only</li>
<li>One file contains our <strong>connect</strong> code.</li>
</ul>
<p>JSX only. Save it in <strong>AppConnectJsxOnly</strong>:</p>
<pre>import React from 'react';
import './App.css';

let AppConnect = ({statement, deny, verify, noComment}) => {

    return (
        <div className="App">
            <p className="App-intro">
                This AppConnect component uses Redux and connect.
                The connect bits are in a separate file called <strong>AppConnectMaps</strong>.
            </p>
            <h1>App Connect JSX Only</h1>
            {statement}
            <hr />
            <button onClick={verify}>Verify</button>
            <button onClick={deny}>Deny</button>
            <button onClick={noComment}>No Comment</button>
        </div>
    );
};

export default AppConnect;
</pre>
<p>And here is the connect only code. Save it in AppConnectMaps.js:</p>
<pre>/**
 * Created by charlie on 6/6/17.
 */

import {connect} from 'react-redux';
import AppConnectJsxOnly from './AppConnectJsxOnly';

const mapStateToProps = (state) => {
    return {
        statement: state.statement
    }
};

const mapDispatchToProps = (dispatch) => {
    return {
        deny: () => {
            dispatch({type: 'DENY'})
        },
        verify: () => {
            dispatch({type: 'VERIFY'})
        },
        noComment: () => {
            dispatch({type: 'NO COMMENT'})
        }
    }
};

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(AppConnectJsxOnly);
</pre>
<a class="anchor" id="updated-spokesman"></a>
<h2>Updated spokesman</h2>
<p>Suppose we wanted to update our code to use slightly more complex state that has two properties rather than one.</p>
<pre>const spokesman = (state = { statement: 'No comment' }, action) => {
    switch (action.type) {
        case 'VERIFY':
            return {
                statement: 'We stand by it. In fact, we invented it.',
                kind: 'verify'
            };
        case 'DENY':
            return {
                statement: 'We deny everything. We have never heard of it.',
                kind: 'deny'
            };
        case 'NO COMMENT':
            return {
                statement: 'No comment.',
                kind: 'no Comment'
            };
        default:
            return state;
    }
};

export default spokesman;
</pre>
<p>And then the function rather than class in <strong>DispatchConnect.js</strong>:</p>
<pre>let DispatchConnect = ({dispatch, statement, kind}) => {

    const verifyStatement = () => {
        dispatch({type: 'VERIFY'});
    };
    // And so on
    return (
    <div className="App">
        <div className="App-intro">
            <h2>Welcome to React</h2>
        </div>

        <h1>Political Science Dispatch Connect Redux</h1>

        <p>This component uses Redux.</p>
        <p>{statement}</p>
        <p>{kind}</p>
        <hr />
        <button onClick={verifyStatement}>Verify</button>
        <button onClick={denyEverything}>Deny</button>
        <button onClick={noComment}>No Comment</button>

    </div>
  );
}
</pre>
<p>And modify <strong>mapStateToProps</strong> to see the new property:</p>
<pre>const mapStateToProps = (state) => {
    return {
        statement: state.statement,
        kind: state.kind
    }
};
</pre>
<a class="anchor" id="final-index"></a>
<h2>Final Index</h2>
<pre>import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import SimpleRedux from './SimpleRedux';
import AppConnect from './AppConnect';
import AppConnectMaps from './AppConnectMaps';
import DispatchConnect from './DispatchConnect';
import DispactchComponentConnect from './DispatchComponentConnect';
import registerServiceWorker from './registerServiceWorker';
import './index.css';
import spokesman from './spokesman';
import {Provider} from 'react-redux';
import {createStore} from 'redux';
let store = createStore(spokesman);

ReactDOM.render(
    <div>
        <Provider store={store}>
            <div>
                <AppConnect/>
                <hr /> <hr />
                <AppConnectMaps/>
                <hr /> <hr />
                <DispactchComponentConnect/>
                <hr /> <hr />
                <DispatchConnect/>
                <hr /> <hr />
                <App store={store}/>
                <hr /> <hr />
                <SimpleRedux />
            </div>
        </Provider>
    </div>,
    document.getElementById('root'));
registerServiceWorker();
</pre>
<a class="anchor" id="turn-it-in"></a>
<h2>Turn it in</h2>
<p>Add, commit, push. Create branch and or tag. Push. Tell me branch, tag and folder when turning in assignment.</p>
<a class="anchor" id="local-storage"></a>
<h2>Local Storage</h2>
<p>Redux can write the current state to localStorage.</p>
</div></body></html>