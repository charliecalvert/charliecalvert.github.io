<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>Isit322Midterm2017</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar" class="navbar-toggle collapsed"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div id="navbar" class="navbar-collapse collapse">       <ul class="nav navbar-nav"><li ng-class="{ active: isActive('/')}" class="trigger-collapse"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img alt="Elvenware" src="/images/elvenwarelogo.png" class="elf-normal"/></figure><h1>Isit322Midterm2017</h1><p>Welcome to Isit322Midterm2017</p><ul><!--TOC_Start--><li><a href="#isit-322-midterm-2017">ISIT 322 Midterm 2017</a></li>
<li><a href="#goals">Goals</a></li>
<li><a href="#jscs">JSCS</a></li>
<li><a href="#jscs-punctuator">JSCS Punctuator in ES6</a></li>
<li><a href="#extra-credit-option-one">Extra Credit Option One</a></li>
<li><a href="#extra-credit-option-two">Extra Credit Option Two</a></li>
<li><a href="#turn-it-in">Turn it in</a></li>
<li><a href="#shallow-button-clicks">Shallow Button Clicks</a></li>
<li><a href="#contains-matching-element">Contains Matching Element</a></li>
<li><a href="#filter-tests">Filter Tests</a></li>
<li><a href="#enospc">ENOSPC Error</a></li>
<li><a href="#props-single-node">Props Singe Node Error</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="isit-322-midterm-2017"></a>
<h1>ISIT 322 Midterm 2017</h1>
<p>It is a take home, you will have about a week to do it. Check back for updates, which will be announced if they occur, but the basic plan is this:</p>
<a class="anchor" id="goals"></a>
<h2>Goals</h2>
<ul>
<li>Same app, same name, new tag and branch both labeled <strong>midterm</strong></li>
<li>Include a styled menu and component switching<ul>
<li>Home (This is the GitUser view)</li>
<li>GetFoo</li>
<li>Numbers</li>
</ul>
</li>
<li>Make at least two more requests of GitHub API<ul>
<li>Include in the menu</li>
<li>Switches between all three Git views (The one we have plus two more)</li>
</ul>
</li>
<li>Possible extra credit: Integrate git-convert into the code so it converts JSON to field-definitions automatically</li>
<li>You should have at least fifty meaningful tests.</li>
<li>Polish.</li>
</ul>
<a class="anchor" id="jscs"></a>
<h2>JSCS</h2>
<p>I couldn&#39;t figure out what was going on with JSCS earlier in the quarter, or perhaps WebStorm was broken with ES6 code. At any rate, something has changed either in my head or in the world.</p>
<p>If you have not done so already, install JSCS globally:</p>
<p>  npm install -g jscs</p>
<p>Make sure JSCS <em><strong>is turned on</strong></em> in WebStorm. Go to <strong>Settings | Languages and Frameworks | JavaScript | Code Quality Tools | JSCS</strong> and make sure it is <strong>enabled</strong>.</p>
<p>Put this <strong>.jscsrc</strong> file in the root of your projects. Probably one for <strong>client</strong> and one for <strong>server</strong>:</p>
<pre><code class="lang-json">{
    <span class="hljs-attr">"preset"</span>: <span class="hljs-string">"google"</span>,
    <span class="hljs-attr">"validateIndentation"</span>: <span class="hljs-number">4</span>,    
    <span class="hljs-attr">"excludeFiles"</span>: [
        <span class="hljs-string">"**/node_modules/**"</span>,
        <span class="hljs-string">"**/config/**"</span>,
        <span class="hljs-string">"**/scripts/**"</span>,
        <span class="hljs-string">"**/bower_components/**"</span>,
        <span class="hljs-string">"**/field-definitions.js"</span>,
        <span class="hljs-string">"**/mock-user-info.js"</span>
    ],
    <span class="hljs-attr">"requireCamelCaseOrUpperCaseIdentifiers"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"maximumLineLength"</span>: <span class="hljs-number">120</span>
}
</code></pre>
<p>Go to <strong>Setting | Editor | Code Style | JavaScript</strong>. On the Settings tab, in the first section, called <strong>Before Parentheses</strong>, set <strong>In Function Expression</strong> to false (unchecked). This means there should be no space after the word <strong>function.</strong>. Our code should look like this: <strong>function() {}</strong>. Not like this <strong>function () {}</strong>. Note the space after the word function in the second example.</p>
<p>JSCS should pass for your files. You can probably make this happen by choosing <strong>Code | Reformat</strong> in WebStorm, or by running the NPM package called <strong>js-beautify</strong>, which should be installed on your system in the global ~/npm/bin directory. If it is not installed, install it. But I do most of my formatting with WebStorm not <strong>js-beautify</strong>.</p>
<p><img src="https://s3.amazonaws.com/bucket01.elvenware.com/images/jscs-config.png" alt="Hopefully works for you too"></p>
<p>Remember that you have a <strong>Gruntfile.js</strong> in <strong>GitExplorer/server</strong> directory. This means you can run <strong>grunt jscs</strong> over the <strong>GitExplorer/server</strong> directory without difficulty. I found it only moderately painful to copy it over to <strong>GitExplorer/client</strong> and run it over the client code as well. There were, however, some <strong>Punctuator</strong> errors that I could not eliminate. I do not, however, get the same errors in WebStorm, perhaps because it is using a more recent copy of JSCS. To be sure you have the latest:</p>
<p>  npm install -g jscs</p>
<a class="anchor" id="jscs-punctuator"></a>
<h2>JSCS Punctuator in ES6</h2>
<p>I can&#39;t get JSCS to accept our arrow functions which we use for binding this. In <strong>ElfLogger</strong>, for instance, I write this:</p>
<pre><code class="lang-javascript">setQuiet = (<span class="hljs-keyword">new</span><span class="hljs-type">Value</span>) =&gt; {
    <span class="hljs-built_in">this</span>.display = <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>;
};
</code></pre>
<p>This is well formed, if experimental, ES6 syntax. If I remove the semi-colon, then I get a missing semicolon complaint from JSCS. If I add the semicolon, then I get this error, which I usually see at the very top of my file:</p>
<p>  JSCS: expected end of node list but punctuator found</p>
<p><strong>NOTE</strong>: <em>When I got this error, the editor did not usually point right at the source of the problem. Instead, for me, it was often pointing at the first <strong>import</strong> statement at the top of the file. Eventually, I realized the problem was not the <strong>import</strong> statement, but the arrow functions. I found this to be quite confusing, and it took me several tries before I sorted it out. Once I removed the arrow function, however, the other JSCS errors were easier to find, and WebStorm pointed me at the place in the file where the error occurred.</em></p>
<p>The solution is to go back to the old syntax for binding <strong>this</strong>. In the constructor, I write the following:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.setQuiet = <span class="hljs-keyword">this</span>.setQuiet.bind(<span class="hljs-keyword">this</span>);
</code></pre>
<p>Now I can switch to the traditional method declaration syntax, and yet still have <strong>this</strong> properly bound. That is, <strong>this</strong> will be valid in the <strong>setQuiet</strong> method. The problem is not unique to this object, and you may need to make similar changes in multiple place to fix the problem.</p>
<p>For an example, look here:</p>
<ul>
<li><a href="https://gist.github.com/charliecalvert/cf20ae73a21bb34d6605a1f533c9d988">ElfLogger Gist</a></li>
<li><a href="http://www.ccalvert.net/books/CloudNotes/Assignments/React/ReactPropsMounted.html#logger">ElfLogger in ReactPropsMounted</a></li>
</ul>
<p>Really sorry about the arrow functions. It&#39;s easy to fix our code, easy to switch to the explicit bind syntax, but I&#39;m sad to see the arrow functions go. I liked them, and this seems like a trivial reason to give them up. But I mentioned earlier that there is a real debate about whether to include them or not in the final ES6. The silver lining is that it is good to learn more about <strong>bind</strong>.</p>
<a class="anchor" id="extra-credit-option-one"></a>
<h2>Extra Credit Option One</h2>
<p>This appears to be more than one way to achieve the goal I was looking for in the extra section. I&#39;ll give you both options and let you choose one or the other or both or what have you.</p>
<p>One option would involve letting <strong>git-convert</strong> curl the data, then generate the field definitions, then copy them into the client directory. That&#39;s a simple yet still very useful solution.</p>
<p>If you go this route, consider writing a Bash script:</p>
<ul>
<li>First line gets the data with <strong>curl</strong></li>
<li>In the second line run your JavaScript code and then pipe it into the appropriate file in the client directory using relative paths.</li>
</ul>
<p>You could possibly integrate your bash script into your <strong>package.json</strong> file as a task that was run before each start of your application. This post seems to go into some depth on <strong>pre</strong> and <strong>post</strong> scripts in <strong>package.json</strong>:</p>
<ul>
<li><a href="http://www.marcusoft.net/2015/08/pre-and-post-hooks-for-npm-scripting.html">Pre and Post Hooks for NPM Scripting</a></li>
</ul>
<p>He points to more documentation here:</p>
<ul>
<li><a href="https://docs.npmjs.com/misc/scripts">NPM Official Docs</a></li>
</ul>
<a class="anchor" id="extra-credit-option-two"></a>
<h2>Extra Credit Option Two</h2>
<p>An alternative solution for the Extra credit might look like this. Right now we import the field definitions:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> fieldDefinitions <span class="hljs-keyword">from</span> <span class="hljs-string">'../field-definitions'</span>;
</code></pre>
<p>I was thinking that instead of importing them, we generate them on the fly. We would use modified version of <strong>git-convert</strong> to generate the definitions. But in this case <strong>git-convert</strong> would be integrated into our code. We would simply run <strong>git-convert</strong> against the code we get back from GitHub when we call <strong>fetch</strong>. I like this solution because it is cool, but is probably not as efficient as the above version, since the code generation would be done at run time.</p>
<p>This solution would perhaps make it impossible to have a default set of data: we wouldn&#39;t know the structure of the fields until we queried the server for the JSON. On the other hand, the default data we display was perhaps more of a learning exercise than anything we want in a shipping product.</p>
<p>It&#39;s extra credit, so I leave it up to you how you solve these problems. Consider using a branch when making the changes, so that you can always go back easily to the code you had before you tried any major surgery.</p>
<a class="anchor" id="turn-it-in"></a>
<h2>Turn it in</h2>
<p>Add, commit, push, tag and branch. T</p>
<p>Git <strong>add</strong>, <strong>commit</strong> and <strong>push</strong>. Create a <strong>branch</strong> called <strong>midterm</strong> and then add a <strong>tag</strong> that you push to the origin. The <strong>branch</strong> and <strong>tag</strong> should both have the word <strong>midterm</strong> in their very short tag/commit message. If there is any doubt as to which folder and branch your midterm is in, be sure to spell it out. For instance, I would like to see something like this, even if you are using the defaults:</p>
<ul>
<li>Branch: <strong>midterm</strong></li>
<li>Tag: v6.00 with a message for <strong>midterm</strong></li>
<li>Folder: <strong>GitExplorer</strong></li>
</ul>
<p>You can update the <strong>midterm</strong> branch at any time until the actual due date for the assignment. Even then, I would probably prefer a late update to a broken program.</p>
<a class="anchor" id="shallow-button-clicks"></a>
<h2>Shallow Button Clicks</h2>
<p>By definition, enzyme <strong>shallow</strong> works with only one component at a time. When we use <strong>shallow</strong>, it is therefore not possible to check if a button click is working correctly since that involves the interaction of two components.</p>
<p>However, even when we use shallow, an onClick function can be created within a button test to validate that the button responds to clicks. We implement the <strong>onClick</strong> function as a callback, and then confirm that when we click the button the callback is executed.</p>
<p>Here is an example:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// button test</span>
it(<span class="hljs-string">'responds to a button click'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">//create variable to track button click status</span>
    <span class="hljs-keyword">let</span> clicked = <span class="hljs-literal">false</span>;
    <span class="hljs-comment">//create function to assign as onClick</span>
    <span class="hljs-keyword">const</span> callback = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        clicked = <span class="hljs-literal">true</span>;
    };

    <span class="hljs-keyword">const</span> wrapper = shallow(&lt;AddressShow onSetAddress = {callback} address={address}/&gt;);
    wrapper.find(<span class="hljs-string">'button#setAddress'</span>).simulate(<span class="hljs-string">'click'</span>);
    expect(clicked).toEqual(<span class="hljs-literal">true</span>);

});
</code></pre>
<p>Thanks to Andrew Wilson for inspiring this tip!</p>
<a class="anchor" id="contains-matching-element"></a>
<h2>Contains Matching Element</h2>
<p>Remember that for tests on some HTML elements we need to use <strong>containsMatchingElement</strong>. <strong>contains</strong> insists that all attributes for a tag match exactly, while <strong>containsMatchingElement</strong> allows you to match just one out of multiple attributes. In other words, it ignores attributes you don&#39;t care about. We have to use <strong>containsMatchingElement</strong> when testing some input controls or when testing for some button controls since they contain <strong>onChange</strong> or <strong>onClick</strong> functions, and it is not easy or perhaps not even possible to match a function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> inputElement = &lt;input <span class="hljs-keyword">value</span>=<span class="hljs-string">'Robin Dudette'</span>/&gt;;
<span class="hljs-comment">// Code omitted</span>
expect(wrapper.containsMatchingElement(inputElement)).toEqual(<span class="hljs-literal">true</span>);
</code></pre>
<p>This works even if the <strong>input</strong> control has a number of other attributes other than <strong>value</strong>.</p>
<a class="anchor" id="filter-tests"></a>
<h2>Filter Tests</h2>
<p>Also, notice the menu the tests give you. Note the p option for filtering files. Suppose one of your test files is called <strong>Foo.test.js</strong> and one is called <strong>Bar.test.js</strong>. Press <strong>p</strong> and enter <strong>Foo</strong>. Only <strong>Foo.test.js</strong> will run:</p>
<pre><code>Watch Usage
 › Press <span class="hljs-keyword">a</span> <span class="hljs-built_in">to</span> run all tests.
 › Press o <span class="hljs-built_in">to</span> only run tests related <span class="hljs-built_in">to</span> changed <span class="hljs-built_in">files</span>.
 › Press p <span class="hljs-built_in">to</span> <span class="hljs-built_in">filter</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">a</span> filename regex pattern.
 › Press q <span class="hljs-built_in">to</span> quit watch mode.
 › Press Enter <span class="hljs-built_in">to</span> trigger <span class="hljs-keyword">a</span> test run.

 pattern › Foo
</code></pre><p>The result might look like this:</p>
<pre><code> PASS src/__tests__/Foo.test.js
 React Foo Suite
 ✓ see if true is true (6ms)

<span class="hljs-keyword">Test </span>Suites: 1 passed, 1 total
Tests: 1 passed, 1 total
Snapshots: 0 total
<span class="hljs-keyword">Time:</span> 0.545s, estimated 1s
Ran all test suites matching "Foo".

Watch Usage
 › Press a to run all tests.
 › Press o to only run tests related to changed files.
 › Press p to filter by a filename regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.
</code></pre><p>Even though I had several tests in my <strong>tests</strong> folder, only the one that had <strong>Foo</strong> in its name was run.</p>
<ul>
<li><a href="https://facebook.github.io/jest/docs/api.html">More information in the docs</a></li>
</ul>
<a class="anchor" id="enospc"></a>
<h2>ENOSPC Error</h2>
<p>Please look here:</p>
<ul>
<li><a href="http://www.elvenware.com/charlie/development/web/JavaScript/JavaScriptReact.html#enospc">Elvenware React</a></li>
</ul>
<a class="anchor" id="props-single-node"></a>
<h2>Props Singe Node Error</h2>
<p>Please go here:</p>
<ul>
<li><a href="http://www.elvenware.com/charlie/development/web/JavaScript/JavaScriptReact.html#props-single-node">Elvenware React</a></li>
</ul>
</div></body></html>