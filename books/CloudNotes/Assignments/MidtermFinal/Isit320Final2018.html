<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>Isit320Final2018</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>Isit320Final2018</h1><p>Welcome to Isit320Final2018</p><ul><!--TOC_Start--><li><a href="#overview">Overview</a></li>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#endpoints">EndPoints</a></li>
<li><a href="#host-address-and-private-key-file">Host Address and Private Key File</a></li>
<li><a href="#refactor">Refactor</a></li>
<li><a href="#turn-it-in">Turn it in</a></li>
<li><a href="#extra-credit">Extra Credit</a></li>
<li><a href="#extra-credit-provision-repository">Extra Credit: Provision Repository</a></li>
<li><a href="#extra-credit-bumps-in-the-road">Extra Credit: Bumps in the Road</a></li>
<li><a href="#extra-credit-route-implementation">Extra Credit: Route Implementation</a></li>
<li><a href="#associate">Associate</a></li>
<li><a href="#charlie-notes">Charlie Notes</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="overview"></a>
<h2>Overview</h2>
<p>Pease see <a href="https://bc.instructure.com/courses/1626572/discussion_topics/8486355">this announcment</a> which covers some of the changes to the final discussed near the end of class on Wednesday.</p>
<p>You have a few major goals:</p>
<ul>
<li>To complete the <a href="https://www.elvenware.com/teach/assignments/Npm/SystemdServiceComplete.html">systemd Service Complete</a> assignment</li>
<li>To complete a modified version of the <a href="https://www.elvenware.com/teach/assignments/Aws/Ec2ProvisionRepo.html">EC2 Provision Repo</a> assignment</li>
<li>Get two applications running on AWS and turn in links to them.<ul>
<li>The custom aws-provision app described in this document.</li>
<li>A version of SystemCheck also described in this document.</li>
</ul>
</li>
<li>Create unit tests<ul>
<li>Create at least 10 Enzyme based tests of your client side code</li>
<li>Create SuperTest tests for each of the routes on the server</li>
</ul>
</li>
</ul>
<p>As subset of the second goal, you should write your own script that will clown your repository to the remote instance.</p>
<p>The <a href="https://www.elvenware.com/teach/assignments/Npm/SystemdServiceComplete.html">Service Complete</a> assignment is self-explanatory, but the EC2 Provision Repo needs some comment, which is provided below.</p>
<p>For extra credit, you can attempt to fully implement Aws-Provision in a branch called <strong>extra-credit.</strong> Do not deploy this version of the program to EC2. It should only be run locally as it could give other people too much power over your account. To be clear:</p>
<ul>
<li><strong>Final Branch</strong>: The <strong>final</strong> contains the custom <strong>Aws-Provision</strong> program that doesn&#39;t really do anything.<ul>
<li>Deploy this version to EC2.</li>
</ul>
</li>
<li><strong>Extra Credit Branch</strong>: Use the <strong>extra-credit</strong> branch to create a version of <strong>aws-provision</strong> that actually does something.</li>
</ul>
<p>The final branch ought to contain at least the <strong>aws-provision</strong>, <strong>scripts</strong> and <strong>system-check</strong> directories. The master branch should contain all the programs we have created.</p>
<a class="anchor" id="getting-started"></a>
<h2>Getting Started</h2>
<p>I don&#39;t see why we can&#39;t do our work in the existing <strong>aws-provision</strong> directory. I would however, like you to:</p>
<ul>
<li>Create a <strong>final</strong> branch and do your work in it.</li>
<li>As you start: <strong>elf-tagger &quot;starting final&quot; &quot;aws-provision&quot;</strong></li>
</ul>
<p>My tag looks like this:</p>
<pre><code>v1.<span class="hljs-number">1.24</span>  starting <span class="hljs-keyword">final</span> <span class="hljs-keyword">for</span> aws-provision <span class="hljs-keyword">on</span> branch <span class="hljs-keyword">final</span> <span class="hljs-keyword">with</span> tag v1.<span class="hljs-number">1.24</span>.
</code></pre><p><strong>NOTE</strong>: <em>It is finally time to get rid of the <strong>queryServer</strong> call to the endpoint <strong>/foo</strong>. We don&#39;t need it anymore since we will create many similar calls as part of this final.</em></p>
<a class="anchor" id="endpoints"></a>
<h2>EndPoints</h2>
<p>Here is a list of the endpoints I want you to implement in the custom Aws-Provision version created for this final. Here are the routes and the file in the <strong>server/routes</strong> directory in which they are found:</p>
<ul>
<li>index.js (all use AWS api)<ul>
<li>/associate-elastic-ip</li>
<li>/create-educate</li>
<li>/create-standard</li>
<li>/get-instance-status</li>
<li>/reboot-instance</li>
</ul>
</li>
<li>ssh-runner.js (all use ssh2)<ul>
<li>/run-get-started</li>
<li>/run-ubuntu-setup</li>
</ul>
</li>
<li>script-pusher (all use spawn)<ul>
<li>/copy-get-started</li>
<li>/remove-known-host</li>
</ul>
</li>
</ul>
<p>On the client end, I have my code refactored into a similar, but not identical, pattern.</p>
<a class="anchor" id="host-address-and-private-key-file"></a>
<h2>Host Address and Private Key File</h2>
<p>The <strong>routes/ssh-runner.js</strong> file must get its <strong>HostAddress</strong> (the Elastic IP of the server) and Private Key identity file from <strong>~/.ssh/config</strong> via the technique explained in the <a href="https://www.elvenware.com/teach/assignments/Linux/GetSshIpAndPrivateKey.html">Get SSH and Private IP</a> assignment. This is an important part of the assignment, as filling in the information by hand is among the time consuming parts of grading your assignment. Having to do it manually would definitely be a bumpy stretch in the process of grading any assignment.</p>
<a class="anchor" id="refactor"></a>
<h2>Refactor</h2>
<p>The following React classes should exist in <strong>client/src</strong>. Beneath each module name I add a few comments and/or the endpoints the module calls:</p>
<ul>
<li>App.js<ul>
<li>Links together the modules listed below in its render method</li>
<li>It does nothing else</li>
</ul>
</li>
<li>CreateAssociate.js<ul>
<li>/create-standard</li>
<li>/create-educate</li>
<li>/associate-elastic-ip</li>
<li>Maintains quite a bit of state.</li>
</ul>
</li>
<li>ElfHeader.js<ul>
<li>Show the Title and your name</li>
</ul>
</li>
<li>RunLocal.js<ul>
<li>/copy-get-started</li>
</ul>
</li>
<li>RunRemote.js<ul>
<li>/run-get-started</li>
<li>/run-ubuntu-setup</li>
</ul>
</li>
<li>Tools.js<ul>
<li>/get-instance-status</li>
<li>/reboot-instance</li>
<li>/remove-known-hosts</li>
</ul>
</li>
</ul>
<p>The URLs shown above, are not necessarily complete. I&#39;m just giving  you enough information so you can see which URL goes in which file. In our custom version, each route simply returns a simple JSON object with a few simple text fields.</p>
<a class="anchor" id="turn-it-in"></a>
<h2>Turn it in</h2>
<ul>
<li>elf-tagger &quot;finished final&quot; &quot;aws-provision&quot;<ul>
<li>If you need to do this more than once, just use the same strings each time. The git tag number will sort out their order.</li>
</ul>
</li>
<li>Merge your work into the <strong>master</strong> branch when you are done.</li>
</ul>
<p>Let me know which programs you want me to check to see if they are running correctly according the description in <strong>systemd Service Complete</strong>. If you have any doubt as to whether you are using the right port or the port name, then let me know what you used. For instance:</p>
<ul>
<li>Program: System Check</li>
<li>Port: 30034</li>
<li>Environment Variable: ELF_SYSTEM_CHECK_PORT</li>
</ul>
<p>Recall that the official list of ports and names is in <a href="https://www.elvenware.com/teach/assignments/Npm/SystemdServiceControl.html#official-ports">SystemdServiceControl</a>.</p>
<a class="anchor" id="extra-credit"></a>
<h2>Extra Credit</h2>
<p>Here are the extra credit sections. Each section that begins with the words <strong>Extra Credit</strong> are part of the extra credit portion of the final.</p>
<a class="anchor" id="extra-credit-provision-repository"></a>
<h2>Extra Credit: Provision Repository</h2>
<p>The EC2 Provision Repo assignment asked you to create a series of buttons and make sure that each one had an endpoint on the server. The goal for the final is to make the sure the endpoints actually perform the expected operations. This will involve using calls that we have covered multiple times in this class. In particular, you will need to:</p>
<ul>
<li>Copy script files from the local machine to the EC2 instance</li>
<li>Run the scripts on the remote machine</li>
<li>Use the AWS api to perform a few tasks such as:<ul>
<li>Create the instance</li>
<li>Link the Elastic IP to the instance</li>
</ul>
</li>
</ul>
<p>Be sure that the code in <strong>App.js</strong> is refactored into an appropriate set of React components.</p>
<p>Create or maintain at least ten unit tests at least three of which should use <strong>supertest</strong>.</p>
<a class="anchor" id="extra-credit-bumps-in-the-road"></a>
<h2>Extra Credit: Bumps in the Road</h2>
<p>At the time of this writing, the process of running even a correctly implemented <strong>aws-provision</strong> application will not go smoothly even under even the best of circumstances. For instance, the application should copy the JsObjects SLB script <strong>GetStarted</strong> to the server and then run it. Among other things, this script runs the following commands in a non-interactive manner:</p>
<pre><code>sudo apt update
sudo apt<span class="hljs-built_in"> upgrade
</span>sudo apt dist-upgrade
sudo apt autoremove
</code></pre><p>All this takes considerable time, and there is no good way at this stage to get feedback to the user. Once the <strong>GetStarted</strong> script is complete, it then reboots the system, which again takes time. By watching the command prompt, you can see the progress, so you, as a technical person, are not in the dark about what is happening. But clearly this is a less than optimal situation. Nevertheless, it does work, and improving the situation will have to wait till a later date, as we out of time this quarter.</p>
<p>For me, the whole process takes something like five minutes to complete. It is pretty nice to be able to completely provision an EC2 instance in five minutes without having to do anything more than select a few buttons. So the experience has its upside. I definitely want to improve the app, but at least this is a start.</p>
<a class="anchor" id="extra-credit-route-implementation"></a>
<h2>Extra Credit: Route Implementation</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Method</th>
<th style="text-align:left">Button Content (Text)</th>
<th style="text-align:left">Route to Endpoint</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/create-educate</td>
<td style="text-align:left">Use the <strong>AwsPromise</strong> code I gave you.</td>
</tr>
<tr>
<td style="text-align:left">/create-standard</td>
<td style="text-align:left">Use the <strong>AwsPromise</strong> code I gave you</td>
</tr>
<tr>
<td style="text-align:left">/associate-elastic-ip</td>
<td style="text-align:left">Use the AwsPromise code I gave you</td>
</tr>
<tr>
<td style="text-align:left">/script-pusher/copy-get-started</td>
<td style="text-align:left">Use the Node JS spawn API and scp</td>
</tr>
<tr>
<td style="text-align:left">/ssh-runner/run-get-started</td>
<td style="text-align:left">Use the SSH2 Package</td>
</tr>
<tr>
<td style="text-align:left">this.removeKnownHost</td>
<td style="text-align:left">Remove from KnownHost</td>
<td style="text-align:left">/script-pusher/remove-known-host</td>
</tr>
</tbody>
</table>
<a class="anchor" id="associate"></a>
<h2>Associate</h2>
<p>One of the trickiest parts of this process is getting the instanceId of a newly created instance and using it to bind an elastic IP to an instance.</p>
<p>You need two pieces of information to link an Elastic IP and instance:</p>
<ul>
<li>The allocationId of the Elastic IP</li>
<li>The instanceId of the instance you want to connect to</li>
</ul>
<p>Your milage may differ, but I maintain the <strong>allocationIds</strong> for both my standard and my educate account on the client side:</p>
<pre><code class="lang-javascript"><span class="hljs-attribute">const allocationIds</span> = {
    standard: <span class="hljs-string">'eipalloc-0f6a026c08de655a2'</span>,
    educate: <span class="hljs-string">'eipalloc-0e6db228b0e914bf1'</span>
};

<span class="hljs-attribute">const regions</span> = { standard: <span class="hljs-string">'us-west-2'</span>, educate: <span class="hljs-string">'us-east-1'</span> };
</code></pre>
<p>Note that I also track the region I use on both accounts. (Most of you will only use your educate account, but I show you how I track both pieces of data, since I want my code to work in both places. That is definitely not a requirement for the final, if you can get either educate or standard to work, then that is more than enough to do well on the final.)</p>
<p>In <strong>routes/aws/AwsPromise.js</strong>, around line 35, you find this code:</p>
<pre><code class="lang-JavaScript"><span class="hljs-selector-tag">resolve</span>({
    <span class="hljs-attribute">result</span>: <span class="hljs-string">'success'</span>,
    instanceData: data.Instances[<span class="hljs-number">0</span>],
    instanceTagged: tagData
});
</code></pre>
<p>The <strong>instanceData</strong> property contains the information about the created instance that is sent to us by AWS. Among the data sent is the <strong>instanceId</strong> of the new instance. On the client side, in the fetch call that starts off the process of creating a new instance, I write this code:</p>
<pre><code class="lang-javascript"><span class="hljs-selector-tag">that</span><span class="hljs-selector-class">.setState</span>({
    <span class="hljs-attribute">result</span>: json.result,
    instanceData: json.instanceData,
    allocationId: allocationIds.educate,
    region: regions.educate
});
</code></pre>
<p>Then in my constructor, I track the data send from the server:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.state = {
        result: <span class="hljs-string">'unknown'</span>,
        allocationId: allocationIds.standard,
        region: regions.standard,
        instanceData: {
            Architecture: <span class="hljs-string">''</span>,
            ClientToken: <span class="hljs-string">''</span>,
            ImageId: <span class="hljs-string">''</span>,
            InstanceId: <span class="hljs-string">'i-0b37f98105dd1a72c'</span>,
            InstanceType: <span class="hljs-string">''</span>,
            KeyName: <span class="hljs-string">''</span>,
            LaunchTime: <span class="hljs-string">''</span>,
            PrivateDnsName: <span class="hljs-string">''</span>,
            PrivateIpAddress: <span class="hljs-string">''</span>,
            PublicDnsName: <span class="hljs-string">''</span>,
            Hypervisor: <span class="hljs-string">''</span>,
            RootDeviceName: <span class="hljs-string">''</span>,
            RootDeviceType: <span class="hljs-string">''</span>
        }
    };
}
</code></pre>
<p>Note that I provide default values for several fields, but this is just to keep the program from faulting before I have chance to fill them in with real data. In other words, this default values are all replaced after I get the instance data for an instance from the server.</p>
<p><img src="https://s3.amazonaws.com/bucket01.elvenware.com/images/aws-provision-instanceid.png" alt="Some random version of my app just after instance is created"></p>
<p><strong>Caption</strong>: <em>Some random version of my app just after an EC2 instance is created. Note that the <strong>instanceId</strong> is displayed.</em></p>
<p>Now that we have the instanceId of the newly created instance, we can use it to associate our Elastic IP with the instance:</p>
<pre><code class="lang-JavaScript">associateElasticIp = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">//const that = this;</span>
    fetch(
        <span class="hljs-string">'/associate-elastic-ip?instanceId='</span> +
            <span class="hljs-keyword">this</span>.state.instanceData.InstanceId +
            <span class="hljs-string">'&amp;allocationId='</span> +
            <span class="hljs-keyword">this</span>.state.allocationId +
            <span class="hljs-string">'&amp;region='</span> +
            <span class="hljs-keyword">this</span>.state.region
    )
        .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{
            <span class="hljs-keyword">return</span> response.json();
        })
        .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parsed json'</span>, json);  
        })
        .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ex</span>) </span>{
            <span class="hljs-built_in">console</span>.log(
                <span class="hljs-string">'parsing failed, URL bad, network down, or similar'</span>,
                ex
            );
        });
};
</code></pre>
<p>Ultimately, it would probably make sense to automatically call associateElasticIp when we get the <strong>instanceId</strong> from the server, but I do yet do that. At this time, I want to complete each step separately so I can be sure it is working. Getting things to run more smoothly is work left for a later date. (Perhaps we&#39;ll do it this spring in Isit322?)</p>
<a class="anchor" id="charlie-notes"></a>
<h2>Charlie Notes</h2>
<p>Here are some key points I need to integrate into this document.</p>
<ul>
<li>We spent a lot of time learning lots of good stuff, but also trying to get everyone up to speed to do aws-provision, but we didn&#39;t quite make it, and I was reluctant to admit it. I see it now.</li>
<li>So the unofficial plan at this writing is to have all the implementation of the server side code for aws-provision be extra credit.</li>
<li>Instead, I want you to polish the earlier aws-provision assignment in the ways laid out in the SystemdServiceComplete (Links to an external site.)Links to an external site. assignment. The only addition is that I want all the server side methods, that just return placeholder JSON, to be checked with SuperTest code. I&#39;ll be more specific later, but essentially each server-side method should return something like {&quot;result&quot;: &quot;success&quot;, &quot;endpoint-called&quot;: &quot;&lt;YOUR ROUTE NAME LIKE /foo&gt;&quot;} and your SuperTest code should confirm that it can do that.</li>
<li>This empty, non-working version of aws-provision should be running on as a systemd service on EC2. When I click on the buttons, they should display the default JSON text guessed at above, and specified in more detail by end of day Friday.</li>
<li>You should also have a SystemCheck program which only checks methods on the client side running as an EC2 service on EC2. In other words, it never uses server/routes/ssh-runner, only script-pusher.js. It never uses SSH to check services running on other systems, it just checks the services running on the same instance of EC2 that it runs on. So uptime returns how long your EC2 instance has been up and running. (Please make sure you implement the whitelist!)</li>
<li>For extra credit, you can have a separate program in your repository in a branch called extra-credit, that actually tries to implement the server side methods in aws-provision. It doesn&#39;t have to be complete to get you at least some extra credit. Don&#39;t deploy this version to EC2. It is only in the aws-provision directory but in the extra-credit branch. The final branch should contain the version of the program that you deploy to EC2, the version that doesn&#39;t do anything. it is that version that should be merged into master. The extra-credit version is never merged into master, it stays in extra-credit. Make it very obvious that you did the extra credit so I notice that you did it and grade it. Assume I&#39;m a basket case and won&#39;t read a hint buried somewhere. If you did it, make it very clear that you did the extra credit.</li>
<li>Also, I&#39;m going to want to see some refactoring. I&#39;ll specify just what in the final document, but it is probably going to be close to what is already in the final.</li>
<li>In summary, the Systemd Service Complete assignment is your final, except that I want you to add your aws-provision program to it, as described above.</li>
</ul>
<p>Again, this is not the final version of the final, as it were, but hopefully, it is close enough to let you continue working until I get the updated text to you.</p>
</div></body></html>