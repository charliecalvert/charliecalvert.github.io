<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>LinuxFiles</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css"><link href="/libs/css/BootstrapIndex.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet" type="text/css"><script src="/libs/scripts/jquery.min.js"></script><script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/libs/scripts/elvenware.js" type="text/javascript"></script><script src="/libs/scripts/Control.js"></script></head><body><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/contents.html">About</a></li><li class="dropdown"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/development/index.html">Strongly Typed</a></li><li><a href="/development/web/index.html">Web & Scripts</a></li><li><a href="/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>LinuxFiles</h1><h3>Table of Contents</h3><ul><!--TOC_Start--><li><a href="#working-with-files-in-linux-and-os-x-">Working with Files in Linux (and OS X)</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#fileOverview">File Permission Overview</a></li>
<li><a href="#home">Where is my Home Directory?</a></li>
<li><a href="#listing-files-with-ls">Listing Files with ls</a></li>
<li><a href="#pwd">Change or Check Your Current Location: CD and PWD</a></li>
<li><a href="#copy">Copying or Moving Files</a></li>
<li><a href="#directories">Directories</a></li>
<li><a href="#more-examples">More Examples</a></li><!--TOC_End--></ul><h1 id="working-with-files-in-linux-and-os-x-">Working with Files in Linux (and OS X)</h1>
<p>In this page we explore performing basic file operations in Linux from
the command line (shell). The information you find here is geared
towards the Ubuntu family of releases, such as Ubuntu desktop, Ubuntu
server, Lubuntu, and the various Mint Linux flavors.</p>
<p>I should point out that the Mac also has a Unix style command prompt. As
a result, most of what I say here applies to a greater or lesser degree
to OS X. There are differences, however, between the Ubuntu Linux
command prompt and the Mac command prompt. I would suggest reading
through this text and mastering the Linux command prompt. Once you feel
comfortable with these commands, then start trying them on the Mac. Most
of them will work exactly as shown here. The variations, as a rule, are
easy to discover once you understand what it is you are trying to do.
For instance, on the Mac, the home directory is in the <strong>/user/</strong>folder,
while on Linux it is in the<strong>/home</strong> folder. Yes there is a difference,
but it is not an important difference. Or at least I personally don&#39;t
find it significant.</p>
<p>What is significant, however, is that Linux is the most popular
operating system in the cloud, and OS X is the popular system of under
30 types in the US. As a result, it can be very useful to begin to
understand how the Linux or Mac command line (shell) works.</p>
<h2 id="overview">Overview</h2>
<p>This page is designed to help new comers to Linux use the basic commands
needed to create, move and edit files are on the command line. The
following commands are covered:</p>
<ol>
<li>ls: List the contents of a directory</li>
<li>cd: Change directory</li>
<li>pwd:  Print my current working directory</li>
<li>cp: Copy a file</li>
<li>mv: Move a file</li>
<li>rm: Delete (remove) a file</li>
<li>mkdir: Create a directory</li>
<li>rmdir or rm -r: Delete a directory</li>
<li>sudo: When do I need to use sudo when working with files?</li>
<li>chmod: Change the file mode so you can read, write or execute a file</li>
<li>chown: Change the user and/or group that owns a file</li>
<li>fs: How much free space is available on my drive?</li>
</ol>
<p>In addition, I will briefly discuss the following text editors: nano,
vim, gedit and leafpad: This is not the place to learn how to use these
editors, but it is a good place to explain which of these editors you
might want to use and why.</p>
<p>The dozen core commands listed above give you the power you need to
master Linux file system. You may be asking yourself: &quot;Do I have to know
all these commands.&quot; In many cases, the answers is no. You might also
ask: &quot;Is this an exhaustive list?&quot; Again, the answer is no. I am trying
to employ a variation of the 80-20 rule here. These are the core
commands that most users need to most of the time. Ninety eight percent
of the time these twelve rules provide all the power you need. (The one
possible exception involves search for <a href="http://www.elvenware.com/charlie/os/linux/LinuxDays/LinuxFAQ.html#grep">text with
grep</a>
or <a href="http://www.elvenware.com/charlie/os/linux/LinuxDays/LinuxFAQ.html#finddir">files with
find</a>.
Those subjects are covered elsewhere.</p>
<p>I have tried to arrange the commands listed above in some kind of
reasonable order, from basic to esoteric. Some users may only need to
know the first command, and many users could get by with a knowledge of
only the first 6 or seven commands. After all, if you know how to copy
and move files, and you know how to create and delete directories, you
have a pretty good command of your system.</p>
<p>If however, you want to act as a system administrator who performs basic
configuration steps on your system, then you may need to know all these
commands. Getting a grasp of all of them requires more than a few
minutes work, but it is not a particularly difficult job. For instance,
if you know how to edit HTML files by hand, or write a beginning level
computer program, then you will find the task of mastering the basics of
the commands listed above to be relatively trivial.</p>
<h2 id="fileOverview">File Permission Overview</h2>
<p>In Linux, as in Windows, by default there are folders where you have
permission to manipulate files and other folders where you do not have
permissions. The rule that governs this issue is fairly easy to
understand:</p>
<ul>
<li>You have permission to edit all the files in your home directory.</li>
<li>Only the administrator (who is called root) has permission to edit
the rest of the files on your system.</li>
</ul>
<p>In Windows, the situation is much the same. You have permission to edit
the files in your My Documents directory, and in your home directory.
But if you go into the Program Files directory, or the Windows
directory, then you usually have to become administrator before you can
edtit a file.</p>
<p>In Windows, a feature called UAC (User Access Control) enforces this
rule. In Linux, a command called <strong>sudo</strong> is used to give you permission
to edit files outside your home directory. That is, it gives you
permission to temporarily become an administrator (super user) and
manage files owned by the system, or by other users. For now, I just
want to be sure you understand that you can edit files outside your home
directory, and that you use the <strong>sudo</strong> command to gain permission to
do so. The details of how that works will be discussed later in this
document.</p>
<p>NOTE: On Linux systems there is a user called <strong>root</strong> who has super
user (administrator) permissions. If you want to edit, rename or delete
a file owned by root then you need to use the <strong>sudo</strong> command to gain
permission to do so. If you are in a directory owned by root, then you
need to use <strong>sudo</strong> to copy files into that directory. The exact
mechanism for doing these things will be explained later in this
document.</p>
<h2 id="home">Where is my Home Directory?</h2>
<p>Knowing that you have permission to edit files in your home directory is
all well and good, but where, exactly is your home directory? Your home
directory is located here:</p>
<pre><code>/home/$USER
</code></pre><p>For instance, if my user names is charlie, then my home directory would
be located here:</p>
<pre><code>/home/charlie
</code></pre><p>This seems fairly straightforward, but there is a little twist that
Linux throws at you herer. When first arrive at the command prompt
(shell) for your Linux box, you usually see something like this:</p>
<pre><code>charlie@MyServer:~$
</code></pre><p>This prompt tells me that I am logged on to the machine called
<strong>MyServer</strong> as the user <strong>charlie</strong> and that I am currently located in
my home directory. If you study the prompt shown above, you probably
find it fairly easy to see the bit about being logged into a particular
server as a particular user. But how do you know you are in your home
directory? You can glean that information for the ~\$ symbol. In
particular, the tilde (~) is an alias for your home directory, and the
\$ is simply the symbol that tells you are at the root of the prompt.</p>
<p>You are probably familiar with the syntax of the Windows command prompt.
Consider the following prompt, which shows my home directory:</p>
<pre><code>C:\Users\Charlie&gt;
</code></pre><p>The greater than symbol (>) at the Windows prompt plays the same role
as the dollar sign symbol (\$) at the Linux prompt. It just tells you
that this is the beginning of the location where you can start typing in
commands. It is the beginning, or root, of the command prompt:</p>
<pre><code>charlie@MyServer:~$
C:\Users\Charlie&gt;
</code></pre><p>Despite all this explanation, there is probably still something that
does not quite make sense to you. What does it mean to say that the ~
symbol is an alias for the home directory. On Windows, we know from the
prompt that the home directory is <strong>C:\Users\Charlie</strong>. In Linux,
however, all we know is that the ~ symbol resolves to the home
directory. Above, I explained that the home directory for the user
<strong>charlie</strong> is located here:</p>
<p>/home/charlie</p>
<p>So, why doesn&#39;t the prompt just tell us that? Why can&#39;t Linux be more
direct? The answer is simply that Linux doesn&#39;t want to waste your time
pointing out the obvious. Unless the prompt specifically says otherwise,
you can just assume that you are in your home directory. After all, that
is where you spend more of your time. If you move to the bin directory,
or etc directory, then the prompt tells you that. Otherwise, it just
gives you the tilda (~) as a little reminder that you are still where
you have been all day long: you home directory.</p>
<p>Here, for instance, is what it looks like if you have navigated to the
etc directory:</p>
<p>charlie@MyServer:<strong>/etc\$</strong></p>
<p>Notice that that there is no tilde in the prompt. That means you are no
longer in your home directory.</p>
<h2 id="listing-files-with-ls">Listing Files with ls</h2>
<p>You can use the list command to list the files in a directory. Suppose
you are in your home directory. Suppose further that it contains two
subdirectories called Documents and Pictures, and a text file called
<strong>readme.txt</strong>:</p>
<pre><code>/home/charlie
-- Documents
-- Pictures
-- readme.txt
</code></pre><p>You can see the files in your directory by type the <strong>ls</strong> command.</p>
<pre><code>charlie@ShantiLinuxServer:~$ ls
Documents  Pictures  readme.txt
</code></pre><p>The dir command also performs the same task, though in the Linux world,
<strong>ls</strong> is more commonly used:</p>
<pre><code>charlie@ShantiLinuxServer:~$ dir
Documents  Pictures  readme.txt
</code></pre><p>You can get a long listing of the files with <strong>ls -l</strong> or <strong>dir -l</strong>.
That would be the letters L and S followed by a space, then the a dash,
then the letter L, all in lower case:</p>
<pre><code>charlie@ShantiLinuxServer:~$ ls -l
total 12
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Documents
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Pictures
-rw-rw-r-- 1 charlie charlie   21 Jan 31 19:47 readme.txt
</code></pre><p>The ls command reports that there are total of 12 files in this current
directory. Three of them are visible, and 9 are hidden. We will see how
to view the hidden files in just a moment. But for now, let&#39;s focus on
the 3 files we can see.</p>
<p>Starting on the left, we can see 6 groups of information:</p>
<ol>
<li><strong>drwxrwxr-x</strong>: The file or directory permissions</li>
<li><strong>2</strong>: The number of directories. More on this in a moment.</li>
<li><strong>charlie charlie</strong>: The owner of the directory or file, and the
group to which it belongs</li>
<li><strong>4096</strong>: The size of the file or directory block in bytes</li>
<li><strong>Jan 31 19:46</strong>: The date. Because no year is listed, we can assume
it was created in the current year</li>
<li><strong>Documents</strong>: The name of the directory or file</li>
</ol>
<p>The file permissions are always confusing to people who are new to
Linux. The topic is actually quite a bit simpler than it seems at first
glance. The following table may help you get oriented:</p>
<p>  Description             Abbreviation   Code</p>
<hr>
<p>  Execute                 x              1
  Write                   w              2
  Read                    r              4
  Read and Execute        rx             5
  Read and Write          rw             6
  Read, Write &amp; Execute   rwx            7</p>
<p>For now, you should just focus on the Description and Abbreviation
fields of the above table. The Code plays a useful role, but we need not
wrestle with that quite yet.</p>
<p>Here are the positions of the flags for the various people who may
attempt to use the file. The first position is set to d if it is a
directory, or - if it is a file. The next three positions apply to the
owner of the file, the next three to the group, and the last three to
everyone else. If you are a member of the group that has read, write and
execute permissions on a file, then you can read, write and execute the
file. Here is the table:</p>
<p>  Name        Location</p>
<hr>
<p>  directory   d---------
  owner       -rwx------
  group       ----rwx---
  other       -------rwx</p>
<p>Sometimes people prefer to present the same information in this format:</p>
<p>  Position   Meaning</p>
<hr>
<p>  1          Usually either d for directory or - for normal.
  2,3,4      The owner&#39;s read, write and execute permissions
  5,6,7      The group&#39;s read, write and execute permissions
  8,9,10     Everyone else&#39;s read, write and execute permissions</p>
<p>Here are the values of the flags themselves:</p>
<p>  Flag   Meaning</p>
<hr>
<ul>
<li>There is no value for this space. It is blank.
r      Read rights on the file
w      Write permission to edit or delete.
x      Rights to execute or list the files in a directory
s      Special set-UID or set-groupID flag. Rare. Ignore for now.</li>
</ul>
<p>Let&#39;s look at the permissions for Documents:</p>
<pre><code class="lang-{.code}">drwxrwxr-x
</code></pre>
<p>The d at the beginning means that this is a directory. Compare those
permissions with the permissions for <strong>readme.txt</strong>:</p>
<pre><code class="lang-{.code}">-rw-rw-r--
</code></pre>
<p>In this second example, the first space is empty. As a result, we can
assume that <strong>readme.txt</strong> is not a directory, but a regular file.
Conversely, we know that Documents is a directory because there is a d
in the first position of its permissions flags.</p>
<p>After the d in the permissions block for the Documents directory there
are three sets of letters:</p>
<pre><code class="lang-{.code}">d rwx rwx r-x
</code></pre>
<p>The first set of three letters mean that the owner of the file
(<strong>charlie</strong>) has read, write and execute permissions on the directory.
The second block of 3 letters mean that any member of the group
<strong>charlie</strong> has read write and execute permissions on the directory. The
final three letters mean that any one else has read and execute
permissions, but no write permissions. In effect, this means that
everyone beside the owner and the members of the group <strong>charlie</strong> can
read the name of the directory, and they can navigate into it, but the
can&#39;t delete or rename it.</p>
<p>Now let&#39;s look at the permissions for <strong>readme.txt</strong>:</p>
<pre><code class="lang-{.code}">-rw-rw-r--
</code></pre>
<p>We see from the blank first letter that this is a normal file, and not a
directory. The next three letters apply to the <strong>owner</strong>, who in this
case is <strong>charlie</strong>:</p>
<pre><code class="lang-{.code}">rw-
</code></pre>
<p>We can see that <strong>charlie</strong> has read and write permissions on this file,
but no execute permissions. The lack of execute permissions is not
really a statement about the range of control that <strong>charlie</strong> has over
the file so much as a statement about the capabilities of the file. This
is a text file that is meant to be read, and so it would not make sense
to try to execute it. Sometimes, we explicitly do not give the owner,
group or others the permission to execute a file that is meant to be
executed. But in this case, it is not really permissions that are at
stake. This is simply an implied, and rather oblique, comment about the
file itself.</p>
<p><strong>NOTE</strong>: It is perfectly legal to set execute permissions for a file
that contains simple text, and no code. For instance, you can set the
execute flag for readme.txt, even though any effort to execute it would
fail since it does not contain executable code. In other words, it
contains simple text, and has no code, in either binary or text format,
associated with it. It is therefore correct to say that it would not be
sensible to set the execute flag for <strong>readme.txt</strong>, but it would not be
illegal. Typically Linux files that can be executed either have a
<strong>.sh</strong> extension, or else they have no extension at all. For instance,
a file called <strong>RunMe.sh</strong> or <strong>RunMe</strong> might be possible to execute, so
long as the execute permissions are set on the file itself:</p>
<pre><code class="lang-{.code}">-rwxrw-r-x 1 charlie charlie 4 Feb 1 01:05 RunMe.sh
</code></pre>
<p>Let&#39;s continue our discussion of <strong>readme.txt</strong>. We can see that members
of the group <strong>charlie</strong> also have read and write permissions, but no
execute permissions:</p>
<pre><code class="lang-{.code}">rw-
</code></pre>
<p> Finally, we can see that everyone else can read the file, but not edit
it or delete it, nor can than they execute it:</p>
<pre><code class="lang-{.code}">r--
</code></pre>
<p>That&#39;s all I&#39;m going to say for now about the permissions section of the
long listing for directory or file.</p>
<p>Scan back up to the original listing, and you will see that second item
in second item in the row for the Documents and Pictures directory
contains the number 2, which I say refers to the number of directories.
What does that mean? In this case, both the Documents and Pictures
directory are empty. As a result, the are recorded as containing both
themselves and their parent directory. These would typically be shown as
a directory called . (a period) and a directory called .. (two periods).
Here is an example:</p>
<pre><code class="lang-{.code}">charlie@ShantiLinuxServer:~/Documents$ ls -la
total 8
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 .
drwxr-xr-x 6 charlie charlie 4096 Jan 31 19:50 ..
</code></pre>
<p>Both of these directories are normally hidden because they begin with a
period. To see the hidden directories in our home folder, we use the ls
-la command:</p>
<pre><code class="lang-{.code}">charlie@ShantiLinuxServer:~$ ls -la
total 48
drwxr-xr-x 6 charlie charlie 4096 Jan 31 19:50 .
drwxr-xr-x 3 root    root    4096 Jan 30 17:15 ..
-rw------- 1 charlie charlie  477 Jan 31 19:54 .bash_history
-rw-r--r-- 1 charlie charlie  220 Jan 30 17:15 .bash_logout
-rw-r--r-- 1 charlie charlie 3637 Jan 30 17:15 .bashrc
drwx------ 2 charlie charlie 4096 Jan 30 17:50 .cache
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Documents
drwxrwxr-x 2 charlie charlie 4096 Jan 31 19:46 Pictures
-rw-r--r-- 1 charlie charlie  675 Jan 30 17:15 .profile
-rw-rw-r-- 1 charlie charlie   21 Jan 31 19:47 readme.txt
drwx------ 2 charlie charlie 4096 Jan 31 19:54 .ssh
-rw------- 1 charlie charlie  608 Jan 31 19:47 .viminfo
</code></pre>
<p>In this listing, our familiar <strong>Documents</strong>, <strong>Pictures</strong> and
<strong>readme.txt</strong> items are still visible. We now also see a series of
hidden files or folders, each of which begin with a period. The period
character is used to create a hidden file or folder. In general, we hide
the files not to protect them, but simply to keep them out of the way
when the user is pursuing his normal course of work. Most of the time,
the user does not need to see all these files or folders, so they are
hidden away where they will not clutter the landscape. </p>
<h2 id="pwd">Change or Check Your Current Location: CD and PWD</h2>
<p>Despite all that is said above, you might still want some confirmation
as to the name of your current directory. Use the PWD command (Print
Working Directory) to always be sure you know your current location. In
the following code, I use pwd to navigate to the log directory from the
home directory:</p>
<pre><code class="lang-{.code}">charlie@MyServer:~$ pwd
/home/ubuntu
charlie@MyServer:~$ cd /var/log/
charlie@MyServer:~$:/var/log$ pwd
/var/log
</code></pre>
<p>In the code above, the prompt is in plain text. The commands and output
from the commands are shown in bold.</p>
<p>The first command issued at the shell prompt is <strong>pwd</strong>. To issue the
command, just type <strong>pwd</strong> and hit enter. This prints the working
directory. The output is <strong>/home/ubuntu</strong>, which is my home folder on
this machine.</p>
<p>I then navigate to the <strong>/var/log</strong> folder with the <strong>cd</strong>, or change
directory command. I then call <strong>pwd</strong> to print out the current
directory. The output produced is <strong>/var/log</strong>. If you want, you can now
optionally type <strong>cat boot.log</strong> to see the output of your boot log. (On
Windows, the command to view the contents of a file is <strong>type
filename</strong>. In Linux, it is <strong>cat filename</strong>, where catalogue is a
mnemonic for print out.</p>
<p>Since many users first need to understand the file system when working
with a web site, I will give another example that uses the /var/www
folder. This directory will not exist unless you have installed apache.
If you don&#39;t have apache installed on your system, you can just ignore
this section of the text, and move on to the discussion of copying
files.</p>
<p>If you are still here, then you will find the following code, I use pwd
to check my location, I navigate to to the <strong>/var/www/</strong> directory, I
create a directory called temp, I copy files into it.</p>
<pre><code class="lang-{.code}">ubuntu@domU-12-31-39-14-16-01:~$ pwd
/home/ubuntu
ubuntu@domU-12-33-37-17-14-01:~$ cd /var/www/
ubuntu@domU-12-33-37-17-14-01:/var/www$ pwd
/var/www
ubuntu@domU-12-33-37-17-14-01:/var/www$ sudo mkdir temp
ubuntu@domU-12-33-37-17-14-01:/var/www$ cd temp
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$ pwd
/var/www/temp
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$ sudo cp /home/ubuntu/* .
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$ ls -la
total 296
drwxr-xr-x 2 root root 4096 Oct 24 02:24 .
drwxr-xr-x 3 root root 4096 Oct 24 02:24 ..
-rw-r--r-- 1 root root 3103 Oct 24 02:24 Buttons.css
-rw-r--r-- 1 root root 2418 Oct 24 02:24 Twitter.js
-rw-r--r-- 1 root root 756 Oct 24 02:24 TwitterQuery.html
ubuntu@domU-12-33-37-17-14-01:/var/www/temp$
</code></pre>
<p>One of the lessons to be learned from the above is that the pattern ~\$
references your home directory. </p>
<h2 id="copy">Copying or Moving Files</h2>
<p>Here is how to copy a file into a a particular directory:</p>
<pre><code class="lang-{.code}">cp MyFile.txt MyDirectory/.
</code></pre>
<p>This command copies the file called <strong>MyFile.txt</strong> into the folder
called <strong>MyDirectory</strong>. The slash and dot at the end of the command say
that you are supposed to put the file that is being copied in the
position of the dot:</p>
<pre><code class="lang-{.code}">MyDirectory/MyFile.txt
</code></pre>
<p>Here is how to move the file called <strong>MyFile.tx</strong>t from its current
position to <strong>MyDirectory</strong>:</p>
<pre><code>mv MyFile.txt MyDirectory/.
</code></pre><p>Here is how to copy a file called <strong>MyPicture.png</strong> from the
<strong>Documents</strong> directory to the <strong>Pictures</strong> directory:</p>
<pre><code class="lang-{.code}">cp Documents/MyPicture.png Pictures/.
</code></pre>
<p>Note that when you give commands like this, they will only give you
feedback if they fail. If the command succeeds, it succeeds silently:</p>
<pre><code class="lang-{.code}">charlie@ShantiLinuxServer:~$ cp /home/charlie/Documents/MyPicture.png Pictures/.
charlie@ShantiLinuxServer:~$
</code></pre>
<p>Notice that there is no text at all at the prompt that appears after the
command executes. That means that you command succeeded.</p>
<p>Here is what you see if you try to copy a file that does not exist. Note
that in this case we see an error:</p>
<pre><code class="lang-{.code}">charlie@ShantiLinuxServer:~$ cp Documents/FooBar.png Pictures/.
cp: cannot stat `Documents/FooBar.png&#39;: No such file or directory
</code></pre>
<p>The cryptic words &quot;cannot stat&quot; means that the system cannot find your
file and report its status.</p>
<p>The following command will rename the file <strong>RunMy.sh</strong> to <strong>RunMe.sh</strong>:</p>
<pre><code class="lang-{.code}">mv RunMy.sh RunMe.sh
</code></pre>
<p>Note that we have used the move (mv) command to rename the file. This is
common practice in Linux.</p>
<h2 id="directories">Directories</h2>
<p>To delete an empty directory you can use <strong>rmdir</strong>. To delete a folder recursively, removing all its contents including nested sub-directories, use <strong>rm -r</strong>:</p>
<pre><code>rm -r &lt;my-folder&gt;
</code></pre><p>For instance:</p>
<pre><code>rm -r my-directory
</code></pre><h2 id="more-examples">More Examples</h2>
<p>This example below shows how to copy files from your home directory to
the <strong>/r/www</strong> directory. In particular, we are going to copy three
files called <strong>index.html</strong>, <strong>index.css</strong> and <strong>index.js</strong> to that
directory. In our example, <strong>index.html</strong> links in both <strong>index.css</strong>
and <strong>index.js</strong>.</p>
<p><strong>NOTE</strong>: <em>I&#39;m working on a local Linux box called<strong><strong>MountainPass</strong></strong>.
It is an instance of Ubuntu desktop 12.04. My user name
is<strong><strong>charlie</strong></strong>. So every time you see me write<strong><strong>charlie</strong></strong>, you
would write or see your user name. For instance, if you are on a default
EC2 instance, you would write or see<strong><strong>ubuntu</strong></strong>instead
of<strong>**charlie.</strong></em></p>
<p>Let&#39;s suppose you have used
<a href="/charlie/development/cloud/SshFtpsPutty.html#filezilla">Filezilla</a> to
copy files to a directory called <strong>Prog270</strong> located on a Linux machine.
Suppose further that the directory is a sub-directory of your home
directory. We can check our current location using PWD:</p>
<pre><code class="lang-{.code}">charlie@MountainPass:~/Prog270$ pwd
/home/charlie/Prog270
</code></pre>
<p>Let&#39;s get a listing of the files in the directory:</p>
<pre><code class="lang-{.code}">charlie@MountainPass:~/Prog270$ ls
index.css index.html index.js
</code></pre>
<p>As you can see, the Prog270 directory contains three files called
<strong>index.css</strong>, <strong>index.html</strong> and <strong>index.js</strong>. Let&#39;s see what files are
currently in the <strong>/var/www/</strong> directory:</p>
<pre><code class="lang-{.code}">charlie@MountainPass:~/Prog270$ ls /var/www
index.html
</code></pre>
<p>At this time there is only one file in <strong>/var/www.</strong> It is called
<strong>index.html</strong>. That file was put there as a default home page during
the install of the Apache web server. Our goal is to copy our three
files to the <strong>/var/www</strong> directory. When we are done, the original
default instance of <strong>index.html</strong> will be replaced with our new copy of
the file. We should also see <strong>index.css</strong> and <strong>index.js</strong> in the
<strong>/var/www</strong> directory.</p>
<p>Let&#39;s use the Linux <strong>sudo</strong> and <strong>cp</strong> commands to copy our files to
the <strong>/var/www</strong> directory:</p>
<pre><code class="lang-{.code}">charlie@MountainPass:~/Prog270$ sudo cp * /var/www/.
charlie@MountainPass:~/Prog270$
</code></pre>
<p>We need to use the <strong>sudo</strong> command because the <strong>/var/www</strong> directory
is owned by <strong>root</strong>, and the user <strong>charlie</strong>does not have permissions
to write to that directly. The sudo command allows us to &quot;do&quot; something
as the <strong>su</strong>, or superuser. In other words, it lets us become root for
a short time. The <strong>cp</strong>, command, of course, is the Linux command for
copying files. The end result of using the two commands together is to
copy the files from the <strong>Prog270</strong> directory to the <strong>/var/www</strong>
directory.</p>
<p>Let&#39;s take a look at the state of the <strong>/var/www</strong> directory after the
copy:</p>
<pre><code class="lang-{.code}">charlie@MountainPass:~/Prog270$ ls /var/www
index.css index.html index.js
</code></pre>
<p>As you can see, we have successfully copied the files <strong>index.css</strong>,
<strong>index.html</strong> and <strong>index.js</strong> to the <strong>/var/www</strong> directory. In this
process we intentionally overwrote the original copy of
<strong>/var/www/index.html</strong> with the new version of the file that we copied
from <strong>/home/charlie/Prog270</strong>. This was our goal, and so our task is
done. If Apache is set up right, and Port 80 is open, we can now go to a
web browser, point it at our Linux box, and see our new copy of
<strong>index.html</strong>. If we examine that file, we should find that it links
<strong>index.css</strong> and <strong>index.js</strong>.</p>
</div></body></html>