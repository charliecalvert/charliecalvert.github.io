<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>SshFtpsPutty</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap-theme.min.css"><!-- link(href='/libs/css/BootstrapIndex.css', rel='stylesheet', type='text/css')--><link href="/css/style.css" rel="stylesheet" type="text/css"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><script src="/components/jquery/dist/jquery.js"></script><script src="/components/angular/angular.js"></script><script src="/components/angular-route/angular-route.js"></script><script src="/components/bootstrap/dist/js/bootstrap.min.js"></script><!-- script(src='/libs/scripts/elvenware.js', type='text/javascript')--><script src="/libs/scripts/Control.js"></script><!-- script(src='http://localhost:35729/livereload.js')--></head><body><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/charlie/About.html">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/charlie/development/index.html">Strongly Typed</a></li><li><a href="/charlie/development/web/index.html">Web & Scripts</a></li><li><a href="/charlie/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/charlie/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>SshFtpsPutty</h1><p>Table of Contents</p><ul><!--TOC_Start--><li><a href="#overview">Overview</a></li>
<li><a href="#ping">Pinging a Machine</a></li>
<li><a href="#why-ssh-">Why SSH?</a></li>
<li><a href="#sshBasics">SSH Basics</a></li>
<li><a href="#sshKeys">SSH Between Machines with Authorized Keys</a></li>
<li><a href="#moreSsh">More on Using SSH to Access Another Machine</a></li>
<li><a href="#ssh-config">SSH Config</a></li>
<li><a href="#putty">Using Putty</a></li>
<li><a href="#connecting-to-an-ssh-server-with-putty">Connecting to an SSH Server with Putty</a></li>
<li><a href="#puttyGen">Creating Key Pairs with PuttyGen</a></li>
<li><a href="#pem">Convert a PEM File to a Putty PPK File</a></li>
<li><a href="#git-and-putty">Git and Putty</a></li>
<li><a href="#step-one-download">Step One: Download</a></li>
<li><a href="#step-two-bin-directory">Step Two: Bin Directory</a></li>
<li><a href="#step-three-putty-in-bin">Step Three: Putty in Bin</a></li>
<li><a href="#pageant">Loading a Private Key with Pageant</a></li>
<li><a href="#ec2-cloud-only">EC2 Cloud Only</a></li>
<li><a href="#ec2Trouble">Trouble Shooting the Connectiong to EC2</a></li>
<li><a href="#pscp">Secure Copy with pscp</a></li>
<li><a href="#filezilla">FileZilla</a></li>
<li><a href="#vnc">VNC Servers</a></li><!--TOC_End--></ul><h2 id="overview">Overview</h2>
<p>Learning about Networks, SSH, SFTP and Putty</p>
<p>The ability to communicate securely across a network is a fundamental
building block for those seeking expertise in Cloud computing. SSH is
protocol that supports very secure communication both for remote command
line sessions and for the Secure File Transfer Protocol (SFTP).</p>
<p>As a general rule SSH is part of the Unix world and not part of the
Windows world. Linux boxes come with SSH already installed or easily
installable, and Windows boxes have no understanding of the protocol. To
add SSH to Windows most people use a free tool called Putty, which is
explained in this document. To add SFTP to Windows and Linux, you can
use a tool called <a href="http://filezilla-project.org/">FileZilla</a>. You can
use FileZilla on Windows, or you can use Putty. For a relatively small
fee, you can also use an excellent tool called <a href="http://www.scootersoftware.com/">Beyond
Compare</a>. More details on SFTP clients
are available here:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Comparison_of_FTP_client_software">http://en.wikipedia.org/wiki/Comparison_of_FTP_client_software</a></li>
</ul>
<p>Linux users can follow this link to learn how to set up
<a href="/charlie/os/linux/LinuxDays/LinuxFAQ.html#ssh">SSH</a>, and then return to
this document to learn more.</p>
<h2 id="ping">Pinging a Machine</h2>
<p>Sometimes you might try to use SSH, SFTP or HTTP to communicate with a
machine and get an error. There could be many probable causes for
receiving an error when attempting to use one of these protocols. It is
usually best, however, to start at the beginning and determine whether
the machine with which you want to communicate is running and signed
into the network. One way to test if a machine is available on the
network is to go to the command prompt and try to <strong>ping</strong> it. If it
works, the session should look something like this:</p>
<pre><code class="lang-%7B.code%7D">C:\Users\Charlie&gt;ping <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.123</span>

Pinging <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.123</span> <span class="hljs-keyword">with</span> <span class="hljs-number">32</span> <span class="hljs-keyword">bytes</span> <span class="hljs-keyword">of</span> data:
Reply <span class="hljs-built_in">from</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.123</span>: <span class="hljs-keyword">bytes</span>=<span class="hljs-number">32</span> <span class="hljs-built_in">time</span>&lt;<span class="hljs-number">1</span>ms TTL=<span class="hljs-number">64</span>
Reply <span class="hljs-built_in">from</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.123</span>: <span class="hljs-keyword">bytes</span>=<span class="hljs-number">32</span> <span class="hljs-built_in">time</span>&lt;<span class="hljs-number">1</span>ms TTL=<span class="hljs-number">64</span>
Reply <span class="hljs-built_in">from</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.123</span>: <span class="hljs-keyword">bytes</span>=<span class="hljs-number">32</span> <span class="hljs-built_in">time</span>&lt;<span class="hljs-number">1</span>ms TTL=<span class="hljs-number">64</span>
Reply <span class="hljs-built_in">from</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.123</span>: <span class="hljs-keyword">bytes</span>=<span class="hljs-number">32</span> <span class="hljs-built_in">time</span>&lt;<span class="hljs-number">1</span>ms TTL=<span class="hljs-number">64</span>
Ping statistics <span class="hljs-keyword">for</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.123</span>:
Packets: Sent = <span class="hljs-number">4</span>, Received = <span class="hljs-number">4</span>, Lost = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>% loss),
Approximate <span class="hljs-built_in">round</span> trip times <span class="hljs-keyword">in</span> <span class="hljs-built_in">milliseconds</span>:
Minimum = <span class="hljs-number">0</span>ms, Maximum = <span class="hljs-number">0</span>ms, Average = <span class="hljs-number">0</span>ms

C:\Users\Charlie&gt;
</code></pre>
<p>On Windows, a session with PING ends by default after four iterations.
On Linux, however, the process of ping a machine will continue
indefinitely. To break out of the loop, press <strong>Ctrl-C</strong>.</p>
<p>When an attempt to ping a machine fails, your session might look like
this:</p>
<p><strong>C:\Users\Charlie>ping 192.168.0.167</strong></p>
<p><strong>Pinging 192.168.0.167 with 32 bytes of data:\
 Reply from 192.168.0.101: Destination host unreachable.\
 Reply from 192.168.0.101: Destination host unreachable.\
 Reply from 192.168.0.101: Destination host unreachable.\
 Reply from 192.168.0.101: Destination host unreachable.</strong></p>
<p><strong>Ping statistics for 192.168.0.167:\
 Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</strong></p>
<p><strong>C:\Users\Charlie></strong></p>
<p>Sometimes an admin for a machine will close down the service that
responds to pings, and hence a machine won&#39;t respond even though it is
running and on the network. However, as a general rule, if ping doesn&#39;t
work, then either the machine isn&#39;t running, or else the network isn&#39;t
set up right. (Or you might have the wrong address for the machine.)</p>
<p>If the ping succeeds but you can&#39;t browse or SSH to the machine you
pinged, then that often means that the machine does not have ports 80
and 22 open.</p>
<p>Pinging a machine is meant to be a way of asking the question: &quot;Are you
alive? Are you running?&quot;</p>
<h2 id="why-ssh-">Why SSH?</h2>
<p>SSH is a means of establishing identity on the web. If we are in the same room, I know who you are by looking at your face. If we talk on the phone, I can know who you are by recognizing your voice. Identity can also be established by a signature, or by asking a question that only certain people can answer can answer. None of these things work very well over the web, particularly when we are trying to prove our identity to an abstract entity such as a web site. Furthermore, over the web, we have to be able to transmit data in encrypted form so others can&#39;t see it.</p>
<p>SSH is designed as a means of proving our identity in the most secure and reliable manner possible. This is accomplished by means of creating a mathematically unique public/private key pair. We keep the private key, we give the public key to others. <em>If our private key matches the public key we gave to others, then we have proved our identity.</em> It&#39;s a bit like having two keys to a safety deposit box, both of which are needed to open the box. The bank has one key, we have the other. The box can&#39;t be opened unless both keys are present. Or, more simply, matching a public/private key is like recognizing a face or a voice: it is a means of establishing identity.</p>
<p>We create an SSH key pair like this:</p>
<pre><code>ssh-keygen -t rsa -P <span class="hljs-string">''</span> <span class="hljs-_">-f</span> ~/.ssh/id_rsa
</code></pre><p>At runtime, it looks like this:</p>
<pre><code>Generating public/private rsa key pair.
Your identification has been saved in id_rsa.
Your public key has been saved in id_rsa.pub.
The key fingerprint is:
SHA256:3C9oYoNjl/lfvQl/zHKHCUcIy75xUPVutRfhBlEmdhM charlie<span class="hljs-meta">@rohan-elf</span>
The key's randomart image is:
+---[RSA 2048]----+
|<span class="hljs-string">             *+E.</span>|
|<span class="hljs-string">          . o *.o</span>|
|<span class="hljs-string">         . + . +o</span>|
|<span class="hljs-string">       . .+ . o.+</span>|
|<span class="hljs-string">        S... . .+</span>|
|<span class="hljs-string">     . o .o.o....</span>|
|<span class="hljs-string">    + B o .++o.= </span>|
|<span class="hljs-string">   . + =  .o o+o*</span>|
|<span class="hljs-string">        ...   ++.</span>|
+----[SHA256]-----+
</code></pre><p>This generates two files that might have names like this:</p>
<ul>
<li>id_rsa        // The private key</li>
<li>id_rsa.pub    // The public key</li>
</ul>
<p>We hang onto the private key. We are the only ones who should ever have access to this key.</p>
<p>We give the public key to others when we want to be able to prove to them who we are. For instance, we might give a copy of our public key to GitHub or BitBucket. They associate this key with our account. Then we use SSH to help us match keys and prove our identity, prove that we are the owner of a particular account. Then we can access the resources associated with that account.</p>
<p>We are the only ones who have access to the private key, so when SSH matches our private key to a public key we have proved that we are who we say we are. The matching of our private key to a public key proves our identity.</p>
<p><strong>NOTE</strong>: <em>We frequently use public/private keys when we want to store something of ours with a third party. This is like putting money in a bank. The bank holds our money, and it gives us access to it when we prove who we are. GitHub stores our code, and gives us access to it when we prove who we are. In some cases, of course, the code on GitHub is free for everyone to view, but you need to prove who you are with SSH if you want to read-write access to it. Everyone has read access, but only those with special permission have read-write access.</em></p>
<p>Before we can use a private key, we generally have to load it. To load our private key, we can use a tools called ssh-add:</p>
<pre><code>$ ssh-<span class="hljs-keyword">add </span>id_rsa
<span class="hljs-symbol">Identity</span> <span class="hljs-keyword">added: </span>id_rsa (id_rsa)
</code></pre><p>No we are now ready to use SSH to contact a site and establish our identity on that site.</p>
<p>To recap, we have done three things in order to have a means of establishing our identity:</p>
<ul>
<li>Generated a key pair</li>
<li>Loaded the private key locally</li>
<li>Given the public key to a remote site that we want to access</li>
</ul>
<p>The remote site will now allow us to access resources, such as a Git repository. Why? Because they can match our private key to the public key we gave them. We are the only ones who have the private key, so <strong>we must be who we say we are.</strong></p>
<p>Now, suppose you copied your private key to another machine. Then you could load that private key on that machine and access your GitHub or BitBucket repository from that machine.</p>
<p>In fact, if you gave your private key to everyone in the world, then they too, at least in theory, could access your repository. But that would not be a very sensible thing to do.</p>
<p>At this point it should be fairly obvious that one could also use this strategy:</p>
<ul>
<li>Create a public private key pair on Machine A and put the public key on GitHub. Now Machine A can access your GitHub repository.</li>
<li>Create a public private key pair on Machine B and put the public key on GitHub. Now Machine B can access your GitHub repository.</li>
</ul>
<p>In other words, whether you copy the private key from Machine A to Machine B, or whether you create a new public/private key pair for each machine is a personal choice. Both strategies work. Which one you choose is up to you.</p>
<p>And here is one final piece of the puzzle. In our class, I ask each of you to give me permission to access your repository. But I don&#39;t have your private key. How come I can access your repository? The answer is that I have my own private and public key, and my public key is associated with my account. <strong>I can use my key pair to prove I&#39;m really me, and you have given me access to your repository.</strong></p>
<p><strong>NOTE</strong>: <em>When you give me access to your repository, what you are really saying is this: &quot;Give the owner of this account access to my repository.&quot; I then use my public private key to prove that I am the owner of that account, and therefore I can access your repository. It&#39;s all about establishing identity. I use SSH and a key pair to prove I&#39;m who I say I am. After that, everything is easy.</em></p>
<p>When you give someone else access to your account, what you are really saying is this:</p>
<ul>
<li>I trust this person</li>
<li>I trust that he can safeguard his private key.</li>
</ul>
<p>If I was untrustworthy, or if I was careless with my private key, then it would not be a good idea to give me access to your repository.</p>
<p>A final, more or less off topic note. If you think about what is going on here, you can see why an employee&#39;s integrity is one of their most sacred and valuable assets. If a company hires one of us, they are going to end up giving us access to valuable resources, and in particular, they are often going to trust us to use and safeguard our SSH keys. Obviously no company will ever want to hire someone they feel they cannot trust to be both honest and reliable in such matters. This is why people who cheat or who are chronically careless are playing a fool&#39;s game. If they are discovered cheating even once, then the gig is up. No one will want to hire them. Dishonesty is the classic example of risking short term, small gain for a long term, huge loss. Carelessness is easier to forgive, but it is hardly a trait that companies concerned about security actively pursue.</p>
<h2 id="sshBasics">SSH Basics</h2>
<p>SSH stands for Secure Shell. There are two common scenarios for using SSH:</p>
<ul>
<li>You want to gain access to a remote service such GitHub, LaunchPad or BitBucket</li>
<li>You want to open up a command line interface to a remote instance of an operating system. In most cases, the remote server will be a Linux or Mac box.</li>
</ul>
<p>SSH provides a secure means of communication between your local client machine and remote server. The authentication between the two machines is usually handled as follows:</p>
<ul>
<li>On the client, you load a private SSH key into memory.</li>
<li>You provide the server with a public key that matches your private key.</li>
<li>When you connect, the private and public keys are compared. If they match,  a connection is established.</li>
</ul>
<p>Below you will find a description of how to create a public/private key pair, and how to configure the client and server so that the keys can be matched and a connection established.</p>
<p>SSH clients are found on Linux, Mac and Windows. SSH servers are typically found on Linux or Mac boxes. A rough example of a Windows equivalent to an SSH client/server is Remote Desktop. The primary difference between Remote Desktop and SSH is that Remote Desktop gives you access to Windows machines, while SSH
gives you access to a wide range of services distributed across the Internet. In other words, Remote Desktop if a proprietary Windows service, and SSH is an open standard implemented across a range of platforms.</p>
<p>On Desktop machines, Windows is still the dominant operating system. Therefore, Remote Desktop is a very important protocol in most IT organizations. On the Internet, however, most machines are some variant of Linux, and many of the client machines are Macs. As a result, web developers and folks who want to
interact with the cloud need to know SSH.  </p>
<p>Here is a nice overview of the topic from our friends at Wikipedia:</p>
<p><a href="http://en.wikipedia.org/wiki/Secure_Shell">http://en.wikipedia.org/wiki/Secure_Shell</a></p>
<p>If you haven&#39;t already done so, follow this link to learn how to set up
<a href="/charlie/os/linux/LinuxDays/LinuxFAQ.html#ssh">SSH on Linux or the Mac</a>:</p>
<h2 id="sshKeys">SSH Between Machines with Authorized Keys</h2>
<p>This section is aimed at Linux and Mac users. If you use Windows, look below
for the section on Putty. It assumes that you have SSH installed. On Ubuntu, install SSH like this:</p>
<pre><code>sudo apt-<span class="hljs-keyword">get</span> install ssh
</code></pre><p><a href="http://www.elvenware.com/charlie/os/linux/LinuxDays/LinuxFAQ.html#ssh">http://www.elvenware.com/charlie/os/linux/LinuxDays/LinuxFAQ.html#ssh</a></p>
<p>Issue these commands to generate a key pair and copy the public key part into your <strong>authorized keys</strong>file:</p>
<pre><code class="lang-%7B.code%7D">    cd
    ssh-keygen -t rsa -P <span class="hljs-string">''</span> -f ~<span class="hljs-regexp">/.ssh/id</span>_rsa
    cat ~<span class="hljs-regexp">/.ssh/id</span>_rsa.pub <span class="hljs-meta">&gt;&gt; </span>~<span class="hljs-regexp">/.ssh/authorized</span>_keys
</code></pre>
<p>The code starts by moving you to your home directory with the <strong>cd</strong> command. After issuing the <strong>ssh-keygen</strong> command you will have a private key and matching public key. The private key is called <strong>id_rsa</strong> and the public key is <strong>id_rsa.pub.</strong> The last line ensures that a copy of the public key was also placed in a file called <strong>~/.ssh/authorized_keys</strong>. As you can see, this file is located in a directory called <strong>.ssh</strong>.</p>
<p>This is so important that I will repeat it in slightly different form:</p>
<ul>
<li><strong>ssh-keygen</strong> ensured that you have a private key and public key on your current machine. In this case they are called <strong>id_rsa</strong> and <strong>id_rsa.pub,</strong>where the latter is the public key.</li>
<li>The command to <strong>cat id_rsa.pub</strong> into <strong>authorized keys</strong> ensured that your machine also has a copy of your public key in its <strong>authorized keys</strong> file. The<strong>authorized_keys</strong>file lists the public keys for the machines that are allowed to visit it via SSH without having to type a password. It is this private key, public key pair that makes SSH without passwords possible.</li>
</ul>
<p>And place this at the bottom of your .bashrc file:</p>
<pre><code><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">"<span class="hljs-variable">$SSH_AUTH_SOCK</span>"</span> ] ; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">eval</span> `ssh-agent`
<span class="hljs-keyword">fi</span>
</code></pre><p>Now restart your shell. Not the whole machine, just the terminal window. Alternatively, you can force the OS to process your updated <strong>.bashrc</strong> by using the <strong>source</strong> command:</p>
<pre><code><span class="hljs-built_in">source</span> ~/.bashrc
</code></pre><p>Now load the key:</p>
<pre><code><span class="hljs-symbol">ssh</span>-<span class="hljs-keyword">add </span>~/.ssh/id_rsa
</code></pre><p>If all goes well you should see a message with the words <strong>Identity added</strong> in it. You are now ready to SSH to remote machine, or use Git or other tools to copy files to a remote server.</p>
<p>This script is not that useful, but it does help spell out the details off what you can do with ssh-keygen:</p>
<pre><code><span class="hljs-meta">#! /bin/bash
</span>
KEY_NAME=Test-Key
SSH_DIR=<span class="hljs-variable">$HOME</span>/.ssh
FULL_PATH=<span class="hljs-variable">$SSH_DIR</span>/<span class="hljs-variable">$KEY_NAME</span>
PUBLIC_KEY=<span class="hljs-variable">$FULL_PATH</span>.pub
AUTHORIZED_KEY_FILE=<span class="hljs-variable">$SSH_DIR</span>/authorized_keys_<span class="hljs-built_in">test</span>

<span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>
<span class="hljs-built_in">pwd</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$FULL_PATH</span>

<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">setupKey</span></span>() {
    <span class="hljs-comment"># -t: Type of key</span>
    <span class="hljs-comment"># -P: Passphrase which is initially empty</span>
    <span class="hljs-comment"># -f: The file name of the key to create</span>
    <span class="hljs-comment"># -v: Describe what you are doing</span>
    ssh-keygen -v -t rsa -P <span class="hljs-string">''</span> <span class="hljs-_">-f</span> <span class="hljs-variable">$FULL_PATH</span>
    cat <span class="hljs-variable">$PUBLIC_KEY</span> &gt;&gt; <span class="hljs-variable">$AUTHORIZED_KEY_FILE</span>

    <span class="hljs-comment"># Change the passphrase</span>
    ssh-keygen -p <span class="hljs-_">-f</span> <span class="hljs-variable">$FULL_PATH</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">removeKey</span></span>() {
    rm -v <span class="hljs-variable">$FULL_PATH</span>
    rm -v <span class="hljs-variable">$PUBLIC_KEY</span>
    rm -v <span class="hljs-variable">$AUTHORIZED_KEY_FILE</span>
}

<span class="hljs-comment"># removeKey</span>
setupKey
</code></pre><h2 id="moreSsh">More on Using SSH to Access Another Machine</h2>
<p>You can now SSH into your own <strong>localhost</strong> machine without being prompted for a password. To SSH to another machine you must copy your public key to that machine. But you need do nothing else to SSH into your own machine. Granted, there is not much utility in SSHing into your own machine, but it is a good exercise to help you see if everything is set up right. It might look a bit like this in practice, where the first line is the command you give to start the SSH session:</p>
<pre><code class="lang-%7B.code%7D">$ ssh localhost
The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-symbol">'localhost</span> (<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>)' can<span class="hljs-symbol">'t</span> be established.
ECDSA key fingerprint <span class="hljs-keyword">is</span> <span class="hljs-number">2</span>b:<span class="hljs-number">33</span>:<span class="hljs-number">64</span>:c1:<span class="hljs-number">42</span>:f9:<span class="hljs-number">08</span>:<span class="hljs-number">42</span>:f6:d3:<span class="hljs-number">4</span>e:<span class="hljs-number">7</span>e:<span class="hljs-number">92</span>:<span class="hljs-number">14</span>:<span class="hljs-number">32</span>:d4.
Are you sure you want <span class="hljs-keyword">to</span> continue connecting (yes/no)? yes
Warning: Permanently added <span class="hljs-symbol">'localhost</span>' (ECDSA) <span class="hljs-keyword">to</span> the list <span class="hljs-keyword">of</span> known hosts.
Welcome <span class="hljs-keyword">to</span> Linux Mint <span class="hljs-number">12</span> Lisa (GNU/Linux <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>-<span class="hljs-number">12</span>-<span class="hljs-keyword">generic</span> i686)

Welcome <span class="hljs-keyword">to</span> Linux Mint
 * Documentation:  http://www.linuxmint.com
</code></pre>
<p>Note that the above session includes text establishing the identity of a key fingerprint. This will occur the first time you SSH into a machine, even if it is localhost. You should, however, see this only one time. If you see it more than once, then someone might be trying to fool you into signing into a &quot;honeypot&quot; or fake machine designed to fool you into giving away some of your private information. (This is in fact an unlikely scenario, but it is not impossible.)</p>
<p>The odd thing about this example is that we enabling ourselves to SSH into the current machine. To exit the &quot;remote&quot; session to your local machine, type <strong>exit</strong>.  Now we are ready to SSH to a remote machine.</p>
<p>Here is a command that will enable you to copy your public key to another machine on the network. After issuing this command you should be able to SSH to a machine called <strong>BoxPrimary</strong> as user <strong>hadooper</strong> without having to type a password:</p>
<pre><code class="lang-%7B.code%7D">ssh-copy-id -<span class="hljs-selector-tag">i</span> <span class="hljs-variable">$HOME</span>/.ssh/id_rsa<span class="hljs-selector-class">.pub</span> hadooper@BoxPrimary
</code></pre>
<p>This command appends your key to the authorized_keys file of a remote machine. After copying the key to the remote machine, you should be able to SSH to that remote machine:</p>
<pre><code>ssh &lt;URL <span class="hljs-keyword">OR</span> IP <span class="hljs-keyword">OF</span> REMOTE MACHINE&gt;
</code></pre><p>For instance:</p>
<pre><code><span class="hljs-selector-tag">ssh</span> 192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.23</span>
</code></pre><p>For help setting up SSH, see the script called setupSsh.sh, as explained at the <a href="#scripts">end of this document</a>.</p>
<h2 id="ssh-config">SSH Config</h2>
<p>So here are a few words on the ~/.ssh/config file which can help you use SSH with less hastle.</p>
<p>To ssh directly to an EC2 ubuntu server, I put this in the config file:</p>
<pre><code>Host ubuntu
    HostName <span class="hljs-number">54</span><span class="hljs-selector-class">.XXX</span><span class="hljs-selector-class">.XXX</span><span class="hljs-selector-class">.XXX</span>
    Port <span class="hljs-number">22</span>
    User ubuntu
    IdentityFile ~/.ssh/ISIT320-<span class="hljs-number">01</span>.pem
</code></pre><p>In this example, 54.XXX.XXX.XXX is the IP address of the EC2 server. It would also be the name of a site, such as mysite.com. After saving my config file, I can access the site by just typing this:</p>
<pre><code><span class="hljs-attribute">ssh</span> ubuntu
</code></pre><p>To use Git to access a repository, I create a second entry in the ./ssh/config file that looks like this:</p>
<pre><code>Host bitbucket<span class="hljs-selector-class">.org</span>
    IdentityFile ~/.ssh/ISIT320-<span class="hljs-number">01</span>.pem
</code></pre><p>Now I don&#39;t need to worry about calling ssh-add. The key is loaded automatically whenever I access the <strong>bitbucket.org</strong> with git.</p>
<p>In its entirety, a config file might look like this:</p>
<pre><code>Host ubuntu
    HostName <span class="hljs-number">54.172</span>.<span class="hljs-number">9.41</span>
    Port <span class="hljs-number">22</span>
    User ubuntu
    IdentityFile ~/.ssh/ISIT320-<span class="hljs-number">01</span><span class="hljs-selector-class">.pem</span>

Host bitbucket<span class="hljs-selector-class">.org</span>
    IdentityFile ~/.ssh/ISIT320-<span class="hljs-number">01</span><span class="hljs-selector-class">.pem</span>

Host github<span class="hljs-selector-class">.com</span>
    IdentityFile ~/.ssh/github.key
</code></pre><p> You don&#39;t need to call chmod and set the privileges for the file. Just an ordinary text file created with a text editor like Geany, Vim, nano or gedit will work.</p>
<h2 id="putty">Using Putty</h2>
<p>Putty is a Windows client for SSH. It is free, open source and provides
you with a range of easy to use tools. Here is the link to a well known
location where you can download Putty:</p>
<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a></p>
<p>You can either download a compressed folder containing the files or
download the Windows installer. In most cases, it you will be happiest if you
run the Windows installer. If you prefer to download the compressed folder,
you can just unzip it, and then run the various programs found inside
it. However, I would unzip the folder to a location on your home drive
rather than trying to run it off a slow USB drive.</p>
<h3 id="connecting-to-an-ssh-server-with-putty">Connecting to an SSH Server with Putty</h3>
<p>The simplest way to use Putty is to open up the GUI client, enter the
address of a machine that has an SSH server, then click the Open button.
If you know the name and password for a user of the machine, then you
should be able to sign in to that machine.</p>
<p><img src="images/Putty01.png" alt="A Simple Putty Connection"></p>
<p><strong>Figure 01: The simplest possible way to use Putty. Specify the address
in the <em>Host Name</em> field, and press the <em>Open</em> button. A window will
open, use it to fill in your user name and password.</strong></p>
<p>Though the process outlined above is simple, it is not the easiest way
to use Putty. To make the process simpler, you will need to:</p>
<ul>
<li>Name and save the entry for your server. (See the Saved Sessions in
Figure01)</li>
<li>Specify a user name</li>
<li>Create a public and private key</li>
</ul>
<p>To use Putty properly, you can start with the steps shown in Figure 1.
Then you should give a name to your session and press the <strong>Save</strong>
button.</p>
<p><img src="images/Putty02.png" alt="Saving a session in Putty"></p>
<p><strong>Figure 02: In this screen shot you can see that the session has been
saved under the name <em>NorthSea</em></strong></p>
<p>Next, click on the <strong>Data</strong> field in the <strong>Category</strong> window and enter
your user name on the server.</p>
<p><img src="images/Putty03.png" alt="Enter a user name"></p>
<p><strong>Figure 03: Enter a username, then click on Session once again, and
save your work. (If you are signing into an EC2 Ubuntu instance, the
username is set, by default, to <em>ubuntu</em>. So in that case, don&#39;t write
your own name, write <em>ubuntu</em>.)</strong></p>
<p>After saving a session that contains a user name, you can click the open
button, or double click on your session name, and open your SSH window.
This time your user name is supplied automatically, and you only need to
enter a password. I often use Putty in this mode, but it gets tiring
having to type in the password each time.</p>
<p>If you take one more step and learn about public and private keys, then
you are on your way to becoming the master of Putty in particular and
SSH in general.</p>
<h2 id="puttyGen">Creating Key Pairs with PuttyGen</h2>
<p><strong>*NOTE</strong>: If you have downloaded a PEM key from AWS EC2, then you
should skip ahead to the section on<em>[</em>converting PEM files into PPK
files<em>](#pem)</em>. After reading that section you should should skip ahead
to the section on <a href="#pageant">Loading a Private Key with Pageant</a>. If you
are not using a PEM file, continue reading to learn how to create a
public/private key pair with PuttyGen. The key point to grasp is the
following: Normally you would use would use PuttyGen to create a
public/private key pair. However. If you downloaded a PEM private key
from someplace like EC2, then all you need to do is <a href="#pem">convert the PEM
file</a> into a Putty PPK file.*</p>
<p>Putty comes with an easy to use tool called PuttyGen that allows you to
generate a public/private key pair. You can also use PuttyGen as a
simple way to view the public key associated with a particular private
key.</p>
<p> The private key you keep on your client machine and you show to no one.
The public key you put on one or more servers in a file called
<strong>authorized_keys</strong> that is stored in the user&#39;s home directory in a
folder called <strong>.ssh</strong>:</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-regexp">/home/</span>someUserName<span class="hljs-regexp">/.ssh/</span>authorized_keys
</code></pre>
<p>The same folder is also commonly written like this:</p>
<pre><code class="lang-%7B.code%7D">~<span class="hljs-regexp">/.ssh/authorized</span>_keys
</code></pre>
<p>To create a public/private key first open PuttyGen and select <strong>Key |
SSH-2 RSA Key</strong> from the menu. Click the <strong>Generate</strong> button and move
the mouse around a bit.</p>
<p><img src="images/Putty04.png" alt="Generate a public private key pair with Putty"></p>
<p><strong>Figure 04: Generating a public private key pair with PuttyGen</strong></p>
<p><img src="images/Putty05.png" alt="PuttyGen as it looks after you have generated a public and private key
pair."></p>
<p><strong>Figure 05: PuttyGen as it looks after you have generated a public and
private key pair.</strong></p>
<p>You can, and perhaps should, associate password (passphrase) with your
key. Once you have done so, you should save the private key to a well
known location on your system, and optionally save the public key.
Saving the public key is optional since you can always view it by
loading your private key. In Figure 05, you can see the Public key in
the top of the window.</p>
<p>Once you have create your key pair, you should copy the Public key into
your clipboard (key buffer). Now you should open a command prompt on
your server, and paste your key into the<strong>authorized_keys</strong>file. There
is a bit of a chick and the egg problem here in some cases, but one
solution is to use Putty to open the command window, then load or create
the authorized keys file with the Nano editor, and finally right click
to paste the key from the clipboard into your file. If you are running
your Linux box in a VM, then there might be other ways for you to copy
the key into the appropriate file.</p>
<p><a href="images/Putty06.png"><img src="images/Putty06Small.png" alt="Pasting the public key into the authorized key
file."></a></p>
<p><strong>Figure 06: Pasting the public key into the authorized keys file. Click
to expand.</strong></p>
<p>You can use <strong>pscp</strong>, the Putty Secure Copy command to copy a file to a
remote machine. Suppose you have a connection in Putty that you have
named MyConnection. First back up your authorized_keys file; the
command I&#39;m about to show you will overwrite your authorized_keys file
if it exists. Make sure the Putty utility called <strong>pscp</strong> is on the
path, and then write the following at the command line, where
<strong>charlie</strong> is your user name on the Linux system:</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-selector-tag">pscp</span> <span class="hljs-selector-tag">MyPublicKey</span><span class="hljs-selector-class">.ppk</span> <span class="hljs-selector-tag">charlie</span>@<span class="hljs-keyword">MyConnection:.ssh/authorized_keys</span>
</code></pre>
<p>For more information, see the section below called <a href="#pscp">Secure Copy with
PSCP</a>.</p>
<p>As a general rule, you want the authorized keys file to be readable and
writable only by the owner, so you might give it 600 permissions:</p>
<pre><code>~<span class="hljs-regexp">/.ssh $ chmod 600 authorized_keys       
~/</span>.ssh $ <span class="hljs-keyword">stat</span> -c <span class="hljs-string">"%A %a %n"</span> authorized_keys
-rw------- <span class="hljs-number">600</span> authorized_keys
</code></pre><p>You have now completed the process of creating a private/public key
pair. Since you are probably not using a PEM file, and since you already
have your Putty private key, you should skip the next section on PEM
files, and go directly to the section on <a href="#pageant">Loading a Private key with
Pageant</a>.</p>
<h2 id="pem">Convert a PEM File to a Putty PPK File</h2>
<p><em>This section describes how to convert a PEM file from a source like EC2
into a Putty private key (PPK). If you are not working with PEM files,
you should skip this section and go to the section on <a href="#pageant">Loading a Private
Key with Pageant</a>.</em></p>
<p>A PEM file is a private key, but it is not in the format that Putty
expects. PEM files are generated by some SSH tools, notably the one used
on AWS. Since the format is different than that found in a Putty PPK
file, you need to convert it before you can use it with Putty.</p>
<p>Launch PuttyGen if it is not already running. Choose <strong>Conversions</strong>
from the menu and browse to the PEM file that you saved. After you
import the key, simple save the file as a Putty PPK file by selecting
<strong>Save private key</strong>. (Do not push the <strong>Generate</strong> button.) You will be
prompted for a password if you did not supply, but you can choose to
ignore that.</p>
<p><strong>NOTE</strong>: <em>Do not press the <strong>Generate</strong> button after you use the
<strong>Conversions</strong> menu. Your key was already generated on EC2. (Or
possibly it was generated on some other system, such as a local Linux
box.) You do not, and should not, <strong>generate</strong> the key. You are just
converting the key. After you convert it by using the menu item, you
should simple press the<strong>**Save private key</strong></em> <em>button. Don&#39;t press the
<strong>Generate</strong> button</em>!</p>
<p><img src="images/AmazonWebServices04.png" alt="AWS and PuttyGen"></p>
<p><strong>Figure 09: Converting the PEM file to a PPK file.</strong></p>
<p>After you have converted the PEM file to PPK, you should launch the
Putty tool called Pagaent, and load your PPK into it. See Figure 7 above
for a screen shot of the Pagaent tool. As you can see from the screen
shot, you need to select the <strong>Add Key</strong>button and add the key to
Pagaent. Figure 7 shows two different keys loaded, but you need only
load the one to access your EC2 instance. Also, see Figure 08 for a
means of making Putty explicitly aware of your PPK key. Be sure you have
also set the <strong>auto-login username</strong>in the <strong>Data</strong> dialog, as shown in
Figure 3. If you are trying to log into an EC2 instance, the default
user name is <strong>ubuntu</strong>. In general, you should make sure you complete
all the steps <a href="#putty">Using Putty</a> section found above, except for the
section on generating a PPK file. You have already done that.</p>
<p>Though you aren&#39;t quite ready yet to connect with Putty, still it might
be useful to see what it will look like when you do. In Figure 10 you
can see an example of what the EC2 SSH Shell looks like just after you
sign in with PuTTY. In this screen shot, the user has already filed in
all the fields of the Putty dialog and clicked connect. As the
connection takes place, a window opens that shows the text from a Linux
shell. You are placed at the command prompt for the shell, and can begin
issuing commands to configure Linux, or to move and copy files. Again,
don&#39;t try to do this yet, but you you will probably find it useful to
have this screen shot if you are want to confirm that you are
successfully logged into an EC2 Linux instance.</p>
<p><a href="images/AmazonWebServices05.png"><img src="images/AmazonWebServices05Small.png" alt="Browsing with
Putty"></a></p>
<p><strong>Figure 10: The SSH shell as it appears when you sign on to an AWS
server using PuTTY. From this command prompt you can control all the
features of the Linux OS. (Click to Enlarge)</strong></p>
<p>You have now finished converting the PEM file to a Putty PPK file.</p>
<p>You can now use the <strong>Category | Connection | SSH | Auth | Private key</strong>
field to associate this key with your Putty session. However, this does not
work quite as you hope if you have associated a password (passphrase) with
your private key. In fact, I usually leave this field blank, and instead use
a tool called Pageant.</p>
<h2 id="git-and-putty">Git and Putty</h2>
<p>On Windows, we have no built in SSH client. As result, we use a tool called Putty, which is an open source, third party, project.</p>
<h3 id="step-one-download">Step One: Download</h3>
<p>Putty comes in two forms:</p>
<ul>
<li>A zip file</li>
<li>A Windows installer</li>
</ul>
<p>If you are admin on your machine, use the installer, otherwise use the
zip file.</p>
<p>Download the zip  file or installer from here:</p>
<ul>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">Putty</a></li>
</ul>
<h3 id="step-two-bin-directory">Step Two: Bin Directory</h3>
<p>If you are not admin on your machine, you will need to decide where to put Putty. This is really a general issue, and not one limited just to Putty. In particular, we need a place to put executables and scripts that we will run frequently. This could be:</p>
<ul>
<li>C:\Users\UserName\Bin</li>
<li>%USERPROFILE%\Bin</li>
</ul>
<p>The two lines above are just two ways of saying the same thing. I show them both hoping that at least one of them will make sense to you. Create the <strong>Bin</strong> directory and put it on your path. Restart your command session.</p>
<h3 id="step-three-putty-in-bin">Step Three: Putty in Bin</h3>
<p>If you are not admin on your machine, then put the contents of the Putty zip file in your bin directory. Otherwise, just leave the Putty files where they were installed, but make sure they are on your path.</p>
<p>Create an environment variable called GIT_SSH. It should be set to:</p>
<pre><code>c:<span class="hljs-tag">\<span class="hljs-name">Users</span></span><span class="hljs-tag">\<span class="hljs-name">charles</span></span>.calvert<span class="hljs-tag">\<span class="hljs-name">Bin</span></span><span class="hljs-tag">\<span class="hljs-name">PLINK</span></span>.EXE
</code></pre><p>You can use the Windows GUI tools for manipulating the environment, or you can try using the built-in SETX utility:</p>
<pre><code>setx GIT_SSH=c:<span class="hljs-tag">\<span class="hljs-name">Users</span></span><span class="hljs-tag">\<span class="hljs-name">charles</span></span>.calvert<span class="hljs-tag">\<span class="hljs-name">Bin</span></span><span class="hljs-tag">\<span class="hljs-name">PLINK</span></span>.EXE
</code></pre><p>You will probably need to restart the Windows Command Line after making this change. To test your work, echo it from the command line. For instance:</p>
<pre><code>&gt;echo <span class="hljs-comment">%GIT_SSH%</span>
c:<span class="hljs-tag">\<span class="hljs-name">Users</span></span><span class="hljs-tag">\<span class="hljs-name">charles</span></span>.calvert<span class="hljs-tag">\<span class="hljs-name">Bin</span></span><span class="hljs-tag">\<span class="hljs-name">PLINK</span></span>.EXE
</code></pre><p>You should also make sure <strong>Git.exe</strong> is on your path. It can usually be found here. When working with this path, be careful to get the spaces right:</p>
<pre><code>C:<span class="hljs-tag">\<span class="hljs-name">Program</span></span> Files (x86)<span class="hljs-tag">\<span class="hljs-name">Git</span></span><span class="hljs-tag">\<span class="hljs-name">cmd</span></span>
</code></pre><p>Also Make sure you enter the following at the command prompt:</p>
<pre><code>git <span class="hljs-built_in">config</span> --global push.<span class="hljs-function">default</span> simple
</code></pre><p><strong>TIP</strong>: <em>Consider putting your SSH keys in an encrypted folder.</em></p>
<p>You might get this error:</p>
<pre><code>Cloning into <span class="hljs-string">'CloudNotes'</span>...
The serve<span class="hljs-string">r's host key is not cached in the registry. You
have no guarantee that the server is the computer you
think it is.
The server'</span>s rsa2 key fingerprint <span class="hljs-keyword">is</span>:
ssh-rsa <span class="hljs-number">2048</span> <span class="hljs-number">16</span>:<span class="hljs-number">27</span>:ac:a5:<span class="hljs-number">76</span>:<span class="hljs-number">28</span>:<span class="hljs-number">2</span>d:<span class="hljs-number">36</span>:<span class="hljs-number">63</span>:<span class="hljs-number">1</span>b:<span class="hljs-number">56</span>:<span class="hljs-number">4</span>d:eb:df:a6:<span class="hljs-number">48</span>
Connection abandoned.
fatal: Could <span class="hljs-keyword">not</span> read <span class="hljs-keyword">from</span> remote repository.

Please make sure you have the correct access rights
<span class="hljs-keyword">and</span> the repository exists.
</code></pre><p>Fix it like this:</p>
<pre><code><span class="hljs-selector-tag">plink</span> <span class="hljs-selector-tag">github</span><span class="hljs-selector-class">.com</span>
</code></pre><p>When they ask you to store the key in the cache, answer yes. Then use
CTRL-C to exit the process. (Don&#39;t log in.)</p>
<p>Check the contents of your .gitconfig file:</p>
<pre><code><span class="hljs-string">C:</span>\Users\charles.calvert&gt;type .gitconfig
[gui]
        recentrepo = <span class="hljs-string">C:</span><span class="hljs-regexp">/Users/</span>charles.calvert<span class="hljs-regexp">/Git/</span>JsObjects
        recentrepo = <span class="hljs-string">C:</span><span class="hljs-regexp">/Users/</span>charles.calvert<span class="hljs-regexp">/Git/</span>CloudNotes
[push]
        <span class="hljs-keyword">default</span> = simple
[user]
        email = charlie<span class="hljs-meta">@elvenware</span>.com
        name = Charlie at A134
</code></pre><h2 id="pageant">Loading a Private Key with Pageant</h2>
<p>Pageant is one of the most important tools in the Putty suite of utilities.
You can use it to keep your private key and password in memory. You can load this
file in the morning when you sign in, and then never have to enter the
password again until Pagaent is unloaded from memory. If you simply put your
computer to sleep at night, instead of shutting it down, then you can go for
days without ever having to think about passwords, Pageant or SSH. Everything
will simply work, very securely, without you having to do anything.</p>
<p>Figure 07 shows Pagaent running with two private keys loaded:</p>
<p><a href="images/Putty07.png"><img src="images/Putty07Small.png" alt="Pagaent"></a></p>
<p><strong>Figure 07: Using Pagaent. Click to expand.</strong></p>
<p>There are number of ways to load your key into pageant. If pageant is on your path, then you can do something like this:</p>
<pre><code>pageant %USERPROFILE%\Documents\Data\Putty\GitHub.ppk
</code></pre><p>Of course, the exact path to your private key will likely be different, but the general principles involved should be clear:</p>
<pre><code>pageant <span class="hljs-tag">&lt;<span class="hljs-name">PATH_TO_PRIVATE_KEY</span>&gt;</span>
</code></pre><p>If you have a DosAlias.bat file, or some similar tool that helps you set up your working environment, you could also add an &quot;alias&quot; to it:</p>
<pre><code>call doskey.exe sshadd=pageant C:<span class="hljs-tag">\<span class="hljs-name">Users</span></span><span class="hljs-tag">\<span class="hljs-name">charlie</span></span><span class="hljs-tag">\<span class="hljs-name">Documents</span></span><span class="hljs-tag">\<span class="hljs-name">Data</span></span><span class="hljs-tag">\<span class="hljs-name">Putty</span></span><span class="hljs-tag">\<span class="hljs-name">MyKey</span></span>.ppk
</code></pre><p>Then you can just type <strong>sshadd</strong> in order to load your key into Putty</p>
<p>Another alternative is it use the Windows Task Scheduler to start Pageant at System Startup. The first three pages in the Task Scheduler should look like this:</p>
<ul>
<li>General Page - No Changes</li>
<li>Triggers Page - At System Startup</li>
<li>Actions page, start pageant and pass in the path to your key as an argument<ul>
<li>&quot;C:\Program Files (x86)\PuTTY\pageant.exe&quot;</li>
<li>C:\Users\charlie\Documents\Data\Putty\Prog219-LastName.ppk</li>
</ul>
</li>
</ul>
<p>If you are not concerned with Git or similar tools, but want only to start an SSH session to a remote machine, you can also link to your private key directly from PuTTY, as shown
in Figure 08.</p>
<p><img src="images/Putty08.png" alt="Browse for your PPK"></p>
<p><strong>Figure 08: Browse for your PPK so PuTTY can use it for authentication.</strong></p>
<p>Finally, it is helpful if you have a way to be able to easily check to be sure that pageant is load. It is best if you can see Pageant in the <strong>notification area</strong>. Start pageant, then go to the do-hickey in the Windows Notification area and set &quot;Show icon and notifications. The Windows Notification Area is usually found at the bottom right of your screen, on the task bar.*</p>
<h2 id="ec2-cloud-only">EC2 Cloud Only</h2>
<p>Assume that you are on a heavily locked down machine, or perhaps a Chromebook, and want to connect to an EC2 instance. We assume that you can&#39;t install anything: not ssh, not putty, not cygwin -- absolutely nothing. All you have is a browser. How do you proceed?</p>
<p>You will need two tools:</p>
<ul>
<li><a href="https://codeanywhere.com">CodeAnywhere</a></li>
<li><a href="https://chrome.google.com/webstore/detail/secure-shell/pnhechapfaindjhompbnflcldabbghjo?utm_source=chrome-ntp-icon">Secure Shell</a> extension for Chrome</li>
</ul>
<p>Actually, there are other tools you can use, but these are the ones we are using in this case.</p>
<p>You will also need to know the following commands. The first two are run on CodeAnywhere. The last one is run in the Developer Tools for your Secure Shell web page.</p>
<ul>
<li>Convert a private key to public: <strong>ssh-keygen -y -f &lt;PRIVATE_KEY&gt; &gt; &lt;PUBLIC_KEY&gt;</strong></li>
<li>For instance: <strong>ssh-keygen -y -f id_rsa &gt; id_rsa.pub</strong></li>
<li>Give file readonly by owner only: <strong>chmod 400 &lt;FILE_NAME&gt;</strong></li>
<li>For instance: <strong>chmod 400 id_rsa</strong></li>
<li>Clear the .ssh folder from Secure Shell: <strong>term_.command.removeDirectory(&#39;/.ssh/&#39;)</strong></li>
<li>Details: Open the Developer Tools (F12) for Chrome and enter the command above.</li>
</ul>
<p>The last command works because secure shell is using the <a href="https://developer.mozilla.org/en-US/docs/WebGuide/API/File_System/Introduction">HTML5 file system</a>.  It will only work, of course, if you have opened the Developer Tools for the Secure Shell page.</p>
<p>Connecting to EC2 in this way involves several steps, which you can see on this video:</p>
<ul>
<li><a href="http://youtu.be/fZE_fLw7Qrg">Ec2ClodeOnly Vide</a></li>
</ul>
<p>The steps:</p>
<ul>
<li>Go to EC2, create your instance</li>
<li>Save (or upload) the EC2 PEM file to CodeAnywhere</li>
<li>On CodeAnywhere convert the SSH PEM file to a public file</li>
<li>Download the PUB file to your machine</li>
<li>Optionally move your keys to the directory where you save your keys</li>
<li>Remove the extension from the PEM file</li>
<li>Fill in the fields of the secure shell and connect</li>
</ul>
<h2 id="ec2Trouble">Trouble Shooting the Connectiong to EC2</h2>
<p>If you see, &quot;disconnected No supported authentication methods available
(server sent public key)&quot; and &quot;using user name Ubuntu server refused our
key,&quot; then you might try the following:</p>
<p>First find the key associated with your running instance, as shown in
Figure 10a. In this screenshot, you can see that the Key Pair is called
Elvenware006.</p>
<p><a href="images/Ec2KeyPair01.png"><img src="images/Ec2KeyPair01Small.png" alt="Finding the Key Pair for an EC2
instance"></a></p>
<p><strong>Figure 10a: Finding the Key Pair for an EC2 instance. (Click image to
expand)</strong></p>
<ul>
<li>Locate that key (PEM file) on your Windows machine. If you can&#39;t
find the key, it will probably be simplest to start over. Create a
new instance instance and a new key, and this time be sure that you
do not lose your key. Keep it secret! Back it up!</li>
<li>Run PuttyGen, choose<strong>Conversions</strong> from the menu,<strong>**and convert
the PEM key to a PPK file. Choose</strong>Save Private Key,<strong>as shown above
in Figure 09. When you save the PPK file, it would be wise to give
it the same name as the PEM file. For instance, I would name my file
</strong>Elvenware006.ppk<strong>. </strong> **</li>
<li>Run Pageant, right click on it in the taskbar tray, select the
<strong>Add</strong> button. Load in your PPK, as shown above in Figure 07. This
is redundant, but you should also load the key into Putty, as shown
in Figure 08. Don&#39;t forget to the set <strong>Connection | Data</strong> to
<strong>ubuntu,</strong>as shown in Figure 10b.</li>
</ul>
<p><img src="images/Ec2KeyPair02.png" alt="Set the authorized user to ubuntu"></p>
<p><strong>Figure 10b: Set the Auto-login username to ubunut.</strong></p>
<p>By this point, you should have everything set up correctly and should be
able to connect.</p>
<h2 id="pscp">Secure Copy with pscp</h2>
<p>If you want securely copy a file from a Windows machine to Linux box,
you can use the Putty utility called pscp (Putty Secure Copy). This is a
command line tool. If you want a more GUI driven interactive tool, I
recommend Filezilla, which is covered later in this document.</p>
<p>The best way to use pscp is to first set up a Putty connection to a
server, and save it. For instance, on my machine I have a connection
called WesternSea. I can use this connection to quickly and efficiently
open an SSH shell that places me at the command prompt for my Linux
instance. But there is more that I can do with that connection. Given
this connection, at the command prompt of my Windows machine, I can type
the following to copy a file from my Windows box to my Linux box. In the
example shown below, the first line is the command, and the second the
output generated by the command:</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-attribute">C</span>:\Users\Ch\Temp&gt;pscp MySite.zip charlie<span class="hljs-variable">@WesternSea</span>:/home/charlie/.
MySite.zip | <span class="hljs-number">75</span> kB | <span class="hljs-number">75.2</span> kB/s | <span class="hljs-attribute">ETA</span>: <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> | <span class="hljs-number">100%</span>
</code></pre>
<p>As you can probably surmise, the command copies the file MySite.zip to a
Linux box called WesternSea. In particular, the file ends up the
<strong>/home/charlie</strong> directory of the Linux box. Notice that when I copy
the file, I specify the name of the user and the name of the Putty
connection I have established for the Linux box:  <strong>charlie@WesternSea</strong>.
If you were working with an EC2 instance, you would probably use the
user <strong>ubuntu</strong> rather than <strong>charlie</strong>.</p>
<p>Tools like pscp can be run from batch files. It often makes sense to use
pscp in conjunction with another tool such as plink, which allows you to
execute a command on the remote machine. Thus, you can first copy a file
to the remote machine, then execute a command that acts upon that file.
For instance, you can copy a zip file to a remote machine, then use
plink to execute a script on the remote machine that unzips the file and
copies its content to a specific location.</p>
<p>Here is a simple plink command, which assumes you have a connection
called MyConnection all set up in Putty.</p>
<pre><code class="lang-%7B.code%7D">plink MyConnection <span class="hljs-keyword">ls</span>
</code></pre>
<p>This will give you a listing of your home folder on your Linux box.</p>
<p>If you want to execute a command that requires <strong>sudo</strong> permissions on
the remote machine, do something like this:</p>
<pre><code class="lang-%7B.code%7D">plink -t MountainPass sudo cp <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/Temp/</span>Twitter.js <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/.</span>
</code></pre>
<p>The command above, when run from the Windows command prompt, copies a
file on your Linux box from the <strong>Temp</strong> directory to the <strong>/var/www/.</strong>
directory. If you need to enter a password to run sudo, then the <strong>-t</strong>
argument passed to plink will offer TTY support for that operation. If
you don&#39;t include the <strong>-t</strong>, you may get errors about &quot;no tty present&quot;
and/or &quot;no askpass program specified.&quot;</p>
<ul>
<li><a href="http://tartarus.org/~simon/putty-snapshots/htmldoc/Chapter5.html#pscp">http://tartarus.org/~simon/putty-snapshots/htmldoc/Chapter5.html#pscp</a></li>
</ul>
<h2 id="filezilla">FileZilla</h2>
<p>The <a href="http://filezilla-project.org/">FileZilla</a> client is free and
supports SFTP. It allows you to copy (or mirror) files on your local
hard drive to some Linux server that supports SSH and SFTP. EC2 supports
these features automatically.</p>
<p>Connecting with FileZilla is a lot like using Putty, but the tool is
very powerful when it comes to copying and comparing files. To connect,
you will need to know:</p>
<ol>
<li>The URL (or IP address) of your Linux box</li>
<li>Your username and password for the Linux box. (On Ec2, by default,
the username is ubuntu.)</li>
</ol>
<p>To get started choose <strong>File | Site Manager (Ctrl-S)</strong> from the
FileZilla menu. Fill in the dialog with the host, the protocol, the
logon type and the user name.:</p>
<p><img src="images/Filezilla02.png" alt="FileZilla Site Manager dialog"></p>
<p><strong>Figure 0X: The FileZilla Site Manager dialog. Fill in the host, the
protocol, the logon type and the user name.</strong></p>
<p>If you want, go to the Advanced TAB to set up the location where you
want to copy files from and to. Click OK to save your work. Now reload
the Site Manager or use the little icon right below the <strong>File</strong> menu to
launch your session. Below you can see an active session with local
files on the left, and the files for my EC2 instance on the right.</p>
<p><a href="images/Filezilla01.png"><img src="images/Filezilla01Small.png" alt="Filezilla Connect to an EC2
image"></a></p>
<p><strong>Figure 0X: FileZilla logged into an EC2 instance running Ubuntu.</strong></p>
<p>Note that I&#39;m copying files to my home folder because I have rights in
my home folder. You can right click and choose<strong>upload</strong> to copy
files.<strong>**By default I won&#39;t have rights to create files in the
</strong>/var/www** folder.</p>
<p>Learn about using queues in FileZilla. Instead of just right-clicking
and choosing Upload, in FileZilla, select a group of files, right click,
and choose <strong>Add to queue</strong>. Choose <strong>File | Export</strong> and save your
queue to an XML file stored in a well known location. When you want to
copy your files, type <strong>Ctrl-P</strong> or choose <strong>Transfer | Process Queue</strong>
from the menu. When you want to run the queue again, choose <strong>File |
Import</strong>, retrieve your XML file from your well known location, and then
process the queue. The point is that the XML stores your selected files,
so that you don&#39;t have to continually select the same group of files and
copy them. If this gets old, try the <a href="#pscp">pscp and plink commands</a>.</p>
<p>One of the most useful commands is <strong>View | Directory Comparison.</strong> You
can compare files either by date or by file size. You can use this tool
to filter out all the files that are the same on your Windows box and on
your Linux box. In other words, it provides a means of seeing only the
files that you have updated on your Windows or Linux box, and ignoring
all the other files. To see a list of only the files that differ between
your selected directories on your Windows and Linux boxes:</p>
<ul>
<li>Select <strong>View | Directory Comparison | Hide identical files</strong>. Make
sure the check mark is now set before the <strong>Hide identical files</strong>
option.</li>
<li>Choose <strong>View | Directory Comparison | Enable</strong>, or else choose
<strong>Ctrl | O</strong>.</li>
</ul>
<p>The real trick is to memorize the <strong>Ctrl | O</strong> hotkey (Control - Capital
Oh). That will allow you to quickly switch back and forth between normal
and selected modes.</p>
<p>Learn more here:</p>
<pre><code><span class="hljs-symbol">http:</span>//wiki.filezilla-project<span class="hljs-meta">.org</span>/Other_Features
</code></pre><h2 id="vnc">VNC Servers</h2>
<p>A VNC server allows you to create a connection between a client machine
and the GUI for a server. This is like a Windows Remote Desktop session
where you can see the remote desktop and interact with it as you please.</p>
<p>VNC connections have two parts. There is the server, which in our case
will typically run on a Linux box. Then there is the client, which
displays the remote desktop, and which typically runs on a Windows box.
You can, of course, also run a VNC client on a Linux box and indeed that
is a common scenario. But in my case, when I use VNC, I am generally on
a Windows box and want to see a remote Linux desktop.</p>
<p>On Mint Linux desktop or Ubuntu desktop it is simple to get a VNC server
running. On Mint Linux, for instance, choose <strong>Application | Internet |
Desktop Sharing</strong>and share your desktop using VNC.</p>
<p><a href="images/Vnc03.png"><img src="images/Vnc03Small.png" alt="Setting up the VNC Server on Mint
Linux"></a></p>
<p><strong>Figure0X: Setting up the VNC Server on Mint Linux</strong></p>
<p>Then on Windows, I installed the <a href="http://www.tightvnc.com/">TightVnc</a>
client. To attach the client to a TightVNC server, at the TightVNC
client prompt type the ip address plus port 5901. If you just want to
attach to your Mint Linux desktop, you can leave off the port number.
But if you want to use the port number, it looks like this:</p>
<p><img src="images/Vnc02.png" alt="Connecting with TightVnc"></p>
<p>Below you can see a screenshot that shows VNC in action. In background I
have Mint Linux running on the Windows desktop inside of VirtualBox. The
foreground image shows TightVNC displaying the same desktop in an
interactive session.</p>
<p><a href="images/Vnc01.png"><img src="images/Vnc01Small.png" alt="Mint Linux: VNC in the foreground, VirtualBox in the
background"></a></p>
<p><strong>Figure 0X: Mint Linux: VNC in the foreground, VirtualBox in the
background.</strong></p>
<p>If you are running Ubuntu server, and particularly if you have a
lightweight <a href="/charlie/os/linux/XWinOpenBox.html">OpenBox</a> desktop
installed, then you might want to install TightVNC on the server so that
you can connect to your OpenBox desktop from a Windows machine. Here is
the command to install TightVNC server on Ubuntu:</p>
<p>\$ sudo apt-get install tightvncserver</p>
<p>And to start the server:</p>
<p>tightvncserver -nolisten tcp :1</p>
<p>On the client side (Windows) I like to run TightVNC Client, as shown
above, and this time the 5901 port will probably be needed.</p>
<p><a href="images/Vnc04.png"><img src="images/Vnc04Small.png" alt="VNC and OpenBox"></a></p>
<p><strong>Figure0X: VNC and OpenBox running on Ubuntu Server. Click to
enlarge.</strong></p>
<p>When VNC server runs, it create a file called <strong>xstartup</strong>in a <strong>.vnc</strong>
folder. Here is how I edited the file to get it to run OpenBox:</p>
<pre><code class="lang-%7B.code%7D">    charlie<span class="hljs-variable">@Whitecap</span><span class="hljs-symbol">:~/</span>.vnc<span class="hljs-variable">$ </span>cat xstartup
    <span class="hljs-comment">#!/bin/sh</span>

    <span class="hljs-comment"># xrdb $HOME/.Xresources</span>
    <span class="hljs-comment"># xsetroot -solid grey</span>
    <span class="hljs-comment"># x-terminal-emulator -geometry 80x24+10+10 -ls -title "$VNCDESKTOP Desktop" &amp;</span>
    <span class="hljs-comment"># x-window-manager &amp;</span>
    <span class="hljs-comment"># Fix to make GNOME work</span>
    export XKL_XMODMAP_DISABLE=<span class="hljs-number">1</span>
    exec ck-launch-session openbox-session
    <span class="hljs-comment"># /etc/X11/Xsession</span>
    nitrogen --restore
</code></pre>
<p>Frankly, I&#39;m not sure all that was necessary, it might have worked
correctly out of the box. But I needed to go to the command prompt once
in the VNC session and run Nitrogen to get the background setup.</p>
</div></body></html>