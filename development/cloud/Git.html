<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>Git</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap-theme.min.css"><link href="/libs/css/BootstrapIndex.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet" type="text/css"><script src="/components/jquery/dist/jquery.js"></script><script src="/components/angular/angular.js"></script><script src="/components/angular-route/angular-route.js"></script><script src="/components/bootstrap/dist/js/bootstrap.min.js"></script><script src="/libs/scripts/elvenware.js" type="text/javascript"></script><script src="/libs/scripts/Control.js"></script></head><body ng-app="elfApp"><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/about">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/development/index.html">Strongly Typed</a></li><li><a href="/development/web/index.html">Web & Scripts</a></li><li><a href="/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>Git</h1><p>Table of Contents</p><ul><!--TOC_Start--><li><a href="#git-basics">Git Basics</a></li>
<li><a href="#centers">Centers of Activity</a></li>
<li><a href="#git-guides-found-on-the-web">GIT Guides found on the Web</a></li>
<li><a href="#git-versus">Git vs DropBox</a></li>
<li><a href="#install-git-on-windows">Install Git on Windows</a></li>
<li><a href="#clone-on-desktop">Clone on Desktop</a></li>
<li><a href="#configuring-git">Configuring GIT</a></li>
<li><a href="#running-git">Running GIT</a></li>
<li><a href="#install-git-on-ubuntu-server">Install Git on Ubuntu Server</a></li>
<li><a href="#git-gui-basics">Git GUI Basics</a></li>
<li><a href="#git-help-command">Git Help Command</a></li>
<li><a href="#the-git-status-command">The Git Status Command</a></li>
<li><a href="#git-log">Git Log</a></li>
<li><a href="#git-show">Show History of a File</a></li>
<li><a href="#git-files">Working with Files in a Repository</a></li>
<li><a href="#typical">A Typical Git Session</a></li>
<li><a href="#the-gitignore-file">The GitIgnore File</a></li>
<li><a href="#create-a-new-repository">Create a New Repository</a></li>
<li><a href="#add-origin">More on git remote add origin</a></li>
<li><a href="#git-config-file">Git CONFIG File</a></li>
<li><a href="#git-overwrite-local-changes">Git Overwrite Local Changes</a></li>
<li><a href="#git-urls-and-ssh">Git URLs and SSH</a></li>
<li><a href="#what-url-is-my-connection-using-">What URL is My Connection Using?</a></li>
<li><a href="#the-ssh-key">The SSH Key</a></li>
<li><a href="#checklist">Git SSH Checklist</a></li>
<li><a href="#host-key-is-not-cached">Host Key is not Cached</a></li>
<li><a href="#amend-a-commit">Amend a Commit</a></li>
<li><a href="#clone-a-local-repository">Clone a Local Repository</a></li>
<li><a href="#git-remote">GIT Remote</a></li>
<li><a href="#working-with-branches">Working with Branches</a></li>
<li><a href="#merge-branches">Merge Branches</a></li>
<li><a href="#push-local-branch-to-remote">Push Local Branch to Remote</a></li>
<li><a href="#clone-a-local-repository">Clone a Local Repository</a></li>
<li><a href="#clone-a-specific-branch">Clone a Specific Branch</a></li>
<li><a href="#git-checkout-a-specific-branch">Git Checkout a Specific Branch</a></li>
<li><a href="#oldversion">Find Old Version of Code</a></li>
<li><a href="#replace-master-with-old-commit">Replace Master with Old Commit</a></li>
<li><a href="#comparing-two-branches">Comparing Two Branches</a></li>
<li><a href="#forking">Forking</a></li>
<li><a href="#fix-broken-fork">Fix Broken Fork</a></li>
<li><a href="#rebase">Rebase</a></li>
<li><a href="#restructure-you-repository">Restructure you Repository</a></li>
<li><a href="#permanent-delete">Permanent Delete</a></li>
<li><a href="#permenant-delete-with-bfg">Permenant Delete with BFG</a></li>
<li><a href="#git-deletions-and-workflow">Git Deletions and Workflow</a></li>
<li><a href="#undo-an-add-in-git">Undo an Add in Git</a></li>
<li><a href="#don-t-nest-repositories">Don&#39;t Nest Repositories</a></li>
<li><a href="#terminal-is-not-fully-functional">Terminal is Not Fully Functional</a></li>
<li><a href="#git-deletions-and-workflow">Git Deletions and Workflow</a></li>
<li><a href="#undo-an-add-in-git">Undo an Add in Git</a></li>
<li><a href="#merging-code">Merging Code</a></li>
<li><a href="#git-tag">Git Tag</a></li>
<li><a href="#miscelaneous-information">Miscelaneous Information</a></li>
<li><a href="#learn-about-nodejs">Learn about NodeJS</a></li>
<li><a href="#simpledb">SimpleDb</a></li>
<li><a href="#templating-engines">Templating engines</a></li>
<li><a href="#bitbucket-snippets">BitBucket Snippets</a></li><!--TOC_End--></ul><h2 id="git-basics">Git Basics</h2>
<p>Git is a free, open source version control system. It allows you to track the different 
versions of code that you produce. You can roll time back, finding old versions of
your code, and you can compare one version with another version.</p>
<p>Version control has been around a long time. What makes Git different is the way
it handles repositories. Git has a distributed model that allows you to clone repositories 
onto your local machine. In the past, there was only version of the repository, typically
somewhere on your local internet. Git is quite different, in that you can have multiple
versions of your repository. This means  you can have a local version of the repository 
and check in and check out from there before deciding that you want to push to the<br>main repository.</p>
<p>Git is a sophisticated tool, and it is not easy to learn. It is however, the dominant
tool of its kind, and with good reason. It is powerful, flexible, and robust. Ultimately,
Git is worth mastering. In fact, much of the basic functionality of Git is relatively
easy to master once you understand how it works.</p>
<h2 id="centers">Centers of Activity</h2>
<p>Below you find links to the main site for Git. You will also find their
download page and related links:</p>
<ul>
<li><a href="http://git-scm.com/">http://git-scm.com/</a> </li>
<li><a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a> </li>
</ul>
<p>There are many Git servers in the cloud. Here are two that everyone should know
about:</p>
<ul>
<li>GitHub: <a href="https://github.com/">https://github.com</a> </li>
<li>BitBucket: <a href="https://bitbucket.org/">https://bitbucket.org/</a></li>
</ul>
<p>You probably want to have accounts on both GitHub and BitBucket. Everyone uses
GitHub, and bitbucket competes by allowing you to have free private accounts.</p>
<h2 id="git-guides-found-on-the-web">GIT Guides found on the Web</h2>
<p>A video I put together:</p>
<ul>
<li><a href="http://youtu.be/p1obmWF6Nks">http://youtu.be/p1obmWF6Nks</a></li>
</ul>
<p>A free online book:</p>
<ul>
<li><a href="http://git-scm.com/book">The Git Book</a></li>
</ul>
<p>More useful links:</p>
<ul>
<li><a href="https://confluence.atlassian.com/display/BITBUCKET/bitbucket+101">BitBucket 101</a></li>
<li><a href="https://help.github.com/">https://help.github.com/</a></li>
<li><a href="http://git-scm.com/documentation">http://git-scm.com/documentation</a> </li>
<li><a href="http://en.wikipedia.org/wiki/Git_(software">http://en.wikipedia.org/wiki/Git_(software)</a>&gt;)</li>
<li><a href="http://www.garyrobinson.net/2014/10/git-in-two-minutes-for-a-solo-developer.html">2 MinuteGuide</a></li>
</ul>
<h2 id="git-versus">Git vs DropBox</h2>
<p>There are some tools such as DropBox, GoogleDrive and OneDrive that will automatically propagate changes to any machine that subscribes to updates. Git, on the other hand, is designed to let developers, or authors, work on a set of documents and then share them when and as needed. The advantages to the second scenario (git), for a certain type of activity, are two fold:</p>
<ul>
<li>No changes are seen until the author is ready to share them. We can work on a rough draft, or on an algorithm, until it is polished, and then share it. If code were propagated automatically as we made changes, we would likely &quot;break the build&quot; for other developers. Our half finished code would appear on others machines as we worked on it. Results of sharing half finished code could be errors in the compilation process (npm start fails to work), or unexpected bugs in working code. A related scenario, perhaps a bit closer to home, would be a student who does not want to share their work with their teacher until it is complete. Or conversely, wants to share it before it is complete in order to ask a question, but does not want to share just any version, but rather a particular version. If changes were propagated automatically, the student could not work on their code until the teacher had reviewed it.</li>
<li>From the other side, a developer might not want to see another person&#39;s changes until they are ready for them. Even if the code that was automatically propagated to their machine did work correctly, it can be disconcerting to have to program against services, objects and APIs that change without warning. </li>
</ul>
<p>I think all that goes at least some of the way to explaining why Git works the way it does.</p>
<p>Sharing documents is a good and common use of a tool like Git. When working with documents rather than code, the consequences of automatically pushing updates is less severe, but still real. Suppose I&#39;m putting together a list of steps that must be followed. If I accidentally leave out a few steps in my first draft, then people who are following my changes live are likely to be miffed that my guide does not work. Or perhaps we begin working on a description of a seven step process. We get to step 5, then get called to dinner, or head off to bed. People reading the document would then begin following my steps, only to find that the description is incomplete.</p>
<p>There are, of course, strong arguments for exactly the opposite kind of functionality. If I&#39;m taking notes on a lecture in Evernote, at the end of class I want them to be propagated automatically and immediately so I can access them as needed from home. There is no advantage in that scenario to any other system. Leaving a copy of my notes at school without being able to access them from home would have no advantages. I want to see all changes immediately on all machines where I log into Evernote.</p>
<p>The bottom line is that there are many different ways to share information in the cloud. The only way to learn which one is best for which task is to learn the tools, and begin experimenting with them. Everyone is working these things out for themselves just now. Unfortunately, students in the future will probably be told to use tool X for purpose Y, and tool W for Z. Neat and clean, but not nearly as fun as exploring this world on your own. We live in interesting times.</p>
<h2 id="install-git-on-windows">Install Git on Windows</h2>
<p>There are two applications you might want to install. The primary GIT application
is found here:</p>
<ul>
<li><a href="http://git-scm.com/">http://git-scm.com/</a> </li>
<li><a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a> </li>
</ul>
<p>When you run the install shown above, be sure to choose the option that gets GIT
on your path. Also, you will probably want to set GIT up to work with PLink 
(Putty), and you will want to choose an option that ensures that you have LF 
style line endings on files that you plan to use on a Linux box.</p>
<p>Because GitHub is so ubiquitous, you will probably want to install it&#39;s GUI 
front end also:</p>
<ul>
<li>GitHub: <a href="https://github.com/">https://github.com</a> </li>
</ul>
<p>You can use Git-Scm with Git-Hub, but there is no denying that the GitHub GUI 
makes dealing with repositories on GitHub very easy.</p>
<h2 id="clone-on-desktop">Clone on Desktop</h2>
<p>On GitHub, you might notice a button that says <strong>Clone on Desktop</strong>. 
If set up correctly, this button will allow you to clone a repository
using a GUI application. On Windows, this application is called <strong>GitHub
for Windows</strong>. For a variety of reasons, I think it is ultimately 
best to manage your Git repositories from the command line, but there
is no denying that this GUI interface can be useful, particularly
if you only plan to use GIT from Windows.</p>
<p>In theory, you should be able to just push the <strong>Clone on Desktop</strong> 
button and the process of installing <strong>GitHub for Windows</strong> should 
occur automatically. In practice, this does not always happen. 
Unfortunately, there are variety of reasons why this call might 
fail, depending on the browser and system you are using. My 
suggestion is to simply install <strong>GitHub for Windows</strong> manually, and 
then the button should begin working as you expect.</p>
<p>To install <strong>GitHub for Windows</strong> go to the first link below and 
push the big green button:</p>
<ul>
<li><a href="https://help.github.com/articles/set-up-git">GitHub for Windows Link</a></li>
<li><a href="http://github-windows.s3.amazonaws.com/GitHubSetup.exe">GitHub Windows download</a></li>
<li><a href="https://help.github.com/">GitHub Help pages</a></li>
</ul>
<p>A file called <strong>GitHubSetup.exe</strong> should soon be downloaded to your
downloads folder. You can run it from there. The install is a forehead
install, and should be navigable by everyone in your family from your
cat on up. I believe that it does not require admin privileges to run
this install.</p>
<p>While you are at it, and if you have not already done so, you should
also install git:</p>
<ul>
<li><a href="http://git-scm.com/downloads">Install GIT itself</a></li>
</ul>
<h2 id="configuring-git">Configuring GIT</h2>
<p>I describe how to use GitGui below. If you are working from the command line, go to your home directory and open <strong>.gitconfig</strong>. You may prefer to just view this file, and use the commands
mentioned below to edit it. Or, you could edit it directly. The changes that need to be made
are fairly obvious.</p>
<p>My .gitconfig looks something like this:</p>
<pre><code>[user]
email = someone@somewhere.com
name = Charlie CedarIsle Calvert
[push]
default = simple
[gui]
recentrepo = C:/Src/Git/Simple02
recentrepo = C:/Src/Git/Writing
recentrepo = C:/Src/Git/CloudNotes
recentrepo = C:/Src/Git/JsObjects
</code></pre><p>As you can see, I&#39;ve set up the <strong>email</strong>, <strong>name</strong> and <strong>push | default</strong> options.
If you don&#39;t set up your user name and email as described above,
you may see this message at some point:</p>
<pre><code>Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly:

    git config --global user.name &quot;Your Name&quot;
    git config --global user.email you@example.com

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author
</code></pre><p>To resolve this message, just follow the instructions. For instance, you could type
something like the following:</p>
<pre><code>    git config --global user.name &quot;Charlie Calvert on EC2&quot;
    git config --global user.email charlie@example.com
</code></pre><p>When you do this, you are changing the settings in your <strong>~/.gitconfig</strong> file.</p>
<p>If you type the last suggested command, the one about amending your commit,
you may end up in an editor such as <strong>nano</strong> or <strong>vim</strong>. If you can 
handle that, then go ahead and do it, otherwise, you can relatively safely skip
that step. All that will be missing is the name of the committer in your repository
for this particular commit. Later commits will have your name.</p>
<p>You may also see a message like this:</p>
<pre><code>warning: push.default is unset; its implicit value is changing in
Git 2.0 from &#39;matching&#39; to &#39;simple&#39;. To squelch this message
and maintain the current behavior after the default changes, use:

  git config --global push.default matching

To squelch this message and adopt the new behavior now, use:

  git config --global push.default simple
</code></pre><p>I respond to this message by typing the following:</p>
<pre><code>git config --global push.default simple
</code></pre><p>For those who are interested, let&#39;s leave the command line and discuss GitGui. 
When you first open GitGui, you should set up your user name and 
email. From the menu, select <strong>Edit | Options</strong>.</p>
<p>What you write in the GitGui options ends up in the email and name 
fields of <strong>.gitconfig</strong>, and vice-versa. It is important to have both 
of these fields filled out from the start. </p>
<p>If you change the information for a particular repository in GitGui 
so that it differs from your global values, then that information 
will appear in the config file from your repository. If it is the 
same as the global values, the same as the values .gitconfig, then 
it will not appear in the config file for your repository.</p>
<p>There is a third option beyond what is mentioned above. You can look at 
the <strong>.git/config</strong> file from a particular repository. Remember that <strong>.git</strong> 
directory is hidden on both Windows and Linux. I usually only open config file
if I want to change the URL for a repository, but you can do more in there
if you want. For now, I&#39;ll leave those options up to you to explore.</p>
<h2 id="running-git">Running GIT</h2>
<p>If you use Putty, it will probably be simplest for you if you use GIT with 
plink, which is part of Putty. During the GIT SCM install, you have the 
chance to set this up, as shown in the screenshot below:</p>
<p><img class="small" src="http://elvenware.com/charlie/development/cloud/images/GitScm01.png" alt="Use plink"></p>
<pre><code>![Use plink](http://elvenware.com/charlie/development/cloud/images/GitScm01.png)
</code></pre><p>If you have already installed GIT, don&#39;t despair! All the option above does is 
set an environment variable named GIT_SSH. If you chose the option shown in the
screenshot, then when you type SET at the command line, you should find something
like the following value for GIT_SSH: </p>
<pre><code>GIT_SSH=C:\Program Files (x86)\PuTTY\plink.exe
</code></pre><p>Since you have a deep knowledge of envirnment variables, you know how to modify
this variable using the Environment Variables dialog.</p>
<p><img class="small" src="http://elvenware.com/charlie/development/cloud/images/GitScm02.png" alt="Set GIT_SSH env variable"></p>
<pre><code>![Set GIT_SSH env variable](http://elvenware.com/charlie/development/cloud/images/GitScm02.png)
</code></pre><p>Here is an example of how to configure the variable:</p>
<p><img src="http://elvenware.com/charlie/development/cloud/images/Git07.png" alt="Set the GIT_SSH environment variable"></p>
<p>If you have been living a sheltered life, you can learn about about 
environment variables here:</p>
<p><a href="http://www.elvenware.com/charlie/os/windows/faq.html#environment">http://www.elvenware.com/charlie/os/windows/faq.html#environment</a></p>
<p>A related issue is the &quot;Host Key is not Cached&quot; error, which is discussed 
elsewhere in this document.</p>
<h2 id="install-git-on-ubuntu-server">Install Git on Ubuntu Server</h2>
<p>It may be helpful to setup a default editor. You can do so by running either of 
the following at a *nix command prompt:</p>
<pre><code>export EDITOR=nano
export EDITOR=vim
</code></pre><p>Now install git:</p>
<pre><code>sudo apt-get install git
</code></pre><p>Create a directory named git and navigate to it:</p>
<pre><code>mkdir git
cd git
</code></pre><p>Now pull down a repository that you do not own, and hence will be in read only
mode:</p>
<pre><code>git clone git://github.com/charliecalvert/JsObjects.git
</code></pre><p>You can go to GitHub and create a repository and put a readme file in it. If you
own the repository, or have rights to it, then the command might look more like
this:</p>
<pre><code>git clone https://github.com/charliecalvert/bc-basic.git
</code></pre><h2 id="git-gui-basics">Git GUI Basics</h2>
<p>First line for HTTPs clone:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects.git">https://github.com/charliecalvert/JsObjects.git</a></li>
</ul>
<p>Second line, say where you want it on your system:</p>
<ul>
<li>C:\Users\MyUserName\Documents\GitHub\JsObjects</li>
</ul>
<p><img class="small" src="http://www.elvenware.com/charlie/development/cloud/images/GitGui04.png" alt="Clone Repository"></p>
<pre><code>![Clone Repository](http://www.elvenware.com/charlie/development/cloud/images/GitGui04.png)
</code></pre><p>Do a pull with GitGui:</p>
<ul>
<li>Remote | Fetch From Origin</li>
<li>Merge | Local Merge</li>
</ul>
<p>The following images take you step by step through the process 
of committing changes to a repository. </p>
<ul>
<li>First we edit one or more files in our repository.</li>
<li>Open the repository in GitGui</li>
<li>Examine unstaged changes</li>
<li>Stage the changes</li>
<li>Compose a commit message </li>
<li>Commit the changes</li>
<li>Push</li>
</ul>
<p><img class="small" src="http://www.elvenware.com/charlie/development/cloud/images/GitGui07.png" alt="Unstaged Changes"></p>
<pre><code>![Unstaged Changes](http://www.elvenware.com/charlie/development/cloud/images/GitGui07.png)
</code></pre><p><img class="small" src="http://www.elvenware.com/charlie/development/cloud/images/GitGui08.png" alt="Ready to Commit"></p>
<pre><code>![Ready to Commit](http://www.elvenware.com/charlie/development/cloud/images/GitGui08.png)
</code></pre><p><img class="small" src="http://www.elvenware.com/charlie/development/cloud/images/GitGui05.png" alt="Get ready to Push "></p>
<pre><code>![Get ready to Push ](http://www.elvenware.com/charlie/development/cloud/images/GitGui05.png)
</code></pre><p><img class="small" src="http://www.elvenware.com/charlie/development/cloud/images/GitGui06.png" alt="Push Success"></p>
<pre><code>![Push Success](http://www.elvenware.com/charlie/development/cloud/images/GitGui06.png)
</code></pre><p>You can choose <strong>Repository | Visualize XXX History</strong> to get an overview
of what has been happening in the repository:</p>
<p><img class="small" src="images/GitHistory01.png" alt="Visualize History"></p>
<pre><code>![Visualize History](images/GitHistory01.png)
</code></pre><h2 id="git-help-command">Git Help Command</h2>
<p>To learn about a git command, type <strong>git help <COMMAND></strong>. For instance:</p>
<pre><code>git help status
git help commit
git help add
</code></pre><p>In some cases the results will be displayed at the command line. In others, you will be taken to a web page.</p>
<h2 id="the-git-status-command">The Git Status Command</h2>
<p>Suppose you have a file called users.html that you have edited. Here is how to 
confirm that you have edited the file, and to see if there are other files
you may have edited, added, or deleted from or to the repository:</p>
<pre><code>git status
</code></pre><p>I issue the git status command frequently. It lets me know the state of my
repository. Here for instance, is what you will see if you issue the git
status command after first creating users.html:</p>
<pre><code>C:\Git\foo&gt; echo foo &gt; users.html
G:\Src\Git\foo&gt; git status
# On branch master
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#       users.html
nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre><p>When we typed <strong>git status</strong>, git replied by telling us the status of the 
files in your directory. In particular, git is telling us that we have a new 
file in our repository called <strong>users.html</strong>. When git sees a new file or 
directory in a repository, then the status message is usually &quot;Untracked 
files.&quot; This is git&#39;s way of saying &quot;I see this new file or directory in 
your repository, and I&#39;m not currently tracking it.&quot; Then it adds a hint: 
&quot;(use &quot;git add <file>...&quot; to include in what will be committed).&quot; It is 
telling you that you can use the command <strong>git add users.html</strong> to start 
tracking the folder that is currently not being tracked. There are several 
variants on the git add command that you can run. For instance, typing <strong>git 
add .</strong> (that&#39;s git plus add plus a period) will usually add any untracked or 
modified files to the repository without you having to spell them out.</p>
<h2 id="git-log">Git Log</h2>
<p>You can just type <strong>git log</strong>, but I find <strong>git log --pretty-oneline</strong> more useful. For instance:</p>
<pre><code>git log --pretty=oneline
7ff2d4b4d3dcea2d938a2a7e0ed42e1000cb32a2 Readme has Elvenware patterns document
e16107b10dce32d7abba9f973549222e5db7adf0 Clean up names for code readability
8739b8e3deee016ad5025f6764ef36ab571ff71c Add functional Programming examples
</code></pre><p>Now clone a particular commit:</p>
<pre><code>git branch functional 8739b8e3d
</code></pre><p>Now you can switch to the functional branch and see your files at the time of that commit.</p>
<pre><code>git checkout functional 
</code></pre><p>If you are tired of looking at that branch, you can switch back to the master branch and then permanently remove your <strong>functional</strong> branch:</p>
<pre><code>git checkout master
git branch --delete functional
</code></pre><p>You might also use with <strong>git diff</strong>. Like this:</p>
<pre><code>git diff e78fe3 a7e46a README.md
</code></pre><p>This compares the difference for a specific file between two commits. If you want to see the changes between all files in the two commits, just leave off the file name in the above command.</p>
<h2 id="git-show">Show History of a File</h2>
<p>First type <strong>git log <MyFile></strong> to see the times when you modified a file.
For instance, this shows the history of <strong>.gitignore</strong> in a repository:</p>
<pre><code>$ git log --oneline .gitignore
83925f1 updated .gitignore from a samed-name file
08e7f2b Adding Object Basics and SplitSlice
bd54f9f adding gitignore
</code></pre><p>Now show the contents of a particular version of the file with <strong>git show</strong>:</p>
<pre><code>$ git show 08e7f2:.gitignore
node_modules
.metadata
.idea
Thumbs.db
.c9
</code></pre><p>What we have done is type:</p>
<ul>
<li>git: Invoke Git</li>
<li>show: Invoke the show command</li>
<li>08e7f2: Reference a particular commit by giving enough of its ID to 
uniquely identify it. Six characters is usually enough, sometimes less.</li>
<li>:.gitignore. The type a colon and the file name.</li>
</ul>
<p>Another example, this time using the README file:</p>
<pre><code>$ git log --oneline README.md
01f3de2 Bar
2b593a3 asdf
f182b3c readme changed
ce4e0f2 README update
66f33ac initial Commit
</code></pre><p>Then view a particular version:</p>
<pre><code>$ git show f182b3c:README.md 
My Readme File
This is an update
New change after support for ssh
</code></pre><h2 id="git-files">Working with Files in a Repository</h2>
<p>Suppose you have a file called users.html that you have either recently 
created or recently edited. You now need to tell git to check in your 
changes, that is, to add your new or updated file to the repository. Whether 
the file is new or updated, here is how to check in the <strong>users.html</strong> file:</p>
<pre><code>git add users.html
git commit -m &quot;This is my message about the way I updated users.html&quot;
</code></pre><p>Now you have everything checked into your local copy of the Git repository. To
push these changes to your GitHub, BitBucket or other remote copy of the 
repository, issue this command:</p>
<pre><code>git push
</code></pre><p>Now, lets add a folder named temp and a file named foo.txt to the repository:</p>
<pre><code>mkdir temp  
cd temp
echo foo &gt; foo.txt
cd ..
</code></pre><p>The above commands create a new folder called <strong>temp</strong>. The second line 
shows how to navigate into the folder. The third line creates a new file 
called <strong>foo.txt</strong> with the contents being the single world <em>foo</em>. Finally 
we navigate back to the original directory where we were before we created 
the <strong>temp</strong> directory.</p>
<p>Now add the changes and commit the work to the repository:</p>
<pre><code>git add temp  
git commit -m &quot;adding temp&quot;  
</code></pre><p>After issuing the last command, you will see several lines of feedback from git. 
Now it is time to push your changes up to GitHub (or to wherever your 
repository is stored)L   </p>
<pre><code>git push  
</code></pre><p>If you do not have an SSH key and repository set up, you will now be asked for 
your username and password.     </p>
<p>Sometimes you will have conflicts between what is on the server and  what
you have on your machine. In that case, do a merge. This will  create a
local copy of you files with both sets of text in it. Open  your file in a
text editor, find the places where the conflicts  exist, fix them manually,
and then go through another  add/commit/push cycle.</p>
<h2 id="typical">A Typical Git Session</h2>
<p>Suppose you run git status and get this result:</p>
<pre><code>&gt;git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   Cordova/CordovaInput/assets/www/index.html
#
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#       foobar.txt
</code></pre><p>Here you can see that one file, <strong>index.html</strong>, has been modified. Another file, called <strong>foobar.txt</strong>, has been created. To commit them both, do this:</p>
<pre><code>git add .
</code></pre><p>That&#39;s <strong>git add</strong> followed by a period. The period is a wild card saying: &quot;Add everything that has been changed.&quot; Now check your status:</p>
<pre><code>&gt;git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   Cordova/CordovaInput/assets/www/index.html
#       new file:   foobar.txt
#
</code></pre><p>As you can see, there are now two files witing to be committed. You can commit them like this:</p>
<pre><code>&gt;git commit -m &quot;Update index.html and add foobar.txt to to ward off polen smears.&quot;
[master c91d5fc] Update index.html to support tiger attacks, add foobar.txt to ward off polen smears.
 2 files changed, 2 insertions(+), 1 deletion(-)
 create mode 100644 foobar.txt
</code></pre><p>Now push them to the repository:</p>
<pre><code>&gt;git push
Counting objects: 14, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (8/8), 633 bytes | 0 bytes/s, done.
Total 8 (delta 5), reused 0 (delta 0)
To git@github.com:charliecalvert/Simple02.git
   16e7d40..c91d5fc  master -&gt; master
</code></pre><h2 id="the-gitignore-file">The GitIgnore File</h2>
<p>You can create a file .gitignore that tells git to ignore certain files.  That&#39;s GITIGNORE, but in all lowercase, with a PERIOD in front of it: .gitignore. Remember that in Linux files that have a period in front of them are hidden. At the command prompt, you can view them by typing <strong>ls -la</strong>.</p>
<p>You might create a file called <strong>.gitignore</strong> with this content:</p>
<pre><code>Thumbs.db
</code></pre><p>This tells Git to ignore all the files in your repository that are called <strong>Thumbs.db</strong>.</p>
<p>You could then tell it to ignore the contents of the <strong>temp</strong> directory, the <strong>.metadata</strong> directory and the <strong>node_modules</strong> directory:</p>
<pre><code>Thumbs.db
temp/*
.metadata
node_modules
</code></pre><p>Here is how to ignore everything but the source directory:</p>
<pre><code>*
!Source/
</code></pre><p>And here is a complex example that includes a comment:    </p>
<pre><code># Ignore everything in the &quot;charlie&quot; directory, except certain directories

charlie/*
charlie/development/*
charlie/development/web/*
charlie/development/web/JavaScript/images/
charlie/development/web/HtmlGuide/images/
charlie/development/web/CssGuide/images/
!charlie/development/
!charlie/development/web/
!charlie/development/web/CssGuide/
!charlie/development/web/JavaScript/
!charlie/development/web/HtmlGuide/
</code></pre><p>Add and check in your .gitignore file:</p>
<pre><code>add .gitignore
commit -m &quot;Adding GitIgnore File&quot;
git push
</code></pre><h2 id="create-a-new-repository">Create a New Repository</h2>
<p>Suppose you want to create a new repository. Typically you would start by creating the repository on a remote service such a BitBucket or Github.  After signing into your BitBucket or GitHub account, you will see a button for creating the repository. Push the button and create an empty repository. Don&#39;t put anything in the repository, not even a README.md file. Just leave it empty.</p>
<p>Next, make sure <a href="http://www.elvenware.com/charlie/development/cloud/SshFtpsPutty.html#sshKeys">you have an SSH private key and public key pair</a> on your client machine, and store the public key portion in BitBucket or GitHub, depending on the service you are using. To do this, first open the public key (id_rsa.pub) in an editor such as <strong>geany</strong>, <strong>nano</strong> or <strong>notepad++</strong>. Block copy it, then paste it into the appropriate field on the GitHub or BitBucket web site. In particular, on BitBucket, choose <strong>manage account</strong> from the icon in the upper right portion of the BitBucket site, and then select <strong>ssh keys</strong> from the menu on the left. On GitHub, choose the <strong>gear</strong> icon at the top right of the site, and then select <strong>SSH keys</strong> from the menu on the left. Don&#39;t forget to call ssh-add on your private (id_rsa) key, as described at the link shown above.</p>
<p>Now that you have SSH set up, go to the directory you want to use as the basis for your repository. If you don&#39;t have such a repository, then start from scratch:</p>
<pre><code>mkdir MyRepo
cd MyRepo
</code></pre><p>No initialize git by typing typing <strong>git init</strong>.  This converts an ordinary directory into a Git repository. In particular, it creates a hidden directory called <strong>.git</strong>. In that directory, it stores all the files necessary to configure and maintain your repository.</p>
<p>Then get the command from bitbucket or github that is used to designate where your remote repository resides. The command might look like this, though the exact url at the end will likely differ in your case:</p>
<pre><code>git remote add origin ssh://git@bitbucket.org/lucia/myrepo.git
</code></pre><p>Then add some content to your repository and add and commit your content:</p>
<pre><code>echo MyReadMe &gt; README.md
git add README.md
git commit -m &quot;Adding a readme to my new repo&quot;
</code></pre><p>If you have multiple changes that you want to add and commit at one time, then use a period in your call to <strong>git add</strong>:</p>
<pre><code>git add .
git commit -m &quot;Initial commit&quot;    
</code></pre><p>In the first example, we added just a README.md file to the repository. In the second example, we added any new or updated files to your repository.</p>
<p>Finally, add the following command to push your repo to BitBucket:</p>
<pre><code>git push -u origin --all
</code></pre><p>After this first time, you will be able to push like this:</p>
<pre><code>git push
</code></pre><p>It&#39;s only the first time you need to add <strong>-u origin --all</strong>.</p>
<p>To sum up, if you have an existing repository, and you want to push it from the shell do something like this, where the exact URL for your repository will of course be different from the one shown here:</p>
<pre><code>git remote add origin git@github.com:charliecalvert/DeleteMeNow.git
// Add some content
git push -u origin master
</code></pre><p>Sometimes you will have a session that looks like this:</p>
<pre><code>G:\Src\Git\foo&gt;git push -u origin --all
No refs in common and none specified; doing nothing.
Perhaps you should specify a branch such as &#39;master&#39;.
fatal: The remote end hung up unexpectedly
Everything up-to-date
</code></pre><p>If you get an error like that, it means you forgot to run git add and git 
commit.</p>
<p>Here is a summary of the steps:</p>
<ul>
<li>Load your SSH private key in pageant and ensure your public key is stored on
BitBucket.</li>
<li>Go to the directory you want to export and typing: git init</li>
<li>Use the <strong>git add</strong> and <strong>git commit</strong> commands to commit your files into your new repository.</li>
<li>Then type: git remote add origin ssh://git@bitbucket.org/lucia/myrepo.git</li>
<li>Then type: git push -u origin --all</li>
</ul>
<p>Here are the instructions from GitHub, which are just a variation on what I write above:</p>
<pre><code>echo &quot;Some Text&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:charliecalvert/DeleteMeNow.git
git push -u origin master
</code></pre><p>Here are the instructions from BitBucket, which are just just a variation on what I say above:</p>
<pre><code>mkdir /path/to/your/project
cd /path/to/your/project
git init
git remote add origin git@bitbucket.org:ccalvert/deletemenow3.git

echo &quot;Charlie Calvert&quot; &gt;&gt; contributors.txt
git add contributors.txt
git commit -m &#39;Initial commit with contributors&#39;
git push -u origin master
</code></pre><h2 id="add-origin">More on git remote add origin</h2>
<p>Sometimes the issue can also be that you need to set to the URL with command like this:</p>
<pre><code>git remote add origin ssh://git@bitbucket.org/lucia/myrepo.git
</code></pre><p>Suppose you create a new repository:</p>
<pre>mkdir foo
$ cd foo
$ git init
</pre>

<p>Now you have a new repository. Your <strong>.git/config</strong> file looks like this:</p>
<pre>
$ cat .git/config 
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
charlie@MountainStreamsLinux
</pre>

<p>Now run our command and then look at <strong>.git/config</strong></p>
<pre>$ git remote add origin ssh://git@bitbucket.org/lucia/myrepo.git
~/temp/foo
$ cat .git/config 
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
[remote "origin"]
    url = ssh://git@bitbucket.org/lucia/myrepo.git
    fetch = +refs/heads/*:refs/remotes/origin/*
~/temp/foo
</pre>


<h2 id="git-config-file">Git CONFIG File</h2>
<p>The git config file holds several important facts. One of the most important
is the URL used to access to your git repository. </p>
<p>The config file is called <strong>config</strong> and it is stored in a hidden directory 
at the root of your repository called .git. Here is the line in the config
file that specify&#39;s your URL:</p>
<pre><code>[remote &quot;origin&quot;]
    url = git@github.com:charliecalvert/JsObjects.git
    fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre><p>If you they ask you to set your global user.email, you can write something like
this:</p>
<pre><code>git config --global user.email &quot;me@somewhere.com&quot;
</code></pre><p>This information is usually writting to $HOME/.gitconfig. For instance:</p>
<pre><code>c:\users\username\.gitconfig
</code></pre><p>Or on Linux:</p>
<pre><code>\home\username\.gitconfig
</code></pre><p>Or on the Mac:</p>
<pre><code>\users\username\.gitconfig
</code></pre><p>If you are guru, and this gets really mixed up, try looking in:</p>
<pre><code>C:\Program Files (x86)\Git\etc\profile    
</code></pre><p>In particular, one time I found my environment had a variable in it called
HOME that was pointing to some nonsense value like /home/ubuntu, even though
I was on a Windows machine.    </p>
<p>In the .get directory you will find your config file. You can just edit that
file with a text editor. On the other hand, you can use the following to set
values in the global config file found in the main .git directory. The main
.git directory for a user is usually found in your home directory on both
Windows in Linux.</p>
<pre><code>C:\\Users\\Charlie\&gt;git config --global user.name &quot;charliecalvert&quot;
C:\\Users\\Charlie\&gt;git config --global user.email &quot;noone@nowhere.net&quot;
</code></pre><p>You can pass in a length of time you want git to cache your password:</p>
<pre><code>git config --global credential.helper cache --timeout=900
</code></pre><h2 id="git-overwrite-local-changes">Git Overwrite Local Changes</h2>
<p>If you want to refresh the entire local repository, overwriting your
changes, do this:</p>
<pre><code>git fetch
git reset --hard
</code></pre><p>Or, you can specify the repository you want to reset from:</p>
<pre><code>git fetch
git reset --hard origin/master
</code></pre><p>If you have a single file in the local repository that you have edited, 
and you want to throw away those changes, but keep your other changes,
then do this:</p>
<pre><code>git fetch
git checkout origin/master &lt;MyFile&gt;    
</code></pre><h2 id="git-urls-and-ssh">Git URLs and SSH</h2>
<p>There are three ways to interact with a GIT repository on a site like GitHub
or BitBucket:</p>
<ul>
<li>You can have read only access to the repository. This will let you check 
files out, but you cannot make changes and check them back in. This is what 
you want if you are using some third party library. </li>
<li>You can have HTTPs access to the library, which will enable you to check 
in and check out. Access to the library is then usually controlled with a 
user name and password. If you are uncomfortable with SSH, this will 
probably be the simplest option for you.</li>
<li>You can have SSH access to the repository. If you are at all familiar with 
SSH, you will probably find this option easiest when working with Git. If 
you have a key loaded with a tool lie <em>Pageant</em> or <em>ssh-add</em>, then you can 
check in and check out without having to worry about typing in your user 
name and password. </li>
</ul>
<p><em>NOTE</em>: Many tools, such as GitHub for Windows, can handle your password for 
you automatically. That means they work well with HTTPs connections. To get 
that benefit, you need to be in the GitHub GUI, or in the shells 
associated with those GUI&#39;s. These tools work well, and I encourage you to 
use them. However, there are times when it is nice to be able to check in 
and out of Git without having to use a specific tool. In those cases, many 
people will find it easiest to use SSH.</p>
<p>To connect to a site using SSH, you need to do two things:</p>
<ul>
<li>Load or reference the private portion of your SSH key on your local machine.     </li>
<li>Cache your SSH key on the remote machine. Both BitBucket and GitHub have 
locations on their web site where you can cache your public keys. On 
BitBucket, choose <em>Manage Account - SSH keys</em>. On GitHub, choose <em>Edit your 
profile - SSH Keys</em>. </li>
</ul>
<p>There are several types of URLs you can use with Git. Only one of them sets up
your repository to use SSH. Here is the type of URL you would use when checking 
out a read only copy of a repository:</p>
<pre><code>git://github.com/someone/JsObjects.git
</code></pre><p>The above URL does not depend on SSH. When you use a URL that looks like the
one shown below, then you are saying you want to work with a read/write copy of 
the repository in SSH mode:</p>
<pre><code>git@github.com:someone/JsObjects.git
</code></pre><p>Let&#39;s put them right next to each other so you can compare:</p>
<pre><code>git://github.com/someone/JsObjects.git 
git@github.com:someone/JsObjects.git
</code></pre><p>Notice the readonly version (the first one) has slashes where the readwrite 
version has at (@) symbols or colons.</p>
<p>None of this is specific to GitHub. The same syntax applies when working 
with files stored in any remote repository. Here, for instance, is an SSH 
URL for bitbucket:</p>
<pre><code>git@bitbucket.org:someone/deleteme.git
</code></pre><p>Here is a URL for an HTTPS readwrite connection to a repository:</p>
<pre><code>https://github.com/charliecalvert/bc-basic.git
</code></pre><p>There URLs are easy to identify since they begin with the letters https. </p>
<p><em>NOTE: Further down in this document you will learn about creating URLs for local 
repositories.</em></p>
<h2 id="what-url-is-my-connection-using-">What URL is My Connection Using?</h2>
<p>The URL for your repository is usually kept in the .git directory at the 
root of your repository. (Sometimes this folder is hidden, even on Windows. 
You can look for hidden files or folders, or just go ahead and type <em>cd .git</em>, 
and assume it will work if you are in the root of your repository.) If you 
want to change the URL your repository uses by default, you can open the 
<em>config</em> file in your .git directory and edit this line:</p>
<pre><code>[remote &quot;origin&quot;]
url = git@github.com:charliecalvert/JsObjects.git 
</code></pre><h3 id="the-ssh-key">The SSH Key</h3>
<p>If you are going to be using SSH to connect to your repository, then you 
want to be sure that you have your key loaded into memory. On Windows, I use a 
Pageant (PuTTY). When you clone, it helps a lot if you use Pagaent. On Linux, 
you can use <em>ssh-agent</em> and <em>ssh-add</em>.</p>
<p><em>NOTE</em>: When working on Windows, be sure to check your /users/username/.ssh 
folder for keys that tools like GitHub might be using. This will only come 
into play if you are not using plink to handle your keys.</p>
<p>Caching SSH Keys on Linux</p>
<p>On Linux, this is how I load an SSH key into memory so that I don&#39;t have to 
reference it each time I make a connection. (On Windows we use Pageant to 
perform this task.)</p>
<p>First I need to be sure ssh-agent is load. Then I add the key to the store. 
Notice that in the first command we use backticks:</p>
<pre><code>eval `ssh-agent`
ssh-add MyKey.pem
</code></pre><p>Try putting this in .bashrc to load ssh-agent when
you log in to your bash shell:</p>
<pre><code>if [ -z &quot;$SSH_AUTH_SOCK&quot; ] ; then
  eval `ssh-agent`  
fi
</code></pre><p>If you put in .bashrc then it will get loaded each time you open
the shell, so you can end up with multiple copies of <strong>ssh-agent</strong>
running. But you need to have it running in the current shell,
so I don&#39;t see a good way around this. </p>
<p>You can also create <strong>~/.ssh/config</strong> file that associates a domain
with key. Here is the complete contents of an example file for 
connecting GitHub.com with a key called Github.pem:</p>
<p>Host github.com
        IdentityFile ~/.ssh/Github.pem</p>
<p>If you get a warning about an unprotected key file, that usually means that 
you have not set up the permissions correctly for the key file itself. You 
should ensure that only the current user can read it:</p>
<pre><code>chmod 600 github_rsa
</code></pre><p>Or perhaps:</p>
<pre><code>chmod 600 MyKey.pem
</code></pre><p>Now try again, and it should go smoothly.</p>
<pre><code>ssh-add github_rsa
</code></pre><p><em>NOTE</em>: I suppose you could even make the SSH keys readonly:</p>
<pre><code>chmod 400 github_rsa
</code></pre><p>After doing this, you should be able to access sites where you have shared your 
ssh public key.</p>
<h2 id="checklist">Git SSH Checklist</h2>
<p>If you are having problems, check the following:</p>
<ul>
<li>Are you issuing the command from inside your repository?</li>
<li>Have you loaded your SSH private key with Pageant, <strong>ssh-add</strong> or some other tool?</li>
<li>Does the server you are trying to reach (ec2, bitbucket, github, etc) have a copy of your public key?</li>
<li>Does your <strong>config</strong> file use an SSH style Url (git@bitbucket.org vs <a href="https://bitbucket.org)?">https://bitbucket.org)?</a></li>
<li>Have you loaded the correct public and private keys? In other words, does the private key you loaded match the public key on your server?</li>
<li>Do you need to do a push or pull before proceeding?</li>
<li>Have you carefully read any error messages that git gives you? Have you tried searching on that error message?</li>
</ul>
<p>Useful video:</p>
<ul>
<li><a href="https://youtu.be/EV9QSSX2w9I">Convert PEM File</a></li>
</ul>
<h2 id="host-key-is-not-cached">Host Key is not Cached</h2>
<p>The following error is a classic:</p>
<p>&quot;The servers host key is not cached in the registry...connection abandoned.&quot; </p>
<p>To fix this, Open Putty, and create a connection to BitBucket 
(bitbucket.org). Try to connect. You don&#39;t need to actually connect, you 
just need the dialog to pop up that asks if you want to store the key for 
the site locally. Answer yes. Then, if you actually connected, which is 
unlikely and unnecessary, disconnect. Now go back and try to connect again 
using SSH. It should now work. </p>
<p>Another option is to type the following at the command line:</p>
<pre><code>plink MyUserName@bitbucket.org
</code></pre><p>This will also give you an option to store the key for the bitbucket server in
your known_hosts file. The <em>known_hosts</em> file is usually stored in your ssh 
directory:</p>
<h2 id="amend-a-commit">Amend a Commit</h2>
<p>(I&#39;m still working on this section of the text, and I have not fully tested
the commands shown here.)</p>
<p>You can amend the previous commit (i.e. after removing a bad file or even 
simply to change the commit message... add -m &quot;message&quot; after --amend)</p>
<pre><code>git commit --amend     
git push -f
</code></pre><p>If you ommit the push command you will an error message like this:</p>
<pre><code>&quot;...the tip of your current branch is behind...&quot;
</code></pre><p>References:</p>
<pre><code>&lt;http://www.atlassian.com/git/tutorial/rewriting-git-history#!commit-amend&gt;
&lt;http://stackoverflow.com/questions/179123/how-do-i-edit-an-incorrect-commit-message-in-git&gt;
</code></pre><p>This command can be useful if you accidentally sent some confidential files 
along with your original commit. That confidential info would still be 
tracked in history even though you removed it in subsequent updates. </p>
<p>For those who are new to Git, or new to Version Control, just a couple reminders:</p>
<ul>
<li><p>The purpose of Git is to give you a complete record of your work on a 
project. It saves all your work, and each version of your work. If you use 
Git, it is almost impossible to lose work in such a way that it can&#39;t ever 
be retrieved. Even if your entire hard drive explodes, destroying your 
computer and all your work, the files that are stored on a remote Git 
repository (BitBucket or GitHub) are safe. They will not be lost. </p>
</li>
<li><p>The commands that rewrite Git history, such as amend and rebase, can cause 
you to completely lose code that you once checked in. Even worse, if you 
issue one of the commands incorrectly, you could accidentally, and 
permanently, delete files that you may still need. In other words, you may 
do your homework, check it into Git, then amend Git, lose your homework, and 
find that you can&#39;t retrieve it.</p>
</li>
<li><p>Git is infinitely configurable. That is why it is sometimes hard to use. 
There is seemingly nothing that can&#39;t be done with Git. It even allows you 
to undermine the whole purpose of Git by allowing you to rewrite, or amend, 
the history that it is careful designed to save. This is my way of saying 
that amend is a useful, but somewhat esoteric command.</p>
</li>
</ul>
<p>Here is a notice from the Git documentation about this command:</p>
<p>&quot;Don&#39;t Amend Public Commits</p>
<p>&quot;On the git reset page, we talked about how you should never reset commits 
that have been shared with other developers. The same goes for amending: 
never amend commits that have been pushed to a public repository.</p>
<p>&quot;Amended commits are actually entirely new commits, and the previous commit 
is removed from the project history. This has the same consequences as 
resetting a public snapshot. If you amend a commit that other developers 
have based their work on, it will look like the basis of their work vanished 
from the project history. This is a confusing situation for developers to be 
in and it&#39;s complicated to recover from.&quot;</p>
<p>If your previous commit is just completely bad,  you can do a git reset 
--hard HEAD~1 (or ~2, 3 etc however far back you want to reset) to 
completely remove the last commit(s) and then a git push -f or --force  but 
this removes everything that was changed in the last commit(s).</p>
<p>The git commit -amend affects only the files that were changed /removed 
since the last commit.</p>
<p>There is also git reset --soft that is similar to git commit --amend so one 
or the other may be preferred in a particular situation. But amending a 
commit seems to be a way to fix simple errors in a previous commit.</p>
<h2 id="clone-a-local-repository">Clone a Local Repository</h2>
<pre><code>git clone file:////home/charlie/git/myrepo git clone file:////\$HOME/git/myrepo
</code></pre><h2 id="git-remote">GIT Remote</h2>
<p>Suppose you have an existing repository on your local machine, and an empty 
repository on GitHub. Navigate to the folder that holds your local copy of 
the repository. If issued from that folder, the followling line ought to add 
your local repository to the empty GitHub repository:</p>
<pre><code>git remote add origin ssh://git@bitbucket.org/ccalvert/deleteme.git
</code></pre><p>You can then type the following to see where your repository is set up:</p>
<pre><code>git remote -v
</code></pre><p>Delete a remote repoistory called working:</p>
<pre><code>git push origin origin :working
</code></pre><p>To delete a local branch named working:</p>
<pre><code>git branch -d working
</code></pre><h2 id="working-with-branches">Working with Branches</h2>
<p>Branches allow you to work with variations of your code. You can have
two versions of one code base checked into your repository at the 
same time. Perhaps one version is intended for one audience, the other
for another audience. Perhaps one version has code from Person A in it
and the other branch has a second version of the same code, but with 
suggestions made by Person B.</p>
<p>List available branches:</p>
<pre><code>git branch
</code></pre><p>For instance:</p>
<pre><code>C:\GitHub\Simple02&gt;git branch
* master
test
</code></pre><p>The listing above shows two branches, one called master, the other called
test. The asterisk before the <strong>master</strong> branch means that it is the current
branch.</p>
<p>Create a branch named <strong>myBranch</strong>:</p>
<pre><code>git branch myBranch
</code></pre><p>For example:</p>
<pre><code>C:\GitHub\Simple02&gt;git branch myBranch

C:\GitHub\Simple02&gt;git branch
* master
  myBranch
  test
</code></pre><p>As you can see, there is now a new branch called <strong>myBranch</strong>.</p>
<p>Now we can switch to our new branch:</p>
<pre><code>git checkout myBranch
</code></pre><p>Now type git branch again and you will see both branches listed, but 
your current branch will be highlighted. In other words, <strong>myBranch</strong>
will appear in highlighted text and with a star before it:</p>
<pre><code>C:\GitHub\Simple02&gt;git checkout myBranch
Switched to branch &#39;myBranch&#39;

C:\GitHub\Simple02&gt;git branch
  master
* myBranch
  test
</code></pre><p>Now lets show that you can edit and add files to your current branch 
without effecting the other branch. First edit a file and check your 
changes in to your branch:</p>
<pre><code>git add MyFile 
git commit -m &quot;Committing changes to MyFile&quot;
</code></pre><p>If you have cloned a repository with multiple branches, you can see
those branches one of three or four ways:</p>
<ul>
<li>git branch</li>
<li>git branch -a</li>
<li>git branch --list</li>
<li>git branch -r </li>
<li>Go to the online version, and you should see the branches listed in,
for instance, BitBucket or GitHub. In other words, the web interface
to your repository should list the branches in some fairly obvious
way.</li>
</ul>
<p>Git branch <strong>-a</strong> shows all the branches, both local and remote. 
<strong>Git --list</strong> shows the local branches and <strong>git -r</strong> shows the 
remote branches.</p>
<pre><code>C:\GitHub\Simple02&gt;git branch -a
  master
* myBranch
  test

  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
  remotes/origin/test
</code></pre><p>In the listing shown above, you can see that master and test are on
both the local and remote versions of the repository. But myBranch
is only on the local version. In the next section you will learn
how to push it to the remote repository.</p>
<p>If you want to push this branch, and only this branch, to the origin (to the remote repository), then do this:</p>
<pre><code>$ git push --set-upstream origin BridgeReader04
</code></pre><p>Where BridgeReader04 is the name of the current repository.</p>
<h2 id="merge-branches">Merge Branches</h2>
<p>If you have been doing work in a branch called <strong>charlie</strong> and you want to
merge it with <strong>master</strong>, then first checkout the master branch branch, then
merge them:</p>
<pre><code>git checkout master
git merge charlie
</code></pre><h2 id="push-local-branch-to-remote">Push Local Branch to Remote</h2>
<p>If you want to create a copy of your branch in the original remote repository:</p>
<pre><code>git push &lt;remote&gt; &lt;local&gt;
</code></pre><p>For example:</p>
<pre><code>git push origin myBranch
</code></pre><p>This would, for example, push the local branch called myBranch to the remote 
repository, which might be a place like GitHub or BitBucket. If <em>myBranch</em> does
not exist in the remote repository, then it will be created.</p>
<p>The next time you push, you can use the same command, or you can set things up
so <em>git push</em> will push only the current repostory:</p>
<pre><code>git config push.default current
</code></pre><p>You can also:</p>
<pre><code>git push --set-upstream origin BridgeReader04
</code></pre><p>Suppose you and another person are working on the same repository 
and the other person adds a branch and pushes it to the origin. When 
you run <strong>git pull</strong>, that will pull down the new branch. You can 
see it by typing <strong>git branch -a</strong>. To switch it to it, just type 
git branch <NewBranch>, where NewBranch is the name of the new 
branch the other person added.</p>
<pre><code>git pull
git branch -a
git checkout myBranch
</code></pre><h2 id="clone-a-local-repository">Clone a Local Repository</h2>
<pre><code>git clone file:////home/charlie/git/myrepo git clone file:////$HOME/git/myrepo
</code></pre><p>Merge from a local repository. For instance, you are in master, and you
want to merge the commits that are in working:</p>
<pre><code>git merge working 
</code></pre><h2 id="clone-a-specific-branch">Clone a Specific Branch</h2>
<p>To clone a specific branch, got to a directory that does not
contain a repository with the same name as the repository you want
to clone. Then enter the following command:</p>
<pre><code>git clone -b &lt;branch&gt; &lt;url&gt;
</code></pre><p>For example:</p>
<pre><code>git clone -b mybranch git@github.com:username/myrepo.git
</code></pre><p>More specifically:</p>
<pre><code>git clone -b test git@bitbucket.org:charlie/myrepo.git
</code></pre><p>Here is another example, working with local files:</p>
<pre><code>BRANCH=chasyte
REPOSITORY=file:////home/charlie/git/myrepo
mkdir 
cd $BRANCH
git init
git remote add -t $BRANCH -f origin $REPOSITORY
git checkout $BRANCH
</code></pre><h2 id="git-checkout-a-specific-branch">Git Checkout a Specific Branch</h2>
<p>Sometimes you want to just look at the state of your repository at
some point in the past. You don&#39;t necessarily want to switch to that
state, but just view it. You can do that by checking out the repository
from the state it was at after a particular commit. </p>
<p>Let&#39;s assume you have just done a pull, and have the whole up to date
repository on your machine. Now you want to check out the repository
and examine a branch that mirrors the way your project looked at some
point in the past.</p>
<p>Every time you do a commit, there is a funny number associated with
that commit. You can easily find these numbers, often called SHAs, on
the Git web sites. Typing git log can also help you find these numbers.</p>
<p>Now just do a checkout, passing in that number:</p>
<pre><code>git checkout -b charlie01 a608f0e
</code></pre><p>In this example we created a new branch called charlie01 that mirrors
the state of the repository as it looked after the commit identified
by the SHA a608f0e.</p>
<h2 id="oldversion">Find Old Version of Code</h2>
<p>The subject of checking out a specific branch is so important, that it might be worth discussing in more depth. When you do good work, check it in. Then later, if you find that you wish you could go back to the working verison of your code, there are several things you can do. Here is one.</p>
<p>One way to get access to the older version of your code is to check it out in a branch. To do this, you need to know the commit number of the good code. Often the best way to find this number is to browse on GitHub or BitBucket. But you can also find with with the Git log comment:</p>
<pre><code>git log
</code></pre><p>Or</p>
<pre><code>git log &lt;FileName&gt;
</code></pre><p>Sample output:</p>
<pre><code>&gt;git log Control.js
commit bbe914c7347c51237b21a4b9a68be29fac3fccf4
Author: Charlie CedarIsle Calvert &lt;charlie@elvenware.com&gt;
Date:   Tue May 26 22:07:44 2015 -0700

    Week08 Initial checkin 

commit 16763f8a3327b074d56f7cb563900ae2d34729a6
Author: Charlie CedarIsle Calvert &lt;charlie@elvenware.com&gt;
Date:   Mon May 25 16:20:49 2015 -0700

    Midterm updated getScientists method with support for Jade files
</code></pre><p>When reading the results of this log, you will begin to understand why it is so important to type in something useful when you commit your code. A useful comment can help you find a particular older version of your code.</p>
<p> Now create the branch based on the commit you did after we worked together. Here I call git branch and give a name for the branch and the full commit number as seen above in the log statement:</p>
<pre><code>git branch initial bbe914c7347c51237b21a4b9a68be29fac3fccf4
</code></pre><p>Now checkout the branch:</p>
<pre><code>git checkout initial
</code></pre><p>Now you have a copy of the code from the past that you wanted to see. You might save the portions you need into another directory. Don&#39;t just open it in an editor, copy it someplace else outside your repository. Then (AND IMPORTANTLY), go back to the master branch:</p>
<pre><code>git checkout master
</code></pre><p>You need to go back to the master because you probably don&#39;t want to do your work in the older branch as it does not contain all your recent work. You just wanted to look at your older files, save the parts you wanted, and then go back to your new work.</p>
<p>Again, there are other ways to solve this problem. This one, however, can be useful as it:</p>
<ul>
<li>Give you a good chance to look over all the files in your project as it was at a specific point in time.</li>
<li>Creates a branch that <strong>memorializes</strong> that point in time in case you want to switch back to it again. To get back to it, just type <strong>git checkout initial</strong>. But don&#39;t forget to switch back to master when you are done: <strong>git checkout master</strong>.</li>
</ul>
<p>Having a branch in your code is not nearly as expensive as it might seem at first. If, however, you want to delete it. First switch to master, and then:</p>
<pre><code>git branch -d initial
</code></pre><h2 id="replace-master-with-old-commit">Replace Master with Old Commit</h2>
<p>Sometimes you will find that the current master branch is no longer what you want. You want to go back to some earlier commit, some earlier state. The first thing to do is find the commit number of that old branch as described above. Suppose that number is<strong> f631de7</strong>. Here is how to replace the current master branch with that older commit. You may or may not want to start with a <strong>git fetch</strong> to to pull down the most recent code (current master branch) from your repository. At any rate, once you are ready to begin, you should do this, where the first line creates a branch called <strong>yesterday</strong> based on specific commit:</p>
<pre><code>git branch yesterday f631de7
git checkout yesterday
git merge -s ours master
git checkout master
git merge yesterday
</code></pre><p>The -s stands for strategy: <strong>git merge --strategy ours master</strong>. It says that if there are conflicts during the merge, always prefer our current branch over the master branch.</p>
<p>When looking at the above code, it should be clear that you can use this same strategy to replace the current master with some any random branch. Suppose you want to replace the current master with the a branch called <strong>goodbranch</strong>:</p>
<pre><code>git checkout goodbranch
git merge -s ours master
git checkout master
git merge yesterday
</code></pre><h2 id="comparing-two-branches">Comparing Two Branches</h2>
<p>If you want to compare the files from BranchA and BranchB, you might
do something like this:</p>
<pre><code>git diff --name-status branchA..branchB
</code></pre><p>For instance:</p>
<pre><code>git diff --name-status master..charlie01
</code></pre><h2 id="forking">Forking</h2>
<p>Frequently we do not own a repository, yet we want to work with the 
code in the repository. We could clone the repository, but then when 
it is updated, the only way to get the changes is to risk over 
writing or losing our own changes. We could make a separate copy of 
the repository, but then we would never be able to get updates. 
There is, however, a third solution: fork the repository. Now you 
own a copy of the repository. You can update it all you want. At the
same time, there is still a link (upstream) back to the original
repository. You can make your changes, and still merge in any changes
from the original. You can&#39;t contribute to the original, but you 
merge in changes from the original. If you ever wanted to merge your
changes to the original repository, then there is a way to do that.
In other words, this is how many open source accept changes. You fork
their project, develop new code, then tell the owners of the original
repository to look at your fork, and if they like it they can accept
the changes.</p>
<pre><code>Upstream Repo    ---&gt;     My Fork
          \                &lt;
           \              /
            \            /
             &gt;          &gt; 
            My Local Copy
</code></pre><p>In the diagram above, the UpStream Repo is the Original Project that
we want to fork. When we fork the repository, then we end up with
a copy of the repository on GitHub. That is what I label as <strong>My Fork</strong>.
We can then make a local copy of <strong>My Fork</strong>.</p>
<p>The path between <strong>My Fork</strong> and <strong>My Local Fork</strong> is two way: we 
can pull and push. The path between <strong>UpStream</strong> and <strong>My Local
Copy</strong> is one way: you can only pull. That is, you can only pull 
unless the Upstream repo decides to accept your commits, which is a 
special case. </p>
<p>Most of the time, we don&#39;t want to merge our commits with the
original repo, we just want to modify our version of the project
without loosing the link to the original. So we are usually only
concerned with pulling from the UpStream Repo. Therefore, I do not
show on this diagram that it is possible to get our changes back
into the upstream repository. That is a special case, and not shown
in this diagram.</p>
<p>The commands you give are as follows, though you only give the
first command once, the first time you try to update your local
copy from the upstream remote. </p>
<pre><code>git remote add upstream [GIT URL OF SOURCE REPO]
git fetch upstream
git rebase upstream/master
</code></pre><p>For instance, if you are trying to get updates from Angular-Seed, the
first command would look like this:</p>
<pre><code>git remote add upstream https://github.com/angular/angular-seed.git
</code></pre><p>And a first session might look like this:</p>
<pre><code>&gt;git remote add upstream https://github.com/angular/angular-seed.git
&gt;git fetch upstream
From https://github.com/angular/angular-seed
 * [new branch]      master     -&gt; upstream/master
 * [new branch]      v0.10.x    -&gt; upstream/v0.10.x
&gt;git rebase upstream/master
Current branch master is up to date.
</code></pre><p>After you added the remote, you can skip that step, so the session
might look more like this:</p>
<pre><code>&gt;git fetch upstream
&gt;git rebase upstream/master
Current branch master is up to date.
</code></pre><p>Exactly what you see will depend on what changes have occurred to 
upstream remote repository. In the examples I have shown, the upstream
repository and the local repository were identical, so the output
is not very interesting, but hopefully it helps you see what you
need to do.</p>
<p><a href="http://stackoverflow.com/users/6309/vonc">VonC</a> has a number of 
good explanations on StackOverflow:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/6286571/git-fork-is-git-clone/6286877#6286877">Why Fork</a></li>
<li><a href="http://stackoverflow.com/questions/3903817/pull-new-updates-from-original-github-repository-into-forked-github-repository/3903835#3903835">Pull from Original</a></li>
<li><a href="http://stackoverflow.com/questions/3611256/forking-vs-branching-in-github">Fork vs Branch</a></li>
</ul>
<h2 id="fix-broken-fork">Fix Broken Fork</h2>
<p>Stackoverflow: How to update git forked repository</p>
<p>git fetch upstream 
git checkout -f -B master upstream/master</p>
<h2 id="rebase">Rebase</h2>
<p>I use rebasing when I have two branches, and sometimes want to update
a particular branch with changes from the other branch. For instance, 
I use rebase in this scenario:</p>
<ul>
<li>I&#39;ve checked out a students repository </li>
<li>I need to make changes to it, but only I want to keep the changes. I&#39;m
not going to check in my changes to the student&#39;s repository.</li>
<li>I want to keep my changes, but also get the most recent changes from the student.</li>
</ul>
<p>Here is what I do. I create two branchs:</p>
<ul>
<li>The <strong>master</strong> branch has the students code</li>
<li>The <strong>mycopy</strong> branch has the student&#39;s code plus my changes.</li>
</ul>
<p>Here is how it works:</p>
<ul>
<li>Create a branch called mycopy: <strong>git branch mycopy</strong></li>
<li>Checkout that branch: <strong>git checkout mycopy</strong></li>
<li>Make my changes and commit them. I never push them.</li>
<li>Then I can switch back to master: git checkout master. </li>
<li>I can pull the most recent changes: <strong>git pull</strong></li>
</ul>
<p>Now I have the most recent copy of the student&#39;s repository in the
<strong>master</strong> branch. If I want to update mycopy with the most
recent changes from the student&#39;s repository, I:</p>
<ul>
<li>Switch to mycopy: <strong>git checkout mycopy</strong></li>
<li>Get the changes from master: <strong>git rebase master</strong></li>
</ul>
<p>There may well be conflicts at this point, but Git talks you through
the process of fixing them. Just edit the files that need to be fixed 
up. See the section in this document on merging code if you need help
on this. Then continue the rebase:</p>
<ul>
<li>Continue the rebase: <strong>git rebase --continue</strong></li>
</ul>
<p>The end result is that I have two copies of the students code:</p>
<ul>
<li>In <strong>master</strong> I have the student&#39;s copy of the code, as he sees it.</li>
<li>In <strong>mycopy</strong> I have all the student&#39;s code, plus my changes to it.</li>
</ul>
<p>I think it is obvious from the above, but it is probably worth saying
anyway. When I work on a student&#39;s code, I only use <strong>mycopy</strong>. So I 
spend 90 percent of my time in <strong>mycopy</strong>. I only switch back to master
in order to pull the most recent version of the student&#39;s code. When
I want to update my copy based on the most recent version of the student&#39;s
code, I switch to the <strong>mycopy</strong> branch, and then <strong>rebase</strong>.</p>
<h2 id="restructure-you-repository">Restructure you Repository</h2>
<p>If you want to restructure a Git repository, you can usually do what you
want with the following command:</p>
<pre><code>git mv X Y
</code></pre><p>Where X and Y could be either the name of a folder or a file. Examples:</p>
<pre><code>git mv MyFile.txt MyFolder/.

mkdir MyNewFolder
git mv *.txt MyNewFolder/.
git mv MyFolder MyNewFolder/.
</code></pre><p>Just as on Linux, you can rename a file with the mv command:</p>
<pre><code>git mv MyFile01.txt MyFile02.txt
</code></pre><p>This renames MyFile01.txt to MyFile02.txt.</p>
<p>If you want to delete an entire directory and its subdirectories, try this:</p>
<pre><code>git rm -r MyFolder
</code></pre><p>To delete a folder from the repository, but keep it on your local
machine, do this:</p>
<pre><code>git rm -r --cached folderName
</code></pre><p>For instance, suppose you have accidentally committed something like 
a <strong>node_modules</strong> folder to the repo that you want to keep on your 
local drive, but remove from the repo. Do this:</p>
<pre><code>git rm -r --cached node_modules
</code></pre><p>And so on...</p>
<p>The point being that you don&#39;t have to start a new repository if you want to 
change the way you have set up your directories. Just use <em>git mv</em> or <em>git 
rm</em> to delete files. </p>
<p><img class="small" src="https://drive.google.com/uc?id=0B25UTAlOfPRGaVR1dVFGTEstMDQ" alt="git rm"></p>
<pre><code>![git rm](https://drive.google.com/uc?id=0B25UTAlOfPRGaVR1dVFGTEstMDQ)
</code></pre><h2 id="permanent-delete">Permanent Delete</h2>
<p>In the following explanation I focus on permanently removing a folder called node_modules from your repository. However, this explanation applies to removing any folder or repository.</p>
<p><strong>NOTE</strong>: <em>There are two ways to permanently remove files or folders. Below you can find a discussion of how to do the delete using a tool called BFG.</em></p>
<p>If you did not include node_modules in your .gitignore file. As a result, your repository has a lot of deeply nested files in the director called Week02-GetNumbers/node_modules. As a result, your repository is many times bigger than it needs to be, and I cannot check it out on Windows, though I can on Linux. I can&#39;t check it out because the path to the files in this deeply nested directory are too long for Windows to handle.</p>
<p>You should <strong>immediately</strong> update your .gitignore file in the root of your repository so that it includes node_modules. If you have any questions, on how to do this, please ask in the discussion area.</p>
<p>The next step is to permanently remove the node_modules folders. This is an odd thing to do, because the whole purpose of Git is to keep track, for all time, of all changes that you make to a project. So even if you delete a file from a repository with git rm file_name or git rm -r node_modules, it should still be in the repository, but not in your working copy of the files. In other words, node keeps track of the files so that you can recall them if you need them. </p>
<p>It is, however, possible to permanently remove a file or folder from a repository. Doing so is a rather drastic step. Here is the command you should run from the root of your repository:</p>
<pre><code>git filter-branch --tree-filter &#39;rm -rf Week02-GetNumbers/node_modules&#39; HEAD
</code></pre><p>More in-depth explanations can be found at these sites: </p>
<ul>
<li><a href="https://help.github.com/articles/remove-sensitive-data/">git perm</a></li>
<li><a href="http://dalibornasevic.com/posts/2-permanently-remove-files-and-folders-from-git-repo">dalibornasevic</a>.</li>
</ul>
<p>After you do this, you should push your repository like this:</p>
<pre><code>git push origin master --force
</code></pre><p>Use that syntax just the one time. After you have pushed it once, you can resume pushing the repository with a simple git push command. When you are done, let me know about the change by resubmitting the assignment. I will then re-clone your repository.</p>
<p>This drastic step breaks all other copies of the repository. On your end, you should therefore delete any copies of the repository from all your machines, and then re-clone it. (I think you can keep the one on which you issued this command and the push, but all other copies should be deleted.) Don&#39;t try to run the command on all copies. That won&#39;t work. Instead, delete them, and then re-clone them with this command:</p>
<pre><code>git clone git@bitbucket.org:lastname/prog272_lastname.git
</code></pre><p>It is difficult to emphasize too often how very important it is to put <strong>node_modules</strong> in your <strong>.gitignore</strong> file. Please look on GitHub, BitBucket, etc when you are through with this process and make sure it is now included.</p>
<p><strong>NOTES</strong>: <em>I&#39;ve heard it said, but not tested that you can remove multiple copies of nested folders like this:</em></p>
<pre><code>git filter-branch --tree-filter &#39;git rm -rf --ignore-unmatch */foo/* &#39; HEAD
</code></pre><h3 id="permenant-delete-with-bfg">Permenant Delete with BFG</h3>
<p>A tool called BFG can make permanently deleting files from a repository
fairly easy. Do this if you accidentally committed something with 
a password in it, or some huge files or directories (node_modules,
.metadata) that you don&#39;t want.</p>
<p>Download the bfg jar file from here:</p>
<ul>
<li><a href="http://rtyley.github.io/bfg-repo-cleaner/">http://rtyley.github.io/bfg-repo-cleaner/</a></li>
</ul>
<p>Now create a mirror of your repository in a new directory:</p>
<pre><code>git clone --mirror git@github.com:charliecalvert/Test.git
</code></pre><p>Run BFG on to, for instance, remove all node_modules folders:</p>
<pre><code>cd Test.git
java -jar c:\src\bfg-1.11.1.jar --delete-folders node_modules
</code></pre><p>Get rid of unneeded files:</p>
<pre><code>git reflog expire --expire=now --all
git gc --prune=now --aggressive
</code></pre><p>To confirm that your work succeeded, clone the mirror:</p>
<pre><code>cd \temp
mkdir myclone
cd myclone
git clone C:\temp\Test.git
</code></pre><p>Now you will have regular repository and can explore it.</p>
<p>When you are convinced that all is good then go back to the mirrored
repo and push it:</p>
<pre><code>git push
</code></pre><p>Your old repositories are now out of date and need to be cloned again. 
Don&#39;t just update your repository, clone it a second time:</p>
<pre><code>ren Test Test.old  
git clone git@github.com:charliecalvert/Test.git
</code></pre><h2 id="git-deletions-and-workflow">Git Deletions and Workflow</h2>
<p>In general, I find one of the gotchas with using Git is that deletion and renaming of files is best done with Git. So most of the time I&#39;m working happily in Eclipse, making lots of edits and creating new files. I do all this work in Eclipse without problem. Life is good. Then I decide I want to rename a file, move it into a new directory, or delete it. At that point, I tend to switch to the command line, and give these commands with git:</p>
<pre><code>git rm MyFile.js

git mv MyFile.js MyNewName.js
</code></pre><p>The first command deletes a file, the second renames it. Here is removing (entirely deleting) a directory and its contents (obviously a dangerous command):</p>
<pre><code>git rm -r MyDirectory
</code></pre><p>Then I choose Alt-Tab to go back to Eclipse, and generally it has found my changes already. If not, I focus the Project Manager and press F5 to refresh the view. As I say, this is perhaps less than ideal, but it is my general workflow when in a Git Repository. </p>
<p>The point is that Git will track the changes we make that way, so if we need to restore a deleted file, etc, we can do so later on. Just trust Git to keep all your changes.</p>
<h2 id="undo-an-add-in-git">Undo an Add in Git</h2>
<p>Sometimes you do an add by mistake:</p>
<pre><code>git add MyFile.txt
git add YourFile.txt
</code></pre><p>Suppose that you meant to one of the adds, but not the other. You can
fix it like this:</p>
<pre><code>git reset HEAD MyFile.txt
</code></pre><p>And this resets everything to before the add:</p>
<pre><code>git reset HEAD --
</code></pre><h2 id="don-t-nest-repositories">Don&#39;t Nest Repositories</h2>
<p>You should always have a mental image of the directory tree in which you do 
your work. This can be important when you are creating a new repository. One 
mistake that new comers often make is to nest one git repository repository 
inside another. For instance, suppose you have a repository here:</p>
<pre><code>d:\src\git\Repo01
</code></pre><p>In most cases, you don&#39;t want to add another repository inside this existing repository:</p>
<pre><code>d:\src\git\Repo01\Repo02
</code></pre><p>It is not illegal to do this, but it is not likely that you did it on 
purpose, and once you have made the mistake it is hard to undo.</p>
<p>You can fix this error, but you don&#39;t want to face this problem. 
Either keep a clear mental image of your file directory structure, or use 
the Windows Explorer to review your file structure before you create a new 
repository. In general, a good plan is to create a folder called Git or 
GitHub, and then create all your repositories as children of this folder:</p>
<pre><code>c:\git\Repo1
c:\git\Repo2
</code></pre><p>Alternatively: </p>
<pre><code>c:\users\me\documents\git\Repo01 
c:\users\me\documents\git\Repo01
</code></pre><p>It is, of course, okay to complex directory structures inside any one 
repository. The mistake is not nesting directories, but nesting repositories.
For instance, the following is fine:</p>
<pre><code>C:\git\Repo1
c:\git\Repo1\Dir01
c:\git\Repo2
c:\git\Repo2\Dir01
c:\git\Repo2\Dir02
</code></pre><h2 id="terminal-is-not-fully-functional">Terminal is Not Fully Functional</h2>
<p>You can get ride of this warning by defining an environment variable called
TERM and setting it to msys.</p>
<p>On Windows, you can type:</p>
<pre><code>set TERM=msys
</code></pre><p>Or edit the Environment Variables for your Account and create a new variable
called TERM set to the msys.</p>
<p>On Linux, you export TERM = msys</p>
<pre><code>export TERM=msys
</code></pre><h2 id="git-deletions-and-workflow">Git Deletions and Workflow</h2>
<p>In general, I find one of the gotchas with using Git is that deletion and renaming of files is best done with Git. So most of the time I&#39;m working happily in Eclipse, making lots of edits and creating new files. I do all this work in Eclipse without problem. Life is good. Then I decide I want to rename a file, move it into a new directory, or delete it. At that point, I tend to switch to the command line, and give these commands with git:</p>
<pre><code>git rm MyFile.js

git mv MyFile.js MyNewName.js
</code></pre><p>The first command deletes a file, the second renames it. Here is removing (entirely deleting) a directory and its contents (obviously a dangerous command):</p>
<pre><code>git rm -r MyDirectory
</code></pre><p>Then I choose Alt-Tab to go back to Eclipse, and generally it has found my changes already. If not, I focus the Project Manager and press F5 to refresh the view. As I say, this is perhaps less than ideal, but it is my general workflow when in a Git Repository. </p>
<p>The point is that Git will track the changes we make that way, so if we need to restore a deleted file, etc, we can do so later on. Just trust Git to keep all your changes.</p>
<h2 id="undo-an-add-in-git">Undo an Add in Git</h2>
<p>Sometimes you do an add by mistake:</p>
<pre><code>git add MyFile.txt
git add YourFile.txt
</code></pre><p>Suppose that you meant to one of the adds, but not the other. You can
fix it like this:</p>
<pre><code>git reset HEAD MyFile.txt
</code></pre><p>And this resets everything to before the add:</p>
<pre><code>git reset HEAD --
</code></pre><h2 id="merging-code">Merging Code</h2>
<p>Sometimes Git tries to merge two versions of your code. If it cannot do so 
neatly, you can end up with code that has funny symbols in it, like this:</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 89e8d1f35ea5f393b3e5830d7169e071695b1cca
</code></pre><p>This means that Git could not cleanly merge two files. Instead, it puts both 
versions of the disputed code in your file, and leaves it to you to sort it 
out. Here is the contents of a file that needs to be manually merged:</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
&lt;!DOCTYPE html&gt;
&lt;!-- MidTerm-CanvasGrid --
&lt; -- Prog 282                         --
&lt; -- Spring 2013                      --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Get User&lt;/title&gt;
    &lt;/head&gt;
    &lt;link href=&quot;buttons.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;body&gt;

&lt;form method=&quot;get&quot; action=&quot;/authenticate&quot;&gt;
    &lt;p&gt;Login using OpenID&lt;/p&gt;
    &lt;img src=&quot;../Images/Openid-16x16.gif&quot; alt=&quot;OpenId Image&quot; &gt;
    &lt;input name=&quot;openid_identifier&quot; /&gt;
    &lt;input class=&quot;myButton&quot;  type=&quot;submit&quot; value=&quot;Login&quot; /&gt;
&lt;/form&gt;

&lt;/body&gt;
=======
&lt;!DOCTYPE html&gt;
&lt;!-- MidTerm-CanvasGrid  --
&lt; -- Prog 282                         --
&lt; -- Spring 2013                      --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Get User&lt;/title&gt;
    &lt;/head&gt;
    &lt;link href=&quot;buttons.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;body&gt;

&lt;form method=&quot;get&quot; action=&quot;/authenticate&quot;&gt;
    &lt;p&gt;Login using OpenID&lt;/p&gt;
    &lt;img src=&quot;../Images/Openid-16x16.gif&quot; alt=&quot;OpenId Image&quot; &gt;
    &lt;input name=&quot;openid_identifier&quot; /&gt;
    &lt;input class=&quot;myButton&quot;  type=&quot;submit&quot; value=&quot;Login&quot; /&gt;
&lt;/form&gt;

&lt;/body&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 89e8d1f35ea5f393b3e5830d7169e071695b1cca
&lt;/html&gt;
</code></pre><p>This occurs because you had two different versions of GetUser.html
that you checked into two different repositories. For instance, you
made changes at school, checked them in, then pushed. Then you went home. Then 
you made changes at home, and checked those in and tried to push. 
Suddenly you have two different versions of the same file. They need to 
be merged, and Git does the best job it can. In this case, that was less
than perfect, and you need to edit the file, and merge the two versions 
yourself. The versions are separated by code that looks like this:</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
YOUR Version 1 here
=======
YOUR Version 2 here
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 89e8d1f35ea5f393b3e5830d7169e071695b1cca
</code></pre><p>You can fix all this by editing the files and getting something like this:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;!-- MidTerm-CanvasGrid  --
&lt; -- Prog 282                         --
&lt; -- Spring 2013                      --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Get User&lt;/title&gt;
    &lt;/head&gt;
    &lt;link href=&quot;buttons.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;body&gt;

&lt;form method=&quot;get&quot; action=&quot;/authenticate&quot;&gt;
    &lt;p&gt;Login using OpenID&lt;/p&gt;
    &lt;img src=&quot;../Images/Openid-16x16.gif&quot; alt=&quot;OpenId Image&quot; &gt;
    &lt;input name=&quot;openid_identifier&quot; /&gt;
    &lt;input class=&quot;myButton&quot;  type=&quot;submit&quot; value=&quot;Login&quot; /&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>The disputed code in a file may be only one line long, or it may be nearly 
the entirety of a file as it here. You only need to merge the part that is 
in dispute. As a rule, if one part of a file is edited in one place, and a
second part of a file is edited in second place, then Git can successfully
merge the two versions without producing code like that shown above. However,
if the same line, or lines, are edited in two different place (usually by
two different people, or the same user in two locations) then there is disputed
code that must be merged manually.</p>
<p>When working on these kinds of problems you may see an error message
stating that &quot;You may want to first integrate the remote changes before
pushing again. See the note about fast-forwards...&quot;</p>
<p>You perhaps understand that the error means that you have to do 
a git pull, then a git push, in this case.</p>
<pre><code>git pull
git push
</code></pre><p>You have to do this because the code in the remote GitHub repository 
is &quot;ahead of&quot; the code in your local repository. In other words, it 
has changes that have not yet been incorporated into your local 
repository.</p>
<p>Suppose you and a friend are working on a document called Foo. Your 
friend has made changes to Foo and checked them in. Now you have 
your own copy of Foo, and you want to check it in. But if you did 
that you would overwrite his changes. So you have to first pull his 
changes into your current copy, fix any changes that might need to 
be made after the merge, and then push your copy.</p>
<p>Why is it that you have to perform the merge&quot; Why can&#39;t you push 
your code into the GitHub repository and make the merge there? 
Because a merge might result in errors. What is in the GitHub 
repository (the origin) is the canonical version of the code. It 
should always work. You can&#39;t risk creating errors there, but you 
can risk errors in your local repository. So you pull his changes 
down, make sure your changes and his changes (the merge) work 
together, and once you have manually ensured that all is good, then 
you can push to the main repository.</p>
<h2 id="git-tag">Git Tag</h2>
<p>To see the tags:</p>
<pre><code>git tag
</code></pre><p>To make a tag called v0.1:</p>
<pre><code>git tag v0.1
</code></pre><p>To add a comment (annotation) to your tag when you make it:</p>
<pre><code>git tag -a v0.1 -m &quot;This is the beginning state&quot;
</code></pre><p>Notice the -a, which stands for annotation</p>
<p>You can view information about a tag like this:</p>
<pre><code>git show v0.1
</code></pre><p>Your tag is local unless you explicitly push it like this:</p>
<pre><code>git push origin v0.1
</code></pre><h2 id="miscelaneous-information">Miscelaneous Information</h2>
<p>I&#39;ve not had a chance to sort this out yet. You can just ignore most  or all of
what is written in this section.</p>
<h2 id="learn-about-nodejs">Learn about NodeJS</h2>
<pre><code>https://www.windowsazure.com/en-us/develop/nodejs/

npm install azure node-uuid DSInit /sqlInstance:.
</code></pre><h2 id="simpledb">SimpleDb</h2>
<p><a href="https://github.com/rjrodger/simpledb">https://github.com/rjrodger/simpledb</a></p>
<h2 id="templating-engines">Templating engines</h2>
<p><a href="https://github.com/joyent/node/wiki/modules#wiki-templating">wiki-templating</a></p>
<p>This usually means that you don&#39;t have a default file set for your  application.
Try explicitly naming the file:</p>
<pre><code>http://localhost:81/server.js
</code></pre><h2 id="bitbucket-snippets">BitBucket Snippets</h2>
<p>Post snippets to BitBucket</p>
<pre><code>    #! /bin/bash

    # This gets a specific snippet
    curl https://api.bitbucket.org/2.0/snippets/ccalvert/i7pn/files/b8e99e91b0419115ac14f79ba9b3d29c6bc5446d/InstallNodePackages.sh

    # This gets information on me and my BitBuckSnippets
    # url https://api.bitbucket.org/2.0/snippets/ccalvert/

    # This gets information on a specific shippet
    # curl https://api.bitbucket.org/2.0/snippets/ccalvert/i7pn
</code></pre><p>Clone a snippet repository:</p>
<pre><code>git clone git@bitbucket.org:snippets/ccalvert/i7pn/installnodepackages.git
</code></pre></div></body></html>