<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>NodeJs</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>NodeJs</h1><p>Welcome to NodeJs</p><ul><!--TOC_Start--><li><a href="#node">Node</a></li>
<li><a href="#install-node">Install Node</a></li>
<li><a href="#npm-global">Install NPM Global Libraries</a></li>
<li><a href="#node-hints">Node Hints</a></li>
<li><a href="#pith-teaching">Pith Teaching</a></li>
<li><a href="#hello-world">Hello World</a></li>
<li><a href="#port">Setting up the Port</a></li>
<li><a href="#module-not-found">Cannot find module XXX</a></li>
<li><a href="#using-express">Using Express</a></li>
<li><a href="#icon-missing">Fav-Icon Missing - 404</a></li>
<li><a href="#hello-express">Hello Express</a></li>
<li><a href="#node-parameters">Node Parameters</a></li>
<li><a href="#working-with-post">Working with Post</a></li>
<li><a href="#using-a-directory-with-app-use">Using a Directory with app.use</a></li>
<li><a href="#express-generated-applications">Express Generated Applications</a></li>
<li><a href="#stylus">Stylus</a></li>
<li><a href="#jasmineNode">Test with Jasmine-Node</a></li>
<li><a href="#require">Require</a></li>
<li><a href="#nodemon-watches-for-changes">Nodemon Watches for Changes</a></li>
<li><a href="#debug-node-in-eclipse">Debug Node in Eclipse</a></li>
<li><a href="#upstart">UpStart</a></li>
<li><a href="#more-on-upstart">More on Upstart</a></li>
<li><a href="#eaddrinuse-and-upstart">EADDRINUSE and UpStart</a></li>
<li><a href="#creating-directories-and-copying-files">Creating Directories and Copying Files</a></li>
<li><a href="#folder-manipulation">Folder Manipulation</a></li>
<li><a href="#jshint">JSHint and Node</a></li>
<li><a href="#karmaChrome">Karma and CHROME_BIN</a></li>
<li><a href="#symbolic-link">Symbolic Links to node_modules</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#mern">MERN</a></li>
<li><a href="#nodejs-on-azure">NodeJS on Azure</a></li>
<li><a href="#simpledb">SimpleDb</a></li>
<li><a href="#cloud-9">Cloud 9</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="node"></a>
<h1>Node</h1>
<p><a href="https://nodejs.org">Node.Js</a> is a JavaScript engine and compiler. It ships with a set of accompanying libraries and plays host to very large set of third party libraries.</p>
<p>You can create general purpose JavaScript programs with Node, but it is
especially designed to help you build networked applications that link a
distributed architecture.</p>
<p>The NodeJs repository is <a href="https://github.com/nodejs/node">here</a>.</p>
<a class="anchor" id="install-node"></a>
<h2>Install Node</h2>
<p>Go to the <a href="https://github.com/charliecalvert/JsObjects/tree/master/Utilities/NodeInstall">NodeInstall</a> directory in <a href="https://github.com/charliecalvert/JsObjects">JsObjects</a>:</p>
<pre><code>    cd Git<span class="hljs-regexp">/JsObjects/</span>Utilities<span class="hljs-regexp">/NodeInstall/</span>
</code></pre><p>There are two scripts there that you should run.</p>
<ul>
<li><strong>NodeInstall.sh</strong></li>
<li><strong>InstallNodePackages.sh</strong></li>
</ul>
<p>Run them one at a time, like this:</p>
<pre><code><span class="hljs-string">./NodeInstall.sh</span>
<span class="hljs-string">./InstallNodePackages.sh</span>
</code></pre><p>The first install <strong>node</strong> and <strong>npm</strong>. The second presents you with a menu. Install only the <strong>essentials</strong>.</p>
<a class="anchor" id="npm-global"></a>
<h2>Install NPM Global Libraries</h2>
<p>Most of the actions described here are performed automatically by the <a href="https://github.com/charliecalvert/JsObjects/blob/master/Utilities/SetupLinuxBox/UbuntuAndCloudNineSetup">UbuntuAndCloudNineSetup</a> script. If you have run it, then you can skip this section unless you want to learn more about configuring global NPM libraries.</p>
<p>When using NodeJs, most developers will want to install express, karma, grunt, nodemon and jasmine-node globally.</p>
<p>If on Linux, first do this so that you don&#39;t have to use sudo:</p>
<pre><code>mkdir ~/npm
npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span><span class="hljs-built_in"> prefix </span>~/npm
</code></pre><p>Then add this to the bottom of your <strong>.bashrc</strong> and restart or source bash:</p>
<pre><code><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">"<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/npm/bin"</span>
</code></pre><p>You can now install express, karma, etc globally without using sudo:</p>
<pre><code>npm <span class="hljs-keyword">install </span>-g karma-cli
npm <span class="hljs-keyword">install </span>-g grunt-cli
npm <span class="hljs-keyword">install </span>-g <span class="hljs-keyword">jasmine-node
</span>npm <span class="hljs-keyword">install </span>-g express-generator
npm <span class="hljs-keyword">install </span>-g nodemon
npm <span class="hljs-keyword">install </span>-g mocha
</code></pre><p>If on Windows, you can issue the above commands without worrying about
<strong>sudo</strong>.</p>
<a class="anchor" id="node-hints"></a>
<h2>Node Hints</h2>
<p>Here are some ideas for basic sanity checks.</p>
<p>Check if node installed:</p>
<pre><code class="lang-bash">$ <span class="hljs-keyword">node</span> <span class="hljs-title">--version</span>
v6.<span class="hljs-number">9.0</span>
</code></pre>
<p>If you get an error instead of a version number, then it is very likely that node needs to be installed.</p>
<pre><code class="lang-bash">$ npm --version
<span class="hljs-number">3.10</span><span class="hljs-number">.8</span>
</code></pre>
<p>Again, if you get no version number, then install node:</p>
<pre><code class="lang-bash"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/Git/JsObjects/Utilities/NodeInstall</span>
<span class="hljs-string">./NodeInstall.sh</span>
</code></pre>
<p>Check if you have node utilities:</p>
<pre><code class="lang-bash"><span class="hljs-symbol">ls</span> ~/npm/<span class="hljs-keyword">bin/
</span><span class="hljs-keyword">bower </span> express  grunt  jade  nodemon
</code></pre>
<p>Here we can see that a few essential utilities are installed into <strong>~/npm/bin</strong>. If you don&#39;t see this, then run the <strong>InstallNodeUtilities</strong> script as described above.</p>
<a class="anchor" id="pith-teaching"></a>
<h2>Pith Teaching</h2>
<p>You can&#39;t run a project that depends on certain packages unless those packages are installed. We run <strong>npm install</strong> to install server side packages for a project, and we often run <strong>bower install</strong> to install client side packages for a project. NPM packages usually end up in a folder called <strong>node_modules</strong>, and bower packages usually end up in either a directory called <strong>bower_components</strong>, or in one called <strong>public/components</strong>.</p>
<p>The list of packages to be installed on the server side are kept in <strong>package.json</strong>. The list of packages to be installed on the client side are frequently kept in a file called <strong>bower.json</strong>.</p>
<p>There are various variations that can be run on these scenarios, but what is laid out in the above two paragraphs is what happens most frequently in most projects, or at least in most projects that I create.</p>
<a class="anchor" id="hello-world"></a>
<h2>Hello World</h2>
<p>Below you will find some sample node programs. Here are the steps
for using them.</p>
<ul>
<li>Create a directory to host your project. (mkdir MyFirstNodeServer)
You might for instance, create the directory in a Git repository.</li>
<li>Navigate into that directory (cd MyFirstNodeServer)</li>
<li>Create a file called server.js and use a text editor to place
one of the sample programs shown below inside your file.</li>
<li>Then run your program by typing <strong>node server.js</strong>.</li>
</ul>
<p>For instance, you might type something like this:</p>
<pre><code>C:<span class="hljs-symbol">\G</span>it<span class="hljs-symbol">\P</span>rog282-Calvert&gt;mkdir MyFirstNodeServer
C:<span class="hljs-symbol">\G</span>it<span class="hljs-symbol">\P</span>rog282-Calvert&gt;cd MyFirstNodeServer
</code></pre><p>Now create server.js as described below. Then run the server:</p>
<pre><code>C:\Git\Prog282-Calvert\MyFirstNodeServer&gt;<span class="hljs-keyword">node</span> <span class="hljs-title">server</span>.js
</code></pre><p>Once the server starts, go to your browser, and type the following:</p>
<pre><code><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:30025</span>
</code></pre><p>Here is the first, hello world style, node program that you can
place in the server.js file:</p>
<pre><code><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
  response.writeHead(<span class="hljs-number">200</span>, {<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>});
  response.end(<span class="hljs-string">'It works!\n'</span>);
}).listen(<span class="hljs-number">30025</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Server running at http://127.0.0.1:30025/'</span>);
</code></pre><p>Here is another hello world type of program. Again, place it in
a file called server.js. You might for instance, create a directory
called MySecondNodeServer, and put this second server.js file
in that directory:</p>
<pre><code><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
  response.writeHead(<span class="hljs-number">200</span>, {<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span>});
  response.end(<span class="hljs-string">'&lt;p&gt;It works&lt;/p&gt;'</span>);
}).listen(<span class="hljs-number">30025</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Server running at http://127.0.0.1:30025/'</span>);
</code></pre><p>And here is one more:</p>
<pre><code><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
    <span class="hljs-keyword">var</span> html = fs.readFileSync(<span class="hljs-string">'index.html'</span>);
    response.writeHead(<span class="hljs-number">200</span>, {<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span>});
    response.write(html);
    response.end();
}).listen(<span class="hljs-number">30025</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Server running at http://127.0.0.1:30025/'</span>);
</code></pre><p>Notice that this last program depends on the presence of a file called
index.html, where index.html can be any valid HTML file.</p>
<a class="anchor" id="port"></a>
<h2>Setting up the Port</h2>
<p>Here is how to get the server to specify the port:</p>
<p>var port = process.env.PORT || 30025;</p>
<p>By default, we use port 30025 in my Bellevue College classes.</p>
<a class="anchor" id="module-not-found"></a>
<h2>Cannot find module XXX</h2>
<p>Here is the error:</p>
<p><img src="https://s3.amazonaws.com/bucket01.elvenware.com/images/cannot-find-module-nano.png" alt="Nano"></p>
<p>Count down five lines from the line that reads &quot;Cannot find module &#39;nano&#39;&quot;. That line looks something like this:</p>
<pre><code class="lang-text">at Object &lt;anonymous&gt; (<span class="hljs-regexp">/home/</span>bcusewr<span class="hljs-regexp">/Git/</span>isit320_Sinanai<span class="hljs-number">-2016</span><span class="hljs-regexp">/Week05-DataMaster/</span>routes/Couch.<span class="hljs-string">js:</span><span class="hljs-number">12</span>:<span class="hljs-number">27</span>
</code></pre>
<p>This means that in Couch.js, at line 12, character 27, there is a problem finding the module nano. I can&#39;t be certain, but I imagine in your copy of Couch.js, at line 12, you would find this code:</p>
<pre><code class="lang-javascript">var nano = require('nano')(<span class="hljs-name">servers</span>[serverIndex])<span class="hljs-comment">;</span>
</code></pre>
<p>The program wants to load the nano package and retrieve and object from it. It is failing to do so. The reason, as others have pointed out, is probably because either:</p>
<p>You have not run <strong>npm install</strong> in order to install the package based on the code in <strong>package.json</strong>.
Or <strong>package.json</strong> does not contain instructions to insall <strong>nano</strong>.</p>
<p>If you have run <strong>npm install</strong> and the problem persists, then the it is likely that the second item above is the problem. In that case, run <strong>npm install nano --save</strong>. This will both install the package, and update package.json so that in the future, you can install <strong>nano</strong> by simply typing <strong>npm install</strong>.</p>
<a class="anchor" id="using-express"></a>
<h2>Using Express</h2>
<p>You can find the HelloExpress program on JsObjects:</p>
<p><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/NodeCode/HelloExpress">https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/NodeCode/HelloExpress</a></p>
<p>To get started, create a directory called HelloExpress and then switch into
that directory:</p>
<pre><code><span class="hljs-built_in">mkdir</span> HelloExpress
<span class="hljs-built_in">cd</span> HelloExpress
</code></pre><p>The next step will be to install the express library on which this project
relies. You can do this one of two ways. Both involve issuing commands at
the shell (command) prompt. You should issue the command in the same
directory where you place your project. The simplest command looks like this:</p>
<pre><code>npm <span class="hljs-keyword">install</span> express
</code></pre><p>When you are done, you should have a folder called <strong>node_modules</strong> with the
contents of the express library in it. You can also choose to download a
global copy of express that you can use in multiple projects:</p>
<pre><code><span class="hljs-built_in">npm</span> install -g express
<span class="hljs-built_in">npm</span> link express
</code></pre><p>After issuing these last two commands, you are set to use Express with your
current project. If you create another project that uses express, you can give
it access to the Express library by again issuing this command:</p>
<pre><code><span class="hljs-built_in">npm</span> link express
</code></pre><p>This will link in express using the global copy downloaded earlier. This
technique saves disk space, as it means you need only one copy of Express on
your system.</p>
<a class="anchor" id="icon-missing"></a>
<h2>Fav-Icon Missing - 404</h2>
<p>Sometimes, on startup, you get an error about your favorite icon missing. Put a 32 X 32 image file called called <strong>favicon.png</strong> in your <strong>public</strong> directory. Open <strong>app.js</strong>. Around line 17 you will find this code:</p>
<pre><code class="lang-javascript">// uncomment <span class="hljs-keyword">after</span> placing your favicon <span class="hljs-keyword">in</span> /public
//app.<span class="hljs-keyword">use</span>(favicon(path.join(__dirname, <span class="hljs-symbol">'public</span>', <span class="hljs-symbol">'favicon</span>.ico')));
</code></pre>
<p>Uncomment the second line and change <strong>favicon.ico</strong> to <strong>favicon.png</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// uncomment after placing your favicon in /public</span>
app.use(favicon(path.<span class="hljs-built_in">join</span>(<span class="hljs-variable">__dirname</span>, <span class="hljs-string">'public'</span>, <span class="hljs-string">'favicon.png'</span>)));
</code></pre>
<p>You can use any image editor to create or edit the PNG file. On Linux, the tool of choice is called <strong>gimp</strong>, but simpler tools will probably a do simple job like this just as well.</p>
<a class="anchor" id="hello-express"></a>
<h2>Hello Express</h2>
<p>Here is the server for the <strong>HelloExpress</strong> program:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> app = express();
<span class="hljs-keyword">var</span> fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">var</span> port = process.env.PORT || <span class="hljs-number">30025</span>;

app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
    <span class="hljs-keyword">var</span> html = fs.readFileSync(__dirname + <span class="hljs-string">'/Public/index.html'</span>);
    res.writeHeader(<span class="hljs-number">200</span>, {<span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/html"</span>});   
    res.write(html);
    res.end();
});

app.<span class="hljs-keyword">use</span>(<span class="hljs-string">"/"</span>, express.<span class="hljs-keyword">static</span>(__dirname + <span class="hljs-string">'/Public'</span>));
app.listen(port);
console.log(<span class="hljs-string">'Listening on port :'</span> + port);
</code></pre>
<p>This code has a method called app.get. It defines a default route that will
be called when the user browses to Port 30025:</p>
<pre><code><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:30025</span>
</code></pre><p>The <strong>app.get</strong> method shown here reads in a file called index.html, then
publishes it on the Node web server. When reading in the file, it uses a
library called fs (FileSystem) and a method called readFileSync.</p>
<p><strong>NOTE</strong>: <em>You can learn more about fs, readFileSync and the asynchronous method readFile in <a href="http://elvenware.com/charlie/development/web/JavaScript/JsonBasics.html#reading-json-with-node">JsonBasics</a>.</em></p>
<p>To make this program work, create a directory called Public. In it, put a
very simple HTML file such as this one:</p>
<pre><code class="lang-HTML"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"generator"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"pandoc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Express Hello<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello Experss<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A simple Node Express program<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>The file shown above is the one that will be read in by the node
readFileSync method, and then served up by the node web server.</p>
<p>Now start the node webserver by running this command:</p>
<pre><code><span class="hljs-keyword">node</span> <span class="hljs-title">server</span>.js
</code></pre><p>Here is another NODE example that uses express:</p>
<pre><code class="lang-javascript">    <span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
    <span class="hljs-keyword">var</span> app = express();
    <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

    <span class="hljs-keyword">var</span> port = process.env.PORT || <span class="hljs-number">30025</span>;

    app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"root request sent"</span>);
        <span class="hljs-keyword">var</span> html = fs.readFileSync(__dirname + <span class="hljs-string">'/public/index.html'</span>);
        res.writeHeader(<span class="hljs-number">200</span>, {<span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/html"</span>});   
        res.write(html);
        res.end();
    });

    app.get(<span class="hljs-string">'/dirname'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, result</span>) </span>{
        result.send({<span class="hljs-string">'result'</span>: __dirname});
    });

    app.get(<span class="hljs-string">'/port'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, result</span>) </span>{
        result.send({<span class="hljs-string">'result'</span>: port});
    });

    app.use(express.static(__dirname + <span class="hljs-string">'/public'</span>));

    app.listen(port);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Express server started on port %s'</span>, port);
</code></pre>
<p>The first three lines are like import or include statements in other languages
such as Java, C# or C++:</p>
<pre><code><span class="hljs-attribute">var express</span> = require(<span class="hljs-string">'express'</span>);
<span class="hljs-attribute">var app</span> = express();
<span class="hljs-attribute">var fs</span> = require(<span class="hljs-string">'fs'</span>);
</code></pre><p>The first line asks that we load in a library called Express. The second line
creates an instance of the express object. The third line brings a library called
fs (filesystem) that is built into node.</p>
<p>The next line establishs the port that your project will run on:</p>
<pre><code>var<span class="hljs-built_in"> port </span>= process.env.PORT || 30025;
</code></pre><p>The words process.env.PORT refers to the environment variable called PORT. On
many machines this will not be set, so our code specifies the value for PORT if
PORT is not assigned. If you need help with environment variables, see this
page:</p>
<ul>
<li><a href="http://www.elvenware.com/charlie/os/windows/faq.html#environment">http://www.elvenware.com/charlie/os/windows/faq.html#environment</a></li>
</ul>
<p>The next lines of code defines the action that our program will take if the
user goes to the root of our site. For instance, if we are running on localhost,
then the following method is called when the user goes to <a href="http://localhost:30025">http://localhost:30025</a>:</p>
<pre><code class="lang-javascript">    app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span></span> {
        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"root request sent"</span>);
        var html = fs.readFileSync(<span class="hljs-string">'public/index.html'</span>);
        res.writeHeader(<span class="hljs-number">200</span>, {<span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/html"</span>});   
        res.<span class="hljs-built_in">write</span>(html);
        res.<span class="hljs-keyword">end</span>();
    });
</code></pre>
<p>This code logs a debug message to the console. Then it reads in an HTML file
from the file system and packages it up using the HTTP protocol. It then
sends it to the user. In a typical scenario, the user invoked this method by
typing a URL in the address bar of a browser. Therefore the HTTP
packet is delivered to a browser and rendered there so the user can read it.</p>
<p>The following two lines of code mirror back the current directory and PORT on
which the node server is running:</p>
<pre><code class="lang-javascript">    app.get(<span class="hljs-string">'/dirname'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, result)</span> </span>{
        result.send({<span class="hljs-string">'result'</span>: __dirname});
    });

    app.get(<span class="hljs-string">'/port'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request, result)</span> </span>{
        result.send({<span class="hljs-string">'result'</span>: port});
    });
</code></pre>
<p>These commands are invoked when the user types one of the following URLS</p>
<pre><code><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:30025/dirname</span>
<span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:30025/port</span>
</code></pre><p>The express library matches up the route designated by the URLs to the app.get
or app.post method that corresponds to it. For instance, the following URL
designates a <em>route</em> called <strong>dirname</strong>:</p>
<pre><code><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:30025/dirname</span>
</code></pre><p>This method is called when Express detects that the user designated the dirname
route:</p>
<pre><code>app.get(<span class="hljs-string">'/dirname'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, result)</span> </span>{ etc...
</code></pre><p>Express knows how to handle by HTTP get verbs and HTTP post verbs:</p>
<pre><code>app.post(<span class="hljs-string">'/dirname'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, result)</span> </span>{ etc...
</code></pre><p>More on this later.</p>
<p>For now, you can Read more here:</p>
<ul>
<li><a href="http://expressjs.com/api.html#app.VERB">http://expressjs.com/api.html#app.VERB</a></li>
</ul>
<a class="anchor" id="node-parameters"></a>
<h2>Node Parameters</h2>
<p>There are three main ways to get parameters:</p>
<ul>
<li>request.query<ul>
<li>Use with get</li>
</ul>
</li>
<li>request.body<ul>
<li>Use with post</li>
</ul>
</li>
<li>request.params<ul>
<li>For getting url params: route.get(&#39;/foo:id&#39;)</li>
<li>request.params.id</li>
</ul>
</li>
</ul>
<p>Suppose you write the following, where a REST parameter is passed as the second parameter to <strong>getJSON</strong>:</p>
<pre><code class="lang-javascript">$.getJSON(<span class="hljs-string">'/walker'</span>, {<span class="hljs-attr">folder</span>: <span class="hljs-string">'Assignments'</span>},  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{ ... })
</code></pre>
<p>Then on the server end you could write the following to display the value passed from the client:</p>
<pre><code class="lang-javascript">console.<span class="hljs-built_in">log</span>('request.<span class="hljs-keyword">query</span>', request.<span class="hljs-keyword">query</span>);
</code></pre>
<p>This would produce the following output in the console:</p>
<pre><code class="lang-javascript"><span class="hljs-selector-tag">request</span><span class="hljs-selector-class">.params</span> { <span class="hljs-attribute">folder</span>: <span class="hljs-string">'Assignments'</span> }
</code></pre>
<p>Consider this useful example for loading Jade/Pug files:</p>
<pre><code class="lang-javascript">router.get(<span class="hljs-string">'/:id'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Requested: '</span>, request.params.id);
    response.render(request.params.id, {
        <span class="hljs-attr">title</span>: request.params.id
    });
});
</code></pre>
<p>This should be last route in the file. It says, in effect: <em>if none of the other routes in this file have matched the request, then assume this is a request to render a jade/pug file. For instance, if the user asks for <strong>/foo</strong>, then the code will attempt to render as HTML the file in the views directory called <strong>foo.jade</strong> or <strong>foo.pug</strong>, as the case may be.</em></p>
<a class="anchor" id="working-with-post"></a>
<h2>Working with Post</h2>
<p>We used to use a tool called bodyParser() when working with post. But
now we should use connect:</p>
<pre><code>npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">connect</span> <span class="hljs-comment">--save</span>
</code></pre><p>And in your code:</p>
<pre><code class="lang-javascript">    <span class="hljs-keyword">var</span> connect = require( <span class="hljs-string">"connect"</span> );

    <span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(connect.urlencoded());
    <span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(connect.json());
</code></pre>
<p>And then use it:</p>
<pre><code class="lang-javascript">    app.post(<span class="hljs-string">'/add'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'add called'</span>);
        <span class="hljs-built_in">console</span>.log(request.body);
        <span class="hljs-keyword">var</span> operandA = <span class="hljs-built_in">parseInt</span>(request.body.operandA);
        <span class="hljs-keyword">var</span> operandB = <span class="hljs-built_in">parseInt</span>(request.body.operandB);
        <span class="hljs-keyword">var</span> result = addingMachine.myObject.add(operandA, operandB);
        response.send({ <span class="hljs-string">"result"</span>: result });
    });
</code></pre>
<p>Example code is found here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/NodeCode/NodeRoutes01/server.js">NodeRoutes01</a></li>
<li><a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/NodeCode/NodeRoutes02/server.js">NodeRoutes02</a></li>
</ul>
<p>Good job troubleshooting.</p>
<p>There is some background here that I have not covered sufficiently in class. See the routes methods section on this page:</p>
<p><a href="https://expressjs.com/en/guide/routing.html">https://expressjs.com/en/guide/routing.html</a> (Links to an external site.)</p>
<p>In the (slightly updated) NodesRoutes02 (Links to an external site.) program notice that I have two Add methods:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// With a get, the parameters are passed in request.query</span>
router.get(<span class="hljs-string">'/add'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'add get called'</span>);
    <span class="hljs-built_in">console</span>.log(request.query);
    <span class="hljs-keyword">var</span> operandA = <span class="hljs-built_in">parseInt</span>(request.query.operandA);
    <span class="hljs-keyword">var</span> operandB = <span class="hljs-built_in">parseInt</span>(request.query.operandB);
    <span class="hljs-keyword">var</span> result = addingMachine.myObject.add(operandA, operandB);
    response.send({
        <span class="hljs-string">"result"</span>: result
    });
});

<span class="hljs-comment">/* To handle a post, we have to add express.bodyParser, shown above
   Now our parameters come in on request.body */</span>
router.post(<span class="hljs-string">'/add'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'add post called'</span>);
    <span class="hljs-built_in">console</span>.log(request.body);
    <span class="hljs-keyword">var</span> operandA = <span class="hljs-built_in">parseInt</span>(request.body.operandA);
    <span class="hljs-keyword">var</span> operandB = <span class="hljs-built_in">parseInt</span>(request.body.operandB);
    <span class="hljs-keyword">var</span> result = addingMachine.myObject.add(operandA, operandB);
    response.send({
        <span class="hljs-string">"result"</span>: result
    });
});
</code></pre>
<p>One is a POST and one is a GET. Here is the client side code that calls them:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> operandA = $(<span class="hljs-string">"#operandA"</span>).val();
        <span class="hljs-keyword">var</span> operandB = $(<span class="hljs-string">"#operandB"</span>).val();

        $.ajax({
            <span class="hljs-attr">url</span>: <span class="hljs-string">"/add"</span>,
            <span class="hljs-attr">type</span>: <span class="hljs-string">"GET"</span>,
            <span class="hljs-attr">data</span>: {
                <span class="hljs-string">"operandA"</span>: operandA,
                <span class="hljs-string">"operandB"</span>: operandB
            },
            <span class="hljs-attr">dataType</span>: <span class="hljs-string">"json"</span>,
            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
                $(<span class="hljs-string">"#addResult"</span>).html(operandA + <span class="hljs-string">" + "</span> + operandB + <span class="hljs-string">" = "</span> + data.result);
            },
            <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">jqXHR, textStatus, errorThrown</span>) </span>{
                <span class="hljs-built_in">console</span>.log(jqXHR.responseText);
                <span class="hljs-built_in">console</span>.log(textStatus);
                <span class="hljs-built_in">console</span>.log(errorThrown);
            }
        });
    };

    <span class="hljs-keyword">var</span> addPost = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> operandA = $(<span class="hljs-string">"#operandAPost"</span>).val();
        <span class="hljs-keyword">var</span> operandB = $(<span class="hljs-string">"#operandBPost"</span>).val();

        $.ajax({
            <span class="hljs-attr">url</span>: <span class="hljs-string">"/add"</span>,
            <span class="hljs-attr">type</span>: <span class="hljs-string">"POST"</span>,
            <span class="hljs-attr">data</span>: {
                <span class="hljs-string">"operandA"</span>: operandA,
                <span class="hljs-string">"operandB"</span>: operandB
            },
            <span class="hljs-attr">dataType</span>: <span class="hljs-string">"json"</span>,
            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
                $(<span class="hljs-string">"#addResultPost"</span>).html(operandA + <span class="hljs-string">" + "</span> + operandB + <span class="hljs-string">" = "</span> + data.result);
            },
            <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">jqXHR, textStatus, errorThrown</span>) </span>{
                <span class="hljs-built_in">console</span>.log(jqXHR.responseText);
                <span class="hljs-built_in">console</span>.log(textStatus);
                <span class="hljs-built_in">console</span>.log(errorThrown);
            }
        });
    };
</code></pre>
<p>Notice that one does a get and one does a post.</p>
<pre><code class="lang-javascript">url: <span class="hljs-string">"/add"</span>,
 type: <span class="hljs-string">"<span class="hljs-keyword">GET</span>"</span>,
---------
url: <span class="hljs-string">"/add"</span>,
type: <span class="hljs-string">"<span class="hljs-keyword">POST</span>"</span>
</code></pre>
<p>And notice that the server side code differs:</p>
<pre><code class="lang-javascript">--- The GET example ---------------------------
 <span class="hljs-built_in">console</span>.log(request.query);
    <span class="hljs-keyword">var</span> operandA = <span class="hljs-built_in">parseInt</span>(request.query.operandA);
    <span class="hljs-keyword">var</span> operandB = <span class="hljs-built_in">parseInt</span>(request.query.operandB);
--- The POST example --------------------------
    <span class="hljs-built_in">console</span>.log(request.body);
    <span class="hljs-keyword">var</span> operandA = <span class="hljs-built_in">parseInt</span>(request.body.operandA);
    <span class="hljs-keyword">var</span> operandB = <span class="hljs-built_in">parseInt</span>(request.body.operandB);
</code></pre>
<p>The get uses request.query and the post uses request.body. I was trying to explain all this earlier, but I was not giving the subject sufficient weight. The get methods sends the query as part of the URL, the POST methods sends the data a little differently, as a port of the HTTP request body. The practical difference is that we can send much more data back and forth with a post than with a get.</p>
<p>The $.getJSON and $.ajax do the same thing. In fact, $.getJSON calls $.ajax to do the actual work. After a bit, it is simpler to call $.ajax directly, but at first it is easier to call $.getJSON.</p>
<a class="anchor" id="using-a-directory-with-app-use"></a>
<h2>Using a Directory with app.use</h2>
<p>There is one more very important line is the code sample shown in the previous
section:</p>
<pre><code class="lang-javascript">app.<span class="hljs-keyword">use</span>(express.<span class="hljs-keyword">static</span>(__dirname + '/<span class="hljs-keyword">public</span>'));
</code></pre>
<p>As you recall, our default route for this node script loads a file called
index.html that is stored in a folder called public:</p>
<pre><code class="lang-javascript"><span class="hljs-attribute">    var html</span> = fs.readFileSync(__dirname + <span class="hljs-string">'/public/index.html'</span>);
</code></pre>
<p>The app.use command shown above ensures that Express knows to look in the
public directory for your files. If you don&#39;t employ app.use to make directories
known to express, then your program may not be able to locate your files.</p>
<p>Inside of index.html, you may want to reference JavaScript and CSS files. If
you place them in the public directory, then you should reference them like
this:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/public/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><p>Finally, let&#39;s think for a moment about how to load index.html in our default
handler. In many cases the following code will work, using a relative path
to find the public directory:</p>
<pre><code class="lang-javascript"><span class="hljs-attribute">var html</span> = fs.readFileSync(<span class="hljs-string">'public/index.html'</span>);
</code></pre>
<p>However, the following code is preferred:</p>
<pre><code class="lang-javascript"><span class="hljs-attribute">var html</span> = fs.readFileSync(__dirname + <span class="hljs-string">'/public/index.html'</span>);
</code></pre>
<p>This code references the path to the directory where your node program
was launched, and then adds <strong>public/index.html</strong> to it. For instance, if your
server.js file were in a directory called <strong>src</strong> then the following path
would be used by <strong>readFileSync</strong>:</p>
<pre><code>C:<span class="hljs-symbol">\\</span>users<span class="hljs-symbol">\\</span>sally<span class="hljs-symbol">\\</span>src<span class="hljs-symbol">\\</span>public<span class="hljs-symbol">\\</span>index.html
</code></pre><p>If your program were in subdirectory of your home directory on Linux, then the
path used by <strong>readFileSync</strong> might look like this:</p>
<pre><code><span class="hljs-regexp">/home/</span>sally<span class="hljs-regexp">/src/</span><span class="hljs-keyword">public</span><span class="hljs-regexp">/index.html</span>
</code></pre><a class="anchor" id="express-generated-applications"></a>
<h2>Express Generated Applications</h2>
<p>Once you have some of the core concepts behind Express under your belt,
it is time to move on to full Express application. To get started, be
sure you have both Express and a template library called Pug installed:</p>
<pre><code>npm <span class="hljs-keyword">install</span> -g express
npm <span class="hljs-keyword">install</span> -g pug-cli
</code></pre><p>Make sure the express application is on your path. It is usually found
in AppData/Roaming. For instance, the Express executable is found here
on my system:</p>
<pre><code>    C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\C</span>harlie<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\n</span>pm<span class="hljs-symbol">\n</span>ode<span class="hljs-symbol">\_</span>modules.bin
</code></pre><p>On some systems it is here:</p>
<pre><code>C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\C</span>harlie<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\n</span>pm\
</code></pre><p>In either case, you are looking for a program called express and
express.cmd. Make sure they are on your path.</p>
<p>It may also be available here in your generated applications:</p>
<pre><code>    <span class="hljs-selector-tag">node_modules</span><span class="hljs-selector-class">.bin</span>
</code></pre><p>Now let Express generate the framework for your application. For instance,
the following command generates an application called MyApp01:</p>
<pre><code><span class="hljs-built_in">express</span> MyApp01
</code></pre><p>This command creates a directory called MyApp01. Inside it you will find
one main file and three subdirectories:</p>
<pre><code>%20%20%20%20MyApp01%0A%20%20%20%20MyApp01/app.js%20%20%20//%20We%20usually%20call%20this%20file%20server.js%0A%20%20%20%20MyApp01/public%0A%20%20%20%20MyApp01/routes%0A%20%20%20%20MyApp01/views
</code></pre><p>Alternatively, you can do something like this, which provides a library
called stylus for use with CSS files:</p>
<pre><code>express -<span class="hljs-keyword">c</span> stylus MyApp<span class="hljs-number">02</span>
</code></pre><p>You can read about stylus in more depth later in this document.</p>
<p>By default, Express applications run on port 3000. Since we typically
run our applications on port 30025, the first thing you might do is
open <strong>app.js</strong> and modify the line that specifies the default port:</p>
<pre><code>app.set(<span class="hljs-symbol">'port</span>', <span class="hljs-keyword">process</span>.env.<span class="hljs-keyword">PORT</span> || <span class="hljs-number">30025</span>);
</code></pre><a class="anchor" id="stylus"></a>
<h2>Stylus</h2>
<p>Stylus is a library that allows you to create CSS pages using a technique
that is a bit reminicescent of a template library or of markdown. In
other words, it provides an alternative syntax for composing CSS pages,
as well as a syntax for working with variables and parameters while
composing CSS pages.</p>
<p><a href="http://learnboost.github.io/stylus/">The Stylus Home Page</a></p>
<p>When you add stylus to a node express page, the following line of code
should be present in your main express file:</p>
<pre><code>    app.<span class="hljs-keyword">use</span>(<span class="hljs-keyword">require</span>(<span class="hljs-string">'stylus'</span>).middleware(__dirname + <span class="hljs-string">'/public'</span>));
</code></pre><p>Here is a Simple Style Page</p>
<pre><code><span class="hljs-function"><span class="hljs-title">border-stuff</span><span class="hljs-params">()</span></span>
    <span class="hljs-attribute">border</span> solid thin black

<span class="hljs-selector-tag">body</span>
    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#00AA00</span>
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">50px</span>
    <span class="hljs-attribute">font</span>: <span class="hljs-number">14px</span> <span class="hljs-string">"Lucida Grande"</span>, Helvetica, Arial, sans-serif

<span class="hljs-selector-tag">a</span>
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#004400</span>

<span class="hljs-selector-tag">nav</span>
    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#00CC00</span>
    <span class="hljs-attribute">border</span>-stuff(<span class="hljs-number">0</span>)
    <span class="hljs-attribute">padding</span> <span class="hljs-number">25px</span>
    <span class="hljs-selector-tag">ul</span>
        <span class="hljs-attribute">list-style</span> none
        <span class="hljs-selector-tag">li</span>
            <span class="hljs-attribute">display</span> inline
            <span class="hljs-attribute">border</span>-stuff(<span class="hljs-number">0</span>)
            <span class="hljs-attribute">margin</span> <span class="hljs-number">10px</span>
            <span class="hljs-attribute">padding</span> <span class="hljs-number">5px</span>
            <span class="hljs-attribute">background-color</span> <span class="hljs-number">#00FF00</span>
</code></pre><a class="anchor" id="jasmineNode"></a>
<h2>Test with Jasmine-Node</h2>
<p>First install jasmine-node:</p>
<pre><code>sudo npm install -g jasmine-<span class="hljs-keyword">node</span><span class="hljs-title"></span>
</code></pre><p>You will also want to install request locally with one of the following:</p>
<pre><code>npm <span class="hljs-keyword">install</span> request
npm <span class="hljs-keyword">install</span> request <span class="hljs-comment">--save-dev</span>
</code></pre><p>The second option saves your command into <strong>package.json</strong>, if <strong>package.json</strong>
already exists.</p>
<p>Create a simple route you want to test:</p>
<pre><code>app.get(<span class="hljs-string">'/hello'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request, response)</span> </span>{ <span class="hljs-string">'use strict'</span>;
    response.send(<span class="hljs-string">'Hi there.'</span>);
});
</code></pre><p>Define a basic Jasmine-Node test by saving the following
as <strong>Tests/SimpleSpec.js</strong>:</p>
<pre><code>var request = require('request')<span class="hljs-comment">;</span>

describe(<span class="hljs-string">"A suite"</span>, function() {
    it(<span class="hljs-string">"should respond with hello world"</span>, function(<span class="hljs-name">done</span>) {
        request(<span class="hljs-string">"http://localhost:30025/hello"</span>, function(<span class="hljs-name">error</span>, response, body) {
            expect(<span class="hljs-name">body</span>).toEqual(<span class="hljs-string">"Hi there."</span>)<span class="hljs-comment">;</span>
            done()<span class="hljs-comment">;</span>
        })<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre><p>Now start your server running in one shell:</p>
<pre><code><span class="hljs-keyword">node</span> <span class="hljs-title">Server</span>.js
</code></pre><p>Then open a second shell and run your tests:</p>
<pre><code>jasmine-<span class="hljs-keyword">node</span> <span class="hljs-title">Tests</span>/
</code></pre><p>Voila! You are done.</p>
<a class="anchor" id="require"></a>
<h2>Require</h2>
<p>Let&#39;s look at this line of code:</p>
<pre><code><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
</code></pre><p>It says that you want to load a copy of a file from the Express package and retrieve an object from it.</p>
<p>In <strong>package.json</strong> we ask <strong>npm</strong> to install the express library into <strong>node modules</strong>:</p>
<pre><code>  <span class="hljs-string">"dependencies"</span>: {
    <span class="hljs-string">"body-parser"</span>: <span class="hljs-string">"~1.12.0"</span>,
    <span class="hljs-string">"cookie-parser"</span>: <span class="hljs-string">"~1.3.4"</span>,
    <span class="hljs-string">"debug"</span>: <span class="hljs-string">"~2.1.1"</span>,
    <span class="hljs-string">"express"</span>: <span class="hljs-string">"~4.12.2"</span>,    // Ask NPM <span class="hljs-keyword">to</span> <span class="hljs-keyword">load</span> Express
    <span class="hljs-string">"jade"</span>: <span class="hljs-string">"~1.9.2"</span>,
    <span class="hljs-string">"morgan"</span>: <span class="hljs-string">"~1.5.1"</span>,
    <span class="hljs-string">"serve-favicon"</span>: <span class="hljs-string">"~2.2.0"</span>
  }
</code></pre><p>Because that line is found in <strong>package.json</strong>, the following directory is created in <strong>node_modules</strong>:</p>
<pre><code>Week04-AngularMongoState<span class="hljs-symbol">\n</span>ode_modules<span class="hljs-symbol">\e</span>xpress
</code></pre><p>In that folder is a directory called <strong>lib</strong> and there is found a file called <strong>express.js</strong>. It is that file that is loaded when we call <strong>require</strong> and pass in <strong>express</strong>. Since we need the express library in a nodejs express project, it is important that we don&#39;t change that line.</p>
<a class="anchor" id="nodemon-watches-for-changes"></a>
<h2>Nodemon Watches for Changes</h2>
<p>Install nodemon:</p>
<pre><code>npm <span class="hljs-keyword">install</span> -g nodemon
</code></pre><p>Now use it to start your application:</p>
<pre><code>nodemon <span class="hljs-keyword">server</span>.js
</code></pre><p>Now you won&#39;t have to restart your application each time you change
the source.</p>
<a class="anchor" id="debug-node-in-eclipse"></a>
<h2>Debug Node in Eclipse</h2>
<p>Here is how to debug outside of Eclipse:</p>
<ul>
<li><a href="http://nodejs.org/api/debugger.html">http://nodejs.org/api/debugger.html</a></li>
</ul>
<p>Though it is not necessary for debugging, this is a good time to check that
you have JsHint installed. If you don&#39;t have it installed, or if you are at all
unclear how to install new software into Eclipse, then please see this link:</p>
<ul>
<li><a href="http://elvenware.com/charlie/development/android/Eclipse.shtml#jsHint">http://elvenware.com/charlie/development/android/Eclipse.shtml#jsHint</a></li>
</ul>
<p>Just to review, here is the URL for JsHint:</p>
<ul>
<li><a href="http://github.eclipsesource.com/jshint-eclipse/updates/">http://github.eclipsesource.com/jshint-eclipse/updates/</a></li>
</ul>
<p>After you choose Help | Install New Software and click the add button, you fill
in the dialog like this:</p>
<p><img src="http://elvenware.com/charlie/development/android/images/JsHint02.png" alt="Install JsHint in Eclipse"></p>
<p>Let&#39;s now start talking about debugging inside Eclipse. You need to
Install V8 into Eclipse. Choose <strong>Help | Install Software</strong> as above, and
enter this URL:</p>
<ul>
<li><a href="http://chromedevtools.googlecode.com/svn/update/dev/">http://chromedevtools.googlecode.com/svn/update/dev/</a></li>
</ul>
<p><img src="images/ChromeV8Install10.png" alt="V8 Install"></p>
<p>Next you need to install Node Eclipse. Again Choose <strong>Help | Install Software</strong>
and this time use this URL:</p>
<ul>
<li><a href="http://www.nodeclipse.org/updates">http://www.nodeclipse.org/updates</a></li>
</ul>
<p>Start the program like this:</p>
<pre><code><span class="hljs-keyword">node</span> <span class="hljs-title">--debug-brk</span> server01.js
</code></pre><p>Regardless of the port that you told your program to run on, the debugger
runs on port 5858:</p>
<p>G:\Git\OpenId03&gt;node --debug-brk server01.js
debugger listening on port 5858</p>
<p>When starting the server in the browser, however, you should still use the
port you assigned:</p>
<pre><code><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:30025</span>
</code></pre><p>In Eclipse set up a Debug run configuration. First bring up the Debug Run
Configuration dialog:</p>
<p><img src="images/NodeDebug00.png" alt="Launch Debug Config Dialog"></p>
<p>Then set up the configuration for the V8 engine on port 5858:</p>
<p><img src="images/NodeDebug01.png" alt="Debug Run Configuration"></p>
<p>I am not able to set breakpoints using the tools. Instead, I have to go into
the code and manually type the word <strong>debugger;</strong> on the line where I want the
debugger to break. Then I do the following:</p>
<ul>
<li>type <strong>node --debug-brk server01.js</strong> at the command line</li>
<li>start the debugger in Eclipse, press F8 once to get passed the first breakpoint.</li>
<li>launch my program in in the browser: <a href="http://localhost:30025">http://localhost:30025</a></li>
</ul>
<p>The program will then stop at my breakpoint:</p>
<p><img src="images/NodeDebug02.png" alt="The debugger hits breakpoint and stops on line 27"></p>
<p>You can step through the debugger with the following keys:</p>
<ul>
<li>F5 (Step into)</li>
<li>F6 (Step over)</li>
<li>F8 (Continue - run)</li>
</ul>
<p><img src="images/NodeDebug03.png" alt="Viewing the request.query object in the debugger"></p>
<a class="anchor" id="upstart"></a>
<h2>UpStart</h2>
<p>UpStart is a Linux utility that ships with recent Ubuntu releases.
It can be used to ensure that your node servers or other program
stay in memory even after you have closed your shell. It will even
restart the programs automatically if the OS is rebooted.</p>
<p>Note that this project includes a file called ExpressSend.config.
You can use this file to ensure that your application is launched
when your OS boots, and that it will stay running, even if it
temporarily crashes.</p>
<p>In JsObjects, there is a program called ExpressSend:</p>
<pre><code>JsObjects<span class="hljs-regexp">/JavaScript/</span>NodeCode<span class="hljs-regexp">/ExpressSend</span>
</code></pre><p>If you open ExpressSend.config in an editor, you will see a few
portions of the line that begins with the word exec that you might
want to edit to convert them for use in your own programs. For
instance, seee the line that begins like this:</p>
<pre><code>exec <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/nodejs /</span>home<span class="hljs-regexp">/charlie/</span>ExpressSend<span class="hljs-regexp">/server.js</span>
</code></pre><p>If your version of the server is located elsewhere, then change the
line as necessary. For instance:</p>
<pre><code>exec <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/nodejs /</span>home<span class="hljs-regexp">/belinda/</span>bin<span class="hljs-regexp">/server.js</span>
</code></pre><p>Note that I replaced charlie/ExpressSend with belinda/bin. You
should edit your version of ExpressSend.config to reflect that paths
and file names on your system.</p>
<p>You can create a <a href="http://www.cyberciti.biz/tips/understanding-unixlinux-symbolic-soft-and-hard-links.html">symbolic
link</a> to a deeply nested directory like this:</p>
<pre><code>ln -s <span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/Git/</span>Prog282-Hints<span class="hljs-regexp">/CanvasGrid03 CanvasGrid</span>
</code></pre><p>If you give that command in your home directory, then you will end
up with a directory that looks like this:</p>
<pre><code>/<span class="hljs-built_in">home</span>/ubuntu/CanvasGrid
</code></pre><p>The point, of course, is that this new directory is an alias, soft
link to the CanvasGrid03 directory.</p>
<p>Place ExpressSend.config in the /etc/init directory:</p>
<pre><code>/etc/init/ExpressSend.<span class="hljs-built_in">config</span>
</code></pre><p>The command to copy it to appropriate directory would be:</p>
<pre><code>sudo cp ExpressSend<span class="hljs-selector-class">.config</span> /etc/init/.
</code></pre><p>Once the file is in the /etc/init directory, you can start your
program by typing the following:</p>
<pre><code>sudo <span class="hljs-literal">start</span> ExpressSend
</code></pre><p>You can stop it with following command:</p>
<pre><code>sudo <span class="hljs-built_in">stop</span> ExpressSend
</code></pre><p>When you reboot the system, your program will start automatically.</p>
<p>Error messages and other output from your program are recorded in
the following location:</p>
<pre><code>/var/log/<span class="hljs-keyword">node</span>.<span class="hljs-title">log</span>
</code></pre><p>If you examine the script, you can see that this file name is configurable.</p>
<p>You should create one script of this type for each program that you
want to launch.</p>
<p>In your node program, you may need to alter paths to your files so
that they include the __dirname variable:</p>
<pre><code class="lang-javascript"><span class="hljs-attribute">var html</span> = fs.readFileSync(__dirname + <span class="hljs-string">'/Public/index.html'</span>);
</code></pre>
<p>The following <strong>might</strong> also work, though i need to test it more:</p>
<pre><code><span class="hljs-attribute">var html</span> = fs.readFileSync(<span class="hljs-string">'./Public/index.html'</span>);
</code></pre><p>For now, I recommend the first option. This is necessary because your
program is no longer being launched from the directory in which you
created it, but instead, is start from the /etc/init directory. There
fore you need to use <strong>__dirname</strong>, which resolves to the complete path
to your file. For instance:</p>
<pre><code><span class="hljs-regexp">/home/</span>charlie<span class="hljs-regexp">/git/</span>MyProgram<span class="hljs-regexp">/Public/i</span>ndex.html
</code></pre><p>The <strong>__dirname</strong> variable, which is built into Node, gives you
the /home/charlie/git/MyProgram part of the path. Of course, on your
system that bit of the path will probably be different. Here is more
information on dirname:</p>
<pre><code>&lt;http:<span class="hljs-regexp">//</span>nodejs.org<span class="hljs-regexp">/docs/</span>latest<span class="hljs-regexp">/api/g</span>lobals.html<span class="hljs-comment">#globals_dirname&gt;</span>
</code></pre><a class="anchor" id="more-on-upstart"></a>
<h2>More on Upstart</h2>
<p>We specify where the log file will be written in this part of our upstart
scripts:</p>
<pre><code>exec <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/nodejs /</span>home<span class="hljs-regexp">/ubuntu/</span>ExpressSend<span class="hljs-regexp">/server.js &gt;&gt; /</span>var<span class="hljs-regexp">/log/</span>node.log <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>
</code></pre><p>This command has three parts that we need to get write:</p>
<ul>
<li><strong>exec</strong> - This command executes a process or program.</li>
<li><strong>/usr/bin/nodejs</strong> - This parameter points at our nodejs program. This is the program to be executed</li>
<li><strong>/home/ubuntu/ExpressSend/server.js</strong> - This is the path to the script that nodejs will run.</li>
</ul>
<p>Then we redirect the output from the program to a text file called node.log that is located in the /var/log directory:</p>
<pre><code>&gt;&gt; /var/log/<span class="hljs-keyword">node</span>.<span class="hljs-title">log</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>
</code></pre><p>To see the content of that file, run this command:</p>
<pre><code>cat /var/log/<span class="hljs-keyword">node</span>.<span class="hljs-title">log</span>
</code></pre><p>That is the most important command when it comes to debugging our UpStart scripts.</p>
<p>Let&#39;s talk for a minute more about this strange command:</p>
<pre><code>&gt;&gt; /var/log/<span class="hljs-keyword">node</span>.<span class="hljs-title">log</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>
</code></pre><p>The &gt; character redirects the output from one command to some other place,
usually a file. So this command sends the output of the echo command to a
file called foo.txt:</p>
<pre><code><span class="hljs-built_in">echo</span> foo &gt; foo.txt
</code></pre><p>After the command is run, foo.txt contains the string foo.</p>
<p>This command appends the output of the echo command to foo.txt:</p>
<pre><code>echo bar <span class="hljs-meta">&gt;&gt; </span>foo.txt
</code></pre><p>Now foo.txt contains both foo and bar. The &gt; operator will overwrite
foo.txt, and the &gt;&gt; operator will append data to it.</p>
<p>All this is called redirection, which is different from piping, which is
done with the | symbol.</p>
<p>This part of the command is more complicated:</p>
<pre><code><span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>
</code></pre><p>There are actually two streams of output that can occur when we launch a
program. One is the standard output stream, and that is what we are redirecting
above. The other is stderr, which is an error stream. By error stream, I mean
that it is a stream that contains the output produced by errors in our program.</p>
<p>The bizarre looking <strong>2&gt;&amp;1</strong> command redirects stderr to the same place as
stdout. This means that both the normal text, and the error text, is being
redirected to the same place. In our case, they are both being redirected to
<strong>node.log</strong>. When we read (cat) <strong>/var/log/node.log</strong>, we are therefore seeing
all the standard output, and all the error output, from our program.</p>
<a class="anchor" id="eaddrinuse-and-upstart"></a>
<h2>EADDRINUSE and UpStart</h2>
<p>The EADDRINUSE error is <a href="#EADDRINUSE">introduced above</a>. Attemps to fix the error might be complicated if you are on a Linux box and using Upstart. UpStart keeps your program running even after you close the command prompt. This means you can&#39;t stop the program by just typing Ctrl-C.</p>
<p>When using UpStart, remember to stop any running programs, such as our
ExpressSend sample, like this:</p>
<pre><code>sudo <span class="hljs-built_in">stop</span> ExpressSend
</code></pre><p>You might think that you can tell if a program is running on a port
by going to browser and seeing if anything comes up when you type in
the address and port of your server:</p>
<p><a href="http://192.168.0.1:30025">http://192.168.0.1:30025</a></p>
<p>That should help you tell if something is running on that port, but
it might not if you tried to launch something on that port, but it
failed during the launch. In particular, sometimes an attempt to
start a node program with UpStart will fail:</p>
<pre><code>sudo <span class="hljs-literal">start</span> ExpressSend
</code></pre><p>You have to check <strong>/var/log/node.log</strong> to see if there are errors. But
the port can be munged up even if the program did not start
correctly. To fix the problem, just tell the program to stop running. If
necessary, remove the script from /etc/init. This can be important
because Linux will try to rerun the script when your server restarts:</p>
<p>sudo rm /etc/init/ExpressSend.config</p>
<p>Like all powerful tools, UpStart can be a double edged sword. It gives
you control over your system, but the power it grants you can also be
source of trouble.</p>
<a class="anchor" id="creating-directories-and-copying-files"></a>
<h2>Creating Directories and Copying Files</h2>
<p>See the Library in the following project for an example of how to copy
files and make directories:</p>
<pre><code>JsObjects<span class="hljs-regexp">/JavaScript/</span>Syntax<span class="hljs-regexp">/MakeDirectory.</span>
</code></pre><p>To create a directory:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mkdirp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mkdirp'</span>);

<span class="hljs-keyword">var</span> createDirectory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">directory</span>) </span>{
    mkdirp(directory, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-built_in">console</span>.log(err);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Created directory"</span>);
        }
    });
};
</code></pre>
<p>For mkdirp: <strong>npm install mkdirp</strong></p>
<p>And to copy a file:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> copyFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source, target</span>) </span>{

    <span class="hljs-keyword">var</span> rd = fs.createReadStream(source);
    rd.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
        done(err);
    });
    <span class="hljs-keyword">var</span> wr = fs.createWriteStream(target);
    wr.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
        done(err);
    });
    wr.on(<span class="hljs-string">"close"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ex</span>) </span>{
        done(<span class="hljs-string">'Success: '</span> + ex);
    });
    rd.pipe(wr);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">done</span>(<span class="hljs-params">msg</span>) </span>{
        <span class="hljs-built_in">console</span>.log(msg);
    }
};
</code></pre>
<a class="anchor" id="folder-manipulation"></a>
<h2>Folder Manipulation</h2>
<p>A library with a routine for ensuring a directory exists and for
recursively removing directories.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mkdirp = <span class="hljs-keyword">require</span>(<span class="hljs-string">'mkdirp'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> path = <span class="hljs-keyword">require</span>(<span class="hljs-string">"path"</span>);

<span class="hljs-keyword">var</span> SimpleDir = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SimpleDir</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-keyword">var</span> makeDir = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(folder)</span> </span>{
        mkdirp(folder);
    }

    <span class="hljs-comment">// Test if a directory exists, if it does not exist create it</span>
    SimpleDir.prototype.ensureDir = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(folder)</span> </span>{
        fs.exists(folder, existsFunc);
    }

    <span class="hljs-comment">// Synchronous version of directory exists</span>
    SimpleDir.prototype.ensureDirSync = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(folder)</span> </span>{
        currentFolder = folder;
        <span class="hljs-keyword">if</span> (fs.existsSync(folder)) {
            <span class="hljs-keyword">return</span> fs.statSync(folder);
        } <span class="hljs-keyword">else</span> {
            makeDir(folder);
            <span class="hljs-keyword">return</span> <span class="hljs-string">'successfully created directory'</span>;
        }        
    };

    <span class="hljs-comment">// Remove directories recursively</span>
    <span class="hljs-comment">// Credit to tkihira: https://gist.github.com/tkihira/2367067</span>
    SimpleDir.prototype.rmdirSync = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(dir)</span> </span>{
        <span class="hljs-keyword">var</span> <span class="hljs-keyword">list</span> = fs.readdirSync(dir);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">list</span>.length; i++) {
            <span class="hljs-keyword">var</span> filename = path.join(dir, <span class="hljs-keyword">list</span>[i]);
            <span class="hljs-keyword">var</span> stat = fs.statSync(filename);

            <span class="hljs-keyword">if</span>(filename == <span class="hljs-string">"."</span> || filename == <span class="hljs-string">".."</span>) {
                <span class="hljs-comment">// pass these files</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stat.isDirectory()) {
                <span class="hljs-comment">// rmdir recursively</span>
                this.rmdirSync(filename);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// rm filename</span>
                fs.unlinkSync(filename);
            }
        }
        fs.rmdirSync(dir);
    };

    <span class="hljs-keyword">return</span> SimpleDir;
})();

exports.dirs = <span class="hljs-keyword">new</span> SimpleDir();
</code></pre>
<p>You might use it in node like this:</p>
<pre><code><span class="hljs-keyword">var</span> dirLib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Library/SimpleDir'</span>);

<span class="hljs-keyword">var</span> folder = <span class="hljs-string">'foo/bar/bam'</span>;

dirLib.dirs.ensureDirSync(folder);
dirLib.dirs.rmdirSync(<span class="hljs-string">'foo'</span>);
</code></pre><a class="anchor" id="jshint"></a>
<h2>JSHint and Node</h2>
<p>You can run JSHint from node. First install JSHint:</p>
<pre><code>npm <span class="hljs-keyword">install</span> -g jshint
</code></pre><p>Now try running JSHint by typing the command <strong>jshint</strong> at the command line.
If you see an error about the path, then set the following environment variable:</p>
<pre><code><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">HOME</span>=%HOMEPATH%
</code></pre><p>It is a bug in JsHint that makes us do this. On Linux and the Mac you probably
won&#39;t need to set the environment variable.</p>
<p>And finally try running jshint against one of your files:</p>
<pre><code>jshint <span class="hljs-keyword">index</span>.js
</code></pre><ul>
<li><a href="http://nodejs.org/api/modules.html#modules_loading_from_the_global_folders">See also Node and env</a></li>
</ul>
<a class="anchor" id="karmaChrome"></a>
<h2>Karma and CHROME_BIN</h2>
<p>Here&#39;s a tip:</p>
<pre><code>echo <span class="hljs-string">'export CHROME_BIN="/usr/bin/chromium-browser"'</span> <span class="hljs-meta">&gt;&gt; </span>~<span class="hljs-regexp">/.bashrc &amp;&amp; source ~/</span>.bashrc
</code></pre><p>Just remember that you put the call in <strong>.bashrc</strong> in case there is some reason why you don&#39;t want that behavior later on. In other words, you have now set <strong>CHROME_BIN</strong> for all bash sessions you create until you remove that line. Frankly, that seems like a totally reasonable thing to do, but just remember that you did it, in case there is some reason you want different behavior later on. Also, we don&#39;t want to put too much in our <strong>.bashrc</strong> file or they will become too complex, and take too long to execute. This one line alone won&#39;t cause problems, of course.</p>
<p>I believe I had referenced this bash file:</p>
<p><a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Design/BridgeSailor/RunKarma.sh">https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Design/BridgeSailor/RunKarma.sh</a></p>
<p>It is a script, and needs to be run as such:</p>
<pre><code><span class="hljs-keyword">sh</span> RunKarma.<span class="hljs-keyword">sh</span>
</code></pre><p>or</p>
<pre><code>chmod +x RunKarma<span class="hljs-selector-class">.sh</span> <span class="hljs-comment">// Done once</span>
./RunKarma<span class="hljs-selector-class">.sh</span>        <span class="hljs-comment">// Any time you want to run the script once it has the executable flag set by the chmod call.</span>
</code></pre><p>Then when it runs, it starts a new shell, then sets the environment variable \$CHROME_BIN in the new shell to <strong>/usr/bin/chromium-browser</strong>, and then executes the line <strong>karma start</strong>. The point, I assume, is that Karma needs to know where chromium is located, and it checks the \$CHROME_BIN environment variable as at least one way of finding it.</p>
<p>If you put the line: <strong>export CHROME_BIN=/usr/bin/chromium-browser</strong> at the end of your .bashrc file, then each time you start a new bash shell, that environment variable will be set.</p>
<p>The line <strong>source ~/.bashrc</strong> is a way to have the <strong>.bashrc</strong> file executed without having to start a new shell. It executes the line inside the present shell, and it can change the current shell, and particularly the environment variables for the current shell.</p>
<p><a href="http://superuser.com/questions/46139/what-does-source-do">http://superuser.com/questions/46139/what-does-source-do</a></p>
<p>The point here is this. If you run <strong>source .bashrc</strong>, or if you start a new shell the normal way, then the current shell, the one you are in, is affected. It is a way of making sure that your current shell, the one at whose command line you are currently working, has executed all the commands in <strong>.bashrc</strong>. But if you run a script with the dot (.) command, then a new shell is launched, the script is run, and when it is finished you are returned to the original shell and changes the script made to the environment are forgotten. Consider running our command:</p>
<pre><code><span class="hljs-string">./RunKarma.sh</span>
</code></pre><p>It creates a new shell, sets the environment variable CHROME_BIN for that shell to <strong>/usr/bin/chromium-browser</strong>. The script then starts Karma. When you hit Control-C to end the run, then you are returned to original shell, and the CHROME_BIN environment variable is returned to the state it was in before you ran the command.  Since it is unlikely that anything else but Karma cares about that environment variable, then that is a reasonable solution. You could probably put ./RunKarma in your bin directory, so that you did not have to put it inside of each project.... (Yes, I tried that, and it seems to work).</p>
<p>Remember that you can check the current value of CHROME_BIN by typing:</p>
<pre><code><span class="hljs-built_in">echo</span> \<span class="hljs-variable">$CHROME_BIN</span>
</code></pre><p>On Windows it would be:</p>
<pre><code><span class="hljs-built_in">echo</span> <span class="hljs-variable">%CHROME_BIN%</span>
</code></pre><a class="anchor" id="symbolic-link"></a>
<h2>Symbolic Links to node_modules</h2>
<p>There is a way to save space on your hard drive if you have a large number of very similar <strong>node_modules</strong> and bower <strong>components</strong> folders on your system. It involves creating one copy of these folders, and then linking to them from your projects.</p>
<p>Go into one of the projects that uses most of the packages that we have been using in this course. For instance, go into any of the projects from Week07. Run <strong>npm install</strong> and <strong>bower install</strong>.</p>
<p>If you do not have a <strong>temp</strong> directory in your home drive, create one:</p>
<pre><code><span class="hljs-built_in">mkdir</span> ~/temp
</code></pre><p>Now copy or move your folders into this temp directory. Here is the copy command:</p>
<pre><code class="lang-bash">cp -r node_modules ~<span class="hljs-regexp">/temp/</span>.
cp -r <span class="hljs-keyword">public</span><span class="hljs-regexp">/components ~/</span>temp<span class="hljs-regexp">/.</span>
</code></pre>
<p>Or you can just move them there, which will free up space in your current project folder:</p>
<pre><code class="lang-bash">mv node_modules ~<span class="hljs-regexp">/temp/</span>.
mv <span class="hljs-keyword">public</span><span class="hljs-regexp">/components ~/</span>temp<span class="hljs-regexp">/.</span>
</code></pre>
<p>Now go into another project. If there already are any existing packages, remove them to free up space:</p>
<pre><code class="lang-bash"><span class="hljs-keyword">rm</span> -r node_modules
<span class="hljs-keyword">rm</span> -r public/components
</code></pre>
<p>Now create symbolic links to the directories in your <strong>temp</strong> folder:</p>
<pre><code class="lang-bash">ln -s ~<span class="hljs-regexp">/temp/</span>node_modules .
ln -s ~<span class="hljs-regexp">/temp/</span>components <span class="hljs-keyword">public</span><span class="hljs-regexp">/.</span>
</code></pre>
<p>As far as your project is concerned, the <strong>node_modules</strong> and <strong>components</strong> folders are now part of your project. They are actually in the temp directory, but the symbolic link makes them appear to be at two places at once:</p>
<ul>
<li>In your current project</li>
<li>In the temp directory</li>
</ul>
<p>I do this a lot, and it works very well. Once you start to understand what symbolic links are, you will find many uses for them. For instance, in your <strong>~/bin</strong> directory you can create symbolic links to scripts in <strong>JsObjects</strong>. Then, when you do <strong>git pull</strong> to get the latest versions of my scripts, they will automagically appear in your <strong>~/bin</strong> directory. This is because they only appear to be in your <strong>~/bin</strong> directory, they are really in <strong>JsObjects</strong>. There is a tiny symbolic link in the <strong>~/bin</strong> directory that points to the real copy of the file. Symbolic links don&#39;t make copies of your files, they just point at the other location. Thus you can have many symbolic links to your <strong>~/temp/node_modules</strong> folder while actually taking up only a small amount space on your drive.</p>
<p>Finally, you might want to make the code that creates the symbolic link a script, and put it in your <strong>~/bin/directory</strong>:</p>
<pre><code class="lang-bash"><span class="hljs-meta">#! /bin/bash
</span>
ln -s ~/temp/node_modules .
ln -s ~/temp/components public/.
</code></pre>
<p>Save it as <strong>~/bin/nm-links</strong>. Make it executable</p>
<pre><code>chmod +<span class="hljs-keyword">x</span> ~/bin/<span class="hljs-keyword">nm</span>-links.<span class="hljs-keyword">sh</span>
</code></pre><p>Now, you can create links to these folders at any time but running the <strong>nm-links</strong> script from the root of your project. (If the folders already exist, then the script will fail.)</p>
<a class="anchor" id="debug"></a>
<h2>Debug</h2>
<p>When running your code, make sure the debug window is open. Consider the image shown below.</p>
<p><img src="https://s3.amazonaws.com/bucket01.elvenware.com/images/debug-bitly-refine-01.png" alt="Debug Twitter"></p>
<p>Notice the following:</p>
<ul>
<li>We are running Chrome/Chromium, not FireFox</li>
<li>The Chrome Developer Tools are open (F12)</li>
<li>We are turned to the <strong>Sources</strong> page</li>
<li>The red circle with the white X at the top right of the Chrome Developer Tools means there is an error</li>
<li>The blue <strong>&gt;_</strong> symbol to the right of the red circle is toggled on (it is blue). When toggled on, this option displays the <strong>console</strong> at the bottom of the dev tools.</li>
<li>The console shows our error, which states that &quot;url&quot; is part of an object that is not defined. We can see that the error is on line 33 of <strong>control.js</strong></li>
<li>The code in the display shows the actual line causing the problem. It is underlined with a red squiggly. Looking at the left of the display we can confirm that it is on line 33.</li>
</ul>
<p>Turning to our editor, and moving to line 33, we can see the complete line of code causing the error:</p>
<pre><code class="lang-javascript">appendUrl(<span class="hljs-string">'#tweetList'</span>, index, tweet.<span class="hljs-built_in">text</span>, tweet.<span class="hljs-built_in">entities</span>.urls[<span class="hljs-number">0</span>].url);
</code></pre>
<p>From the error messages in the dev tools, we now know that <strong>urls[0]</strong> is undefined. This is almost certainly because this particular tweet has no <strong>urls</strong> associated with it. As you know from previous lessons, the fix for this problem is to write something like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (tweet<span class="hljs-selector-class">.entities</span><span class="hljs-selector-class">.urls</span><span class="hljs-selector-class">.length</span> &gt; <span class="hljs-number">0</span>) { ... }
</code></pre>
<p>But my point here is not to provide the fix. It is to emphasize how crucially important it is that you use the debugger. I have come around to help many of you during or after class. As you know, the first thing I do is almost always to turn the debugger on. Without it the task of finding an error becomes much more difficult. We <strong>can</strong> walk from here to Tacoma rather than driving, but it is more difficult. We <strong>can</strong> fix problems in our code without the dev tools, but it is indeed much more difficult.</p>
<a class="anchor" id="mern"></a>
<h2>MERN</h2>
<p>I&#39;m not partial to this particular acronym, but if there is one that captures what we do, it is called the MERN stack: MongoDB, Express, React and Node. Not to be confused with the MEAN stack.</p>
<ul>
<li><a href="http://mern.io/">MERN</a></li>
<li><a href="http://mean.io/">MEAN</a></li>
<li><a href="https://www.mongodb.com/blog/post/the-modern-application-stack-part-1-introducing-the-mean-stack">MEAN and MERN on MongoDB</a></li>
</ul>
<p>I never really set out to be a LAMP, MEAN or MERN developer. I just found the technologies I like the most that I think students need to learn to get jobs. Right now, I think that is Node with Express, React, and MongoDB. I could happily replace MongoDB with CouchDB, but Mongo is so useful in the job market.</p>
<p>Ten years ago it was possible to pick a &quot;best&quot; tool for certain tasks. Now, the best we can do is say that a particular tool is very popular, or very much in demand. Many products are both powerful and well crafted.</p>
<p>I pick the tools we use very carefully. I don&#39;t know how to say this properly, but have faith in me. I am showing you the right products.</p>
<a class="anchor" id="nodejs-on-azure"></a>
<h2>NodeJS on Azure</h2>
<ul>
<li><a href="https://www.windowsazure.com/en-us/develop/nodejs/">https://www.windowsazure.com/en-us/develop/nodejs/</a></li>
</ul>
<p>I&#39;m not quite sure what this command does:</p>
<pre><code>npm install azure <span class="hljs-keyword">node</span><span class="hljs-title">-uuid</span> DSInit /sqlInstance:.
</code></pre><a class="anchor" id="simpledb"></a>
<h2>SimpleDb</h2>
<p><a href="https://github.com/rjrodger/simpledb">https://github.com/rjrodger/simpledb</a></p>
<a class="anchor" id="cloud-9"></a>
<h2>Cloud 9</h2>
<p>Cloud 9 is an online IDE. You can find it here:</p>
<p><a href="https://c9.io/">https://c9.io</a></p>
<p>On your account page, you can link to your GitHub account.</p>
<p>Installing NPM modules:</p>
<p><a href="https://docs.c9.io/installing_npm_modules.html">https://docs.c9.io/installing_npm_modules.html</a></p>
<!--------------------------------------->
<!-- Links ------------------------------>
<!--------------------------------------->
</div></body></html>