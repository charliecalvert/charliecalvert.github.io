<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>NodeJs</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css"><link href="/libs/css/BootstrapIndex.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet" type="text/css"><script src="/components/jquery/"></script><script src="components/angular/angular.js"></script><script src="components/angular-route/angular-route.js"></script><script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script><script src="/libs/scripts/elvenware.js" type="text/javascript"></script><script src="/libs/scripts/Control.js"></script></head><body ng-app="elfApp"><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/about">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/development/index.html">Strongly Typed</a></li><li><a href="/development/web/index.html">Web & Scripts</a></li><li><a href="/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>NodeJs</h1><p>Welcomes to NodeJs</p><ul><!--TOC_Start--><li><a href="#node">Node</a></li>
<li><a href="#is-node-installed">Is Node Installed</a></li>
<li><a href="#npm-global-packages">NPM Global Packages</a></li>
<li><a href="#whatsGlobal">What&#39;s Globally Installed?</a></li>
<li><a href="#configGlobal">Configure Global Install</a></li>
<li><a href="#npm-local-libraries">NPM Local Libraries</a></li>
<li><a href="#not-important">Not important</a></li>
<li><a href="#packageJson">Using package.json</a></li>
<li><a href="#adding-entries-to-package-json">Adding entries to package.json</a></li>
<li><a href="#more-on-node-and-package-json">More on Node and Package.json</a></li>
<li><a href="#get-node-and-npm-on-your-path">Get Node and NPM on your Path</a></li>
<li><a href="#what-version-of-a-node-package-is-installed-">What Version of a Node Package is Installed?</a></li>
<li><a href="#npm-latest-packages">NPM Latest Packages</a></li>
<li><a href="#update-npm-in-ubuntu">Update NPM in Ubuntu</a></li>
<li><a href="#error-cannot-find-module">Error: Cannot find module</a></li>
<li><a href="#error-couldn-t-read-dependencies">Error: Couldn&#39;t Read Dependencies</a></li>
<li><a href="#EADDRINUSE">Error: Address in Use EADDRINUSE</a></li>
<li><a href="#nodePath">NODE_PATH and Cannot Find Modules</a></li>
<li><a href="#hello-world">Hello World</a></li>
<li><a href="#port">Setting up the Port</a></li>
<li><a href="#using-express">Using Express</a></li>
<li><a href="#working-with-post">Working with Post</a></li>
<li><a href="#using-a-directory-with-app-use">Using a Directory with app.use</a></li>
<li><a href="#express-generated-applications">Express Generated Applications</a></li>
<li><a href="#jade">Jade</a></li>
<li><a href="#jade-indent">Jade Indent</a></li>
<li><a href="#stylus">Stylus</a></li>
<li><a href="#jasmineNode">Test with Jasmine-Node</a></li>
<li><a href="#require">Require</a></li>
<li><a href="#nodemon-watches-for-changes">Nodemon Watches for Changes</a></li>
<li><a href="#debug-node-in-eclipse">Debug Node in Eclipse</a></li>
<li><a href="#upstart">UpStart</a></li>
<li><a href="#more-on-upstart">More on Upstart</a></li>
<li><a href="#eaddrinuse-and-upstart">EADDRINUSE and UpStart</a></li>
<li><a href="#creating-directories-and-copying-files">Creating Directories and Copying Files</a></li>
<li><a href="#folder-manipulation">Folder Manipulation</a></li>
<li><a href="#node-and-environment-variables">Node and Environment Variables</a></li>
<li><a href="#jshint">JSHint and Node</a></li>
<li><a href="#maintain-repository">Maintain Repository</a></li>
<li><a href="#find-big-files-that-you-don-t-need">Find big files that you don&#39;t Need</a></li>
<li><a href="#karmaChrome">Karma and CHROME_BIN</a></li>
<li><a href="#cloud-9">Cloud 9</a></li><!--TOC_End--></ul><h1 id="node">Node</h1>
<p>Node is a JavaScript platform and compiler and a set of accompanying libraries.
You can create general purpose JavaScript programs with Node, but it is 
especially designed to help you build networked applications that link a 
distributed architecture.</p>
<p>For Windows, the node install is found here: </p>
<pre><code>&lt;http://nodejs.org/&gt;
</code></pre><p>If you want to install the latest version of node and npm on Linux, do this:</p>
<pre><code>    sudo apt-get install curl
    curl -sL https://deb.nodesource.com/setup | sudo bash -
    sudo apt-get install -y nodejs
</code></pre><p>It is <strong>not recommended</strong> to use the following, because it installs a very old version of nodejs. Maybe someday it will start working again:</p>
<pre><code>sudo apt-get install nodejs npm
</code></pre><p>On Linux, you can use the <strong>which</strong> command to find the location of a program. For instance:</p>
<pre><code>$ which nodejs
/usr/bin/nodejs
</code></pre><p>If that does not work, then NodeJs is probably not properly installed.</p>
<p>Reference from the Node GitHub site and other key links:</p>
<ul>
<li><a href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager">https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager</a></li>
<li><a href="http://howtonode.org/">http://howtonode.org/</a></li>
</ul>
<h2 id="is-node-installed">Is Node Installed</h2>
<p>Node does not come installed on most systems, but it is easy to check if it is
already on your system. Here is one simple test to see if it
is installed:</p>
<pre><code>node --help
</code></pre><p>Alternatively, you can try:</p>
<pre><code>nodejs --help
</code></pre><p>If you don&#39;t get an error message, then it is installed. In particular, you 
should see output showing available commands.</p>
<p>It is always possible that Node is installed on your system but is not on your
path. On Windows you can generally look for Node in the start menu. There should
be a link to start a Node Command prompt, or to run Node interactively. </p>
<p>On Linux, Node is usually installed here:</p>
<pre><code>/usr/bin/node
/usr/bin/nodejs
</code></pre><p>If Node is not installed, then go here and install install it:</p>
<ul>
<li><a href="http://nodejs.org/">http://nodejs.org/</a></li>
</ul>
<h2 id="npm-global-packages">NPM Global Packages</h2>
<p>NPM is the <a href="https://www.npmjs.com/">Node Package Manager</a>. Many of the libraries that you will want to use with Node are best installed using NPM. Node and NPM are closely linked: I can&#39;t imagine using Node without 
NPM and vice versa. The default Node install includes NPM.</p>
<p>Most NPM packages are installed only for a particular project. They have local scope and are not found on your PATH. However, there are a few libraries that I like to install globally so that they are always on my path. These include:</p>
<ul>
<li>karma-cli</li>
<li>grunt-cli</li>
<li>jasmine-node</li>
<li>express-generator</li>
<li>nodemon</li>
<li>mocha</li>
</ul>
<p>On <strong>Windows</strong>, install them like this:</p>
<pre><code>npm install -g karma-cli
npm install -g grunt-cli
npm install -g jasmine-node
npm install -g express-generator
npm install -g nodemon
npm install -g mocha
</code></pre><p>On <strong>Windows</strong>, this typically installs express into your <strong>AppData/Roaming</strong> directory. </p>
<p>To issue the same commands on <strong>Linux</strong>, you need to do some setup:</p>
<pre><code>mkdir ~/npm
npm config set prefix ~/npm
</code></pre><p>Then add this to the bottom of your .bashrc:</p>
<pre><code>export PATH=&quot;$PATH:$HOME/npm/bin&quot;
</code></pre><h3 id="whatsGlobal">What&#39;s Globally Installed?</h3>
<p>To see what is installed globally, issue the <strong>npm list</strong> command with <strong>-g</strong> and <strong>--depth=0</strong> as arguments:</p>
<pre><code>npm list -g --depth=0
/home/charliecalvert/npm/lib
├── bower@1.3.12
├── cordova@4.2.0
├── express-generator@4.11.2
├── generator-angular@0.11.0
├── generator-angularjs-cordova@1.0.0
├── generator-express@2.5.6
├── generator-jasmine@0.1.2
├── generator-karma@0.9.0
├── generator-mocha@0.1.6
├── grunt-cli@0.1.13
├── jasmine-node@1.14.5
├── jshint@2.6.0
├── karma-cli@0.0.4
├── mocha@2.1.0
├── node-inspector@0.8.3
├── nodemon@1.3.6
├── npm@2.4.1
├── npm-check-updates@1.5.1
└── yo@1.4.5
</code></pre><p>The <strong>-g</strong> bit ensures that we look only at globally installed packages. We use <strong>--depth=0</strong> to ensure we see only the packages we have explicitly installed, and not the packages that those packages rely upon.</p>
<h3 id="configGlobal">Configure Global Install</h3>
<p>To make sure npm is configured correctly, type the following:</p>
<pre><code>npm config list
</code></pre><p>One Windows, it might look something like this:</p>
<pre><code>&gt;npm config list
; cli configs
registry = &quot;https://registry.npmjs.org/&quot;
user-agent = &quot;npm/1.4.21 node/v0.10.30 win32 x64&quot;

; builtin config undefined
prefix = &quot;C:\\Users\\charlie\\AppData\\Roaming\\npm&quot;

; node bin location = C:\Program Files\nodejs\\node.exe
; cwd = C:\Src\Git\JsObjects\JavaScript
; HOME = C:\Users\charlie
; &#39;npm config ls -l&#39; to show all defaults.
</code></pre><p>On Linux, the same command yields these results on one of my VMs:</p>
<pre><code>$ npm config list
; cli configs
registry = &quot;https://registry.npmjs.org/&quot;
user-agent = &quot;npm/1.4.28 node/v0.10.35 linux x64&quot;

; userconfig /home/charlie/.npmrc
prefix = &quot;/home/charlie/npm&quot;

; node bin location = /usr/bin/node
; cwd = /home/charlie
; HOME = /home/charlie
; &#39;npm config ls -l&#39; to show all defaults.
</code></pre><p>After making changes to <strong>.bashrc</strong> you either restart your shell or type:  <strong>source ~/.bashrc</strong>. In either case, your <strong>.bashrc</strong> file will be processed and any changes you made should take effect.</p>
<p>Now you can issue the <strong>npm install</strong> commands shown above. The packages will be installed in your <strong>~/npm</strong> directory. </p>
<p><strong>NOTE</strong>: <em>On JsObjects there <a href="https://github.com/charliecalvert/JsObjects/blob/master/Utilities/NodeInstall/InstallNodePackages.sh">is a script</a> that will perform most of the actions described above, though it will not automatically update your <strong>.bashrc</strong> file.</em></p>
<p><strong>NOTE</strong>: <em>You might also want to look in this hidden directory for additional details about your NPM installation: <strong>~/.npm</strong>.</em>    </p>
<h2 id="npm-local-libraries">NPM Local Libraries</h2>
<p>You can use NPM to install local libraries that you will use in your node programs. These libraries are installed in the same directory as your project. In particular, they are placed in a folder called <strong>node_modules</strong>.</p>
<p>Many node program rely on a library called express. Express is not built into Node. Instead, it is a library that you must install. </p>
<p><strong>NOTE</strong>: <em>Express gets installed twice. Above you saw how to globally install the express-generator. Here you are learning how to install express itself, which is a local library.</em></p>
<p>To install <strong>express</strong>, we typically issue the following command from the root of our project:</p>
<pre><code>npm install express --save
</code></pre><p>This will install a local copy of express in a directory called <strong>node_modules</strong>.  The <strong>--save</strong> switch saves the command to install express into a file called <strong>package.json</strong>. Once express is saved into <strong>package.json</strong> you can reinstall it by simply typing <strong>npm install</strong>. You can <strong>--save</strong> multiple packages into <strong>package.json</strong>. Then you can reinstall them at any time by simply typing <strong>npm install</strong>. You would want to do this if you move the project to a new system, or if you deleted the <strong>node_modules</strong> directory. The <strong>package.json</strong> file also helps if you give your project to another developer. Then they can install all the needed libraries by just type <strong>npm install</strong>.</p>
<p><strong>NOTE</strong>: <em>It is generally not appropriate to include the <strong>node_modules</strong> directory when you give a project to another developer or when you check it into source control. The reason for this is simple: the <strong>node_modules</strong> directory can be huge if you include a lot of npm packages in your project. As a result, we <strong>--save</strong> the libraries into <strong>package.json</strong> and then let the user install them with <strong>npm install</strong>. This is why we put <strong>node_modules</strong> in our <strong>.gitignore</strong> files.</em></p>
<p>Any other libraries you install will also end up in this directory. For instance, if you want to installed the openid library, you would issue this command:</p>
<pre><code>npm install openid --save
</code></pre><p>Now the <strong>node_modules</strong> directory will contain libraries: express and openid.</p>
<h2 id="not-important">Not important</h2>
<p>To link express into your project, go to the root of your project and type the following:</p>
<pre><code>npm link express.
</code></pre><p>To update node, type the following </p>
<pre><code>sudo npm install npm -g
</code></pre><h2 id="packageJson">Using package.json</h2>
<p>All your projects should include a file called <strong>package.json</strong>. To create one from scratch, go to the root of your project and issue this command:</p>
<pre><code>npm init
</code></pre><p>You will be presented with a series of prompts to fill out. Just step through them one by one, leaving the ones that don&#39;t interest or confuse you blank. When you are done, there will be a file called <strong>package.json</strong> in your current directory.</p>
<p>To add packages to package.json, issue a command like this:</p>
<pre><code>npm install require --save
</code></pre><p>This installs the package called <strong>require</strong> into a folder called <strong>node_modules</strong>. It also saves a command to install the package into <strong>package.json</strong>. To reinstall <strong>require</strong> later, just type this command:</p>
<pre><code>npm install
</code></pre><p>This command processes <strong>package.json</strong> and automatically installs all the packages you <strong>saved</strong> into it. You can, of course, <strong>save</strong> information about many packages into a single <strong>package.json</strong> file.</p>
<p>You may have a project that depends on express. In such cases, the author of the project will probably create a file called <strong>package.json</strong> that will contain a reference to express. If this file exists, you can just type the following to install express and any other libraries that the project depends upon:</p>
<pre><code>npm install
</code></pre><p>Here is the contents of a simple package.json file that installs both express
and openid as well as a library called mdirp:</p>
<pre><code>    {
        &quot;name&quot;: &quot;OpenId04&quot;, 
        &quot;version&quot;: &quot;0.0.1&quot;,
        &quot;private&quot;: true,
        &quot;dependencies&quot;: {
            &quot;openid&quot;: &quot;latest&quot;,
            &quot;express&quot;: &quot;latest&quot;,
            &quot;mkdirp&quot;: &quot;latest&quot;
        }
    }
</code></pre><p>To put the thing you installed in package.json:</p>
<pre><code>npm install &quot;karma-script-launcher&quot; --save-dev
</code></pre><p>The key point to remember is that <strong>npm install</strong> processes the contents of the file called <strong>package.json</strong>. It installs all the libraries listed in that file in a local directory called <strong>node_modules</strong>. By locally, I mean that the directory is now included in your project.</p>
<p>If you follow the link to <a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Design/BridgeSailor/package.json">package.json</a> for <a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Design/BridgeSailor">BridgeSailor</a> you will see that karma is listed in that file:</p>
<pre><code>&quot;devDependencies&quot;: {
    &quot;requirejs&quot;: &quot;^2.1.11&quot;,
    &quot;karma&quot;: &quot;^0.12.14&quot;,
    &quot;karma-jasmine&quot;: &quot;^0.2.0&quot;,
    &quot;karma-requirejs&quot;: &quot;^0.2.1&quot;,
    &quot;karma-chrome-launcher&quot;: &quot;^0.1.3&quot;,
    &quot;karma-firefox-launcher&quot;: &quot;^0.1.3&quot;
}
</code></pre><p>This means that running <strong>npm install</strong> will install all the files listed above, including the <strong>karma</strong> library. </p>
<p>The point of <strong>npm install</strong> and <strong>package.json</strong> is that they work together to install a series of libraries, rather than asking you to type the following series of individual commands:</p>
<pre><code>npm install requirejs
npm install karma
npm install karma-jasmine
npm install karma-requirejs
npm install karma-chrome-launcher
npm install karma-firefox-launcher
</code></pre><p>Typing all of the above commands is time consuming, error prone and repetitious. Therefore we use <strong>package.json</strong>, which needs to be configured correctly once, and works automatically thereafter.</p>
<h2 id="adding-entries-to-package-json">Adding entries to package.json</h2>
<p>Usually all you need to do is process <strong>package.json</strong> by typing <strong>npm install</strong>. However, you may occassionally. want to add your own dependency to package.json. Here is how to put a library called <strong>karma-script-launcher</strong> in <strong>package.json</strong>:</p>
<pre><code>npm install &quot;karma-script-launcher&quot; --save-dev
</code></pre><p>The command shown above first installs <strong>karma-script-launcher</strong> into <strong>node_modules</strong>. It then adds an entry for it to <strong>package.json</strong>. Then next time you run <strong>npm install</strong> the <strong>karma-script-launcher</strong> package will be installed automatically because it is now included in <strong>package.json</strong>.</p>
<p>Consider this command:</p>
<pre><code>npm install karma --save-dev
</code></pre><p>This command installs the library, and saves the library name into <strong>package.json</strong> if it is not already there. </p>
<table>
<thead>
<tr>
<th style="text-align:left">Command</th>
<th style="text-align:left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>npm install</strong></td>
<td style="text-align:left">process package.json and install all packages it references into <strong>node_modules</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>npm install chai</strong></td>
<td style="text-align:left">install chai into node_modules </td>
</tr>
<tr>
<td style="text-align:left"><strong>npm install chai --save</strong></td>
<td style="text-align:left">install chai into <strong>node_modules</strong> and add <strong>chai</strong> to <strong>package.json</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>npm install chai --save-dev</strong></td>
<td style="text-align:left">install chai into <strong>node_modules</strong> and add <strong>chai</strong> to <strong>package.json</strong> in a section listing packages used during development.</td>
</tr>
</tbody>
</table>
<h2 id="more-on-node-and-package-json">More on Node and Package.json</h2>
<p>NPM related issues are specific to node, not to Linux. If you were using node on Windows or the Mac, <strong>npm</strong> behaves in a very similar fashion.</p>
<p><strong>npm</strong> is the Node Package Manager. It installs libraries that are used by Node projects. Some of the libraries, such as <strong>fs</strong> (the File System package) are built into node, but most are open source projects hosted on GitHub. </p>
<p>Here are a few node packages (libraries) that I often install globally:</p>
<pre><code>/usr/lib
├─┬ express-generator@4.0.0
├─┬ grunt-cli@0.1.13
├─┬ jasmine-node@1.14.3
├─┬ js-beautify@1.5.1
├─┬ jshint@2.5.0
├─┬ karma-cli@0.0.4
└─┬ npm@1.4.9
</code></pre><p>These are stored here on a typical Linux system:</p>
<pre><code>$ ls -l /usr/lib/node_modules/
total 28
drwxr-xr-x 5 nobody charlie 4096 Apr 21 12:24 express-generator
drwxr-xr-x 6 nobody charlie 4096 Apr 20 09:57 grunt-cli
drwxr-xr-x 9 nobody charlie 4096 Apr 21 16:02 jasmine-node
drwxr-xr-x 4 nobody charlie 4096 Apr 26 15:43 js-beautify
drwxr-xr-x 6 nobody charlie 4096 Apr 21 18:31 jshint
drwxr-xr-x 4 nobody charlie 4096 Apr 27 10:23 karma-cli
drwxr-xr-x 9 root root 4096 May 5 07:56 npm
</code></pre><p>We install these global packages by typing something like: </p>
<pre><code>sudo npm install -g karma-cli
</code></pre><p>Where <strong>karma-cli</strong> is the package we want to install.</p>
<p>Each project also has packages that it uses. Each individual project might rely on a particular version of a package. For instance, one express project might use express 3.5.1, while another might use express 4.0.0. As a result, we don&#39;t install these packages globally. Instead, we install them inside the project we are currently using. This way, a particular project can rely on a particular version of a package. Specifically, we install them in a folder called <strong>node_modules</strong>.</p>
<p>Here, for instance, are the packages installed for a project called Week02Jade:</p>
<pre><code>charlie@MountainStreamsLinux:~/Git/Prog282/Week02Jade
$ ls -l node_modules/
total 28
drwxrwxr-x 3 charlie charlie 4096 Apr 26 16:44 body-parser
drwxrwxr-x 5 charlie charlie 4096 Apr 26 16:44 cookie-parser
drwxrwxr-x 3 charlie charlie 4096 Apr 26 16:44 debug
drwxrwxr-x 5 charlie charlie 4096 Apr 26 16:44 express
drwxrwxr-x 5 charlie charlie 4096 Apr 26 16:44 jade
drwxrwxr-x 3 charlie charlie 4096 Apr 26 16:44 morgan
drwxrwxr-x 2 charlie charlie 4096 Apr 26 16:44 static-favicon
</code></pre><p>These packages get installed when we type <strong>npm install</strong>. This action causes <strong>npm</strong> to process the contents of <strong>package.json</strong>, and to install the packages listed there:</p>
<pre><code>    $ cat package.json 
    {
      &quot;name&quot;: &quot;application-name&quot;,
      &quot;version&quot;: &quot;0.0.1&quot;,
      &quot;private&quot;: true,
      &quot;scripts&quot;: {
        &quot;start&quot;: &quot;DEBUG=my.application node ./bin/www&quot;
      },
      &quot;dependencies&quot;: {
        &quot;express&quot;: &quot;~4.0.0&quot;,
        &quot;static-favicon&quot;: &quot;~1.0.0&quot;,
        &quot;morgan&quot;: &quot;~1.0.0&quot;,
        &quot;cookie-parser&quot;: &quot;~1.0.1&quot;,
        &quot;body-parser&quot;: &quot;~1.0.0&quot;,
        &quot;debug&quot;: &quot;~0.7.4&quot;,
        &quot;jade&quot;: &quot;~1.3.0&quot;
      }
    }
</code></pre><p>Do you see that the directory listing is the same as the packages listed in <strong>package.json</strong>? The bottom line is that we need to think in terms of both global and local versions of our <strong>npm</strong> packages. </p>
<p>You can find all the <strong>npm</strong> packages here:</p>
<ul>
<li><a href="https://www.npmjs.org/">https://www.npmjs.org/</a></li>
</ul>
<h2 id="get-node-and-npm-on-your-path">Get Node and NPM on your Path</h2>
<p>In many cases, and certainly in most classes I teach, your life will be 
simpler if both Node and NPM are always on your path. Your install of Node 
may set things up that way for you automatically. If not, make sure they are 
on your path:</p>
<p><a href="http://www.elvenware.com/charlie/os/windows/faq.html#environment">http://www.elvenware.com/charlie/os/windows/faq.html#environment</a></p>
<p>Typically, on Windows, this is the item I want to add to my path:</p>
<ul>
<li><C:\Users\Charlie\AppData\Roaming\npm>

</li>
</ul>
<p>Your milage may differ, particularly in regard to the user name, but
that should provide a start for you.</p>
<h2 id="what-version-of-a-node-package-is-installed-">What Version of a Node Package is Installed?</h2>
<p>Use the following syntax to identify the latest version of a package:</p>
<pre><code>npm show [PackageName] version
</code></pre><p>This is not showing the version you have installed, but the latest version that
is available on the net.</p>
<p>For instance:</p>
<pre><code>G:\Src\Git\MyStuff&gt;npm show voxel-engine version
npm http GET https://registry.npmjs.org/voxel-engine
npm http 200 https://registry.npmjs.org/voxel-engine
0.16.3
</code></pre><p>This means that the package voxel-engine is at version 0.16.3.</p>
<p>To find the owner of a package, enter the following:</p>
<pre><code>npm owner ls [package]
</code></pre><p>For instance:</p>
<pre><code>G:\Src\Git\voxel-hello-world&gt;npm owner ls voxel-hello-world
npm http GET https://registry.npmjs.org/voxel-hello-world
npm http 200 https://registry.npmjs.org/voxel-hello-world
maxogden &lt;EMAIL ENDS UP HERE&gt;
</code></pre><p>To update all the packages you have installed globally:</p>
<pre><code>npm update -g
</code></pre><p>To update a specific global package such as grunt:</p>
<pre><code>npm update -g grunt
</code></pre><p>To update a local package such as grunt:</p>
<pre><code>npm update grunt
</code></pre><p>Remember that your globally installed file are placed in your AppData |
Roaming | npm folder. The path on your system might look something
like this:</p>
<pre><code>C:\Users\Charlie\AppData\Roaming\npm\node_modules
</code></pre><h2 id="npm-latest-packages">NPM Latest Packages</h2>
<p>It is nice to know that your project is using the latest packages. You can do this by running the <strong>npm outdated</strong> command:</p>
<pre><code>npm outdated
</code></pre><p>If you first delete your <strong>node_modules</strong> folder, and then run it, you might see output like this:</p>
<pre><code>charlie@mongovbox:~/Git/writings/Tech/Games/ThreeFloor$ npm outdated
npm http GET https://registry.npmjs.org/morgan
npm http GET https://registry.npmjs.org/cookie-parser
npm http GET https://registry.npmjs.org/body-parser
npm http GET https://registry.npmjs.org/debug
npm http GET https://registry.npmjs.org/serve-favicon
npm http GET https://registry.npmjs.org/express
npm http GET https://registry.npmjs.org/jade
npm http 304 https://registry.npmjs.org/morgan
npm http 304 https://registry.npmjs.org/body-parser
npm http 304 https://registry.npmjs.org/serve-favicon
npm http 304 https://registry.npmjs.org/express
npm http 304 https://registry.npmjs.org/debug
npm http 304 https://registry.npmjs.org/jade
npm http 304 https://registry.npmjs.org/cookie-parser
Package        Current  Wanted  Latest  Location
morgan         MISSING   1.3.2   1.4.1  morgan
body-parser    MISSING   1.8.4   1.9.2  body-parser
serve-favicon  MISSING   2.1.6   2.1.6  serve-favicon
express        MISSING   4.9.8  4.10.1  express
debug          MISSING   2.0.0   2.1.0  debug
jade           MISSING   1.6.0   1.7.0  jade
cookie-parser  MISSING   1.3.3   1.3.3  cookie-parser
</code></pre><p>Here you can see that our <strong>package.json</strong> file requests <strong>morgan</strong> 1.3.2. We can see that by opening up <strong>package.json</strong> and looking:</p>
<pre><code>{
  &quot;name&quot;: &quot;Test05&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;nodemon ./bin/www&quot;
  },
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;~4.9.0&quot;,
    &quot;body-parser&quot;: &quot;~1.8.1&quot;,
    &quot;cookie-parser&quot;: &quot;~1.3.3&quot;,
    &quot;morgan&quot;: &quot;~1.3.0&quot;,
    &quot;serve-favicon&quot;: &quot;~2.1.3&quot;,
    &quot;debug&quot;: &quot;~2.0.0&quot;,
    &quot;jade&quot;: &quot;~1.6.0&quot;
  }
}
</code></pre><p>As you can see, we are explicitly asking for 1.3.0. But <strong>npm outdated</strong> tells us that there is a newer version. So we just update <strong>package.json</strong> so that it asks for the latest, which is 1.4.1:</p>
<pre><code>&quot;morgan&quot;: &quot;~1.4.1&quot;,
</code></pre><p>We can do the same for all the packages we are using. Then run <strong>npm update</strong> after you have updated your <strong>package.json</strong> file. That will ensure that the installed versions of the files in <strong>node_modules</strong> are up to date. If the call to <strong>npm update</strong> fails, you can always just delete the files in your <strong>node_modules</strong> directory and run <strong>npm install</strong>.</p>
<p>You get the same output if you run <strong>npm outdated</strong> if you have a <strong>node_modules</strong> directory, but you may see reports on the nested packages in the <strong>node_modules</strong>. That information may not be useful. As a result, it might be best to start by deleting the folder:</p>
<pre><code>rm -r node_modules
</code></pre><h2 id="update-npm-in-ubuntu">Update NPM in Ubuntu</h2>
<p>You may have trouble with npm, and find that you have an older versions installed. For instance, version 1.4.28. We should be able to update it fairly. Here is the standard technique, but don&#39;t do this quite yet:</p>
<pre><code>sudo npm update -g npm
</code></pre><p>But that may not work in our case. The issue, I believe, is that many of us have set npm to perform updates locally to our npm folder, so that we don&#39;t have to worry sudo permissions. We set that up by typing the following command:</p>
<pre><code>npm config set prefix ~/npm
</code></pre><p>This sets where we install global files as explained here: <a href="https://docs.npmjs.com/misc/config#prefix">https://docs.npmjs.com/misc/config#prefix</a>.</p>
<p>We want to do this. It is a best practice. However, when we type <strong>npm update -g npm</strong> it updates our <strong>~/npm</strong> version of <strong>npm</strong> and not the one in <strong>/usr/bin</strong>. Of course, the one in <strong>/usr/bin/</strong> is the one that is on our path. So now we have outdated version of NPM that we can reach and an updated version that we can&#39;t access. I suppose we have two solutions. The first looks like this, where we begin by updating the local copy of NPM:</p>
<pre><code>npm update -g npm
sudo rm /usr/bin/npm
sudo ln -s ~/npm/bin/npm /usr/bin/npm
</code></pre><p>That should create a <a href="http://www.computerhope.com/unix/uln.htm">symbolic link</a> to the copy of NPM in our <strong>/usr/bin</strong> folder to the one in our <strong>~/npm/bin/npm</strong>. Then we should be on the latest. At the time of this writing, that looks like.</p>
<pre><code>$ npm --version
2.4.1
</code></pre><p>Alternatively, I think we could temporarily set the <strong>prefix</strong> to <strong>/usr/bin:</strong></p>
<pre><code>npm config set prefix /usr/bin
sudo npm update -g npm
</code></pre><p>Then check your work:</p>
<pre><code>$ npm --version
2.4.1
</code></pre><p>Then set the prefix back to ~/npm</p>
<pre><code>npm config set prefix ~/npm
</code></pre><h2 id="error-cannot-find-module">Error: Cannot find module</h2>
<p>One of the classic Node errors looks like this:</p>
<pre><code>node Server.js

module.js:340
    throw err;
          ^
Error: Cannot find module XXX
</code></pre><p>In this case, XXX is usually the name of a library, such as Express, Morgan, Walk, etc. This error usually occurs because you have not typed the following command:</p>
<pre><code>npm install
</code></pre><p>This command processes the list of libraries found in the file <strong>package.json.</strong> The <strong>package.json</strong> file is usually part of any node program. There are few cases when you will not need <strong>package.json</strong> and in such cases its absence is not significant. In those cases, you need only type something like <strong>node Server.js</strong> to start the program. If, however, you get a <strong>cannot find module</strong> error, and <strong>package.json</strong> is not present, then you either do not have a complete copy of the program, or the program itself is not complete.</p>
<h3 id="error-couldn-t-read-dependencies">Error: Couldn&#39;t Read Dependencies</h3>
<p>Sometimes you may also see this error:</p>
<pre><code>npm install
npm ERR! install Couldn&#39;t read dependencies
npm ERR! package.json ENOENT, open &#39;/home/charlie/package.json&#39;
etc...
</code></pre><p>This errror occurs, needless to say, because a copy of <strong>package.json</strong> is not found. As mentioned above, there are cases when a node program does not rely on any libraries, and hence <strong>package.json</strong> does not exist. But the error above usually occurs because you are not in the proper directory. For instance, you are in your home directory, and the program you want to run is in <strong>~/Git/JsObjects/JavaScript/Design/SimpleQueue</strong>.</p>
<p>To return to our main point: the primary problem that developers encounter when the see this error is simply forgetting to type <strong>npm install</strong>.</p>
<h3 id="EADDRINUSE">Error: Address in Use EADDRINUSE</h3>
<p>The EADDRINUSE (Error Address In Use) message usually means that the 
port is in use by another program. For instance, you left an 
instance of a program running on the port where you want to launch your
node server. Usually, fixing this is just a matter of finding the 
SSH or Windows command prompt where the server is running, and pressing
Ctrl-C to stop the server:</p>
<pre><code>C:\Git\P282\CanvasGrid&gt;node server.js
  Listening on port :30026
^C   &lt;== Here I press Ctrl-C
C:\Git\P282\CanvasGrid&gt;
</code></pre><p>An important variation on this error can occur if you are running upstart. Details about that variant of the <a href="#eaddrinuse-and-upstart">EEADDRINUSE error are discussed below</a>. </p>
<h3 id="nodePath">NODE_PATH and Cannot Find Modules</h3>
<p>A related issue occurs when you cannot find modules that you installed globally with
NPM. Usually there is no need to install modules globally. However, in some cases it can be useful. Suppose you globally install walk:</p>
<pre><code>&gt;npm install -g walk
npm http GET https://registry.npmjs.org/walk
etc...
</code></pre><p>At this point, you would normally be all set to use <strong>walk</strong> in your
program. But sometimes you get an error like the following, even after
your install walk globablly:</p>
<pre><code>&gt;node Server.js

module.js:340
    throw err;
          ^
Error: Cannot find module &#39;walk&#39;
    at Function.Module._resolveFilename (module.js:338:15)
    at Function.Module._load (module.js:280:25)
    at Module.require (module.js:364:17)
    at require (module.js:380:17)
</code></pre><p>The problem could be that you don&#39;t have the environment variable
called NODE_PATH set up correctly. To fix the problem, simply add
the correct path to your global node_modules directory to your
path:</p>
<pre><code>set NODE_PATH=C:\\Users\\Charlie\\AppData\\Roaming\\npm\\node_modules
</code></pre><p>Or, if you want, use the environment dialog as explained above.</p>
<ul>
<li><a href="http://nodejs.org/api/modules.html#modules_loading_from_the_global_folders">See also Node and env</a></li>
</ul>
<h2 id="hello-world">Hello World</h2>
<p>Below you will find some sample node programs. Here are the steps
for using them.</p>
<ul>
<li>Create a directory to host your project. (mkdir MyFirstNodeServer) 
You might for instance, create the directory in a Git repository. </li>
<li>Navigate into that directory (cd MyFirstNodeServer)</li>
<li>Create a file called server.js and use a text editor to place
one of the sample programs shown below inside your file.</li>
<li>Then run your program by typing <strong>node server.js</strong>.</li>
</ul>
<p>For instance, you might type something like this:</p>
<pre><code>C:\Git\Prog282-Calvert&gt;mkdir MyFirstNodeServer
C:\Git\Prog282-Calvert&gt;cd MyFirstNodeServer
</code></pre><p>Now create server.js as described below. Then run the server:</p>
<pre><code>C:\Git\Prog282-Calvert\MyFirstNodeServer&gt;node server.js
</code></pre><p>Once the server starts, go to your browser, and type the following:</p>
<pre><code>http://localhost:30025
</code></pre><p>Here is the first, hello world style, node program that you can
place in the server.js file:</p>
<pre><code>var http = require(&#39;http&#39;);

http.createServer(function (request, response) {
  response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  response.end(&#39;It works!\n&#39;);
}).listen(30025);

console.log(&#39;Server running at http://127.0.0.1:30025/&#39;);
</code></pre><p>Here is another hello world type of program. Again, place it in
a file called server.js. You might for instance, create a directory
called MySecondNodeServer, and put this second server.js file 
in that directory:</p>
<pre><code>var http = require(&#39;http&#39;);

http.createServer(function (request, response) {
  response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;});
  response.end(&#39;&lt;p&gt;It works&lt;/p&gt;&#39;);
}).listen(30025);

console.log(&#39;Server running at http://127.0.0.1:30025/&#39;);
</code></pre><p>And here is one more:</p>
<pre><code>var http = require(&#39;http&#39;);
var fs = require(&#39;fs&#39;);

http.createServer(function (request, response) {
    var html = fs.readFileSync(&#39;index.html&#39;);
    response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;});
    response.write(html);
    response.end();
}).listen(30025);

console.log(&#39;Server running at http://127.0.0.1:30025/&#39;);
</code></pre><p>Notice that this last program depends on the presence of a file called
index.html, where index.html can be any valid HTML file.</p>
<h2 id="port">Setting up the Port</h2>
<p>Here is how to get the server to specify the port:</p>
<p>var port = process.env.PORT || 30025;</p>
<p>By default, we use port 30025 in my Bellevue College classes.</p>
<h2 id="using-express">Using Express</h2>
<p>You can find the HelloExpress program on JsObjects:</p>
<p><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/NodeCode/HelloExpress">https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/NodeCode/HelloExpress</a></p>
<p>To get started, create a directory called HelloExpress and then switch into
that directory:</p>
<pre><code>mkdir HelloExpress
cd HelloExpress
</code></pre><p>The next step will be to install the express library on which this project 
relies. You can do this one of two ways. Both involve issuing commands at 
the shell (command) prompt. You should issue the command in the same 
directory where you place your project. The simplest command looks like this:</p>
<pre><code>npm install express
</code></pre><p>When you are done, you should have a folder called <strong>node_modules</strong> with the 
contents of the express library in it. You can also choose to download a 
global copy of express that you can use in multiple projects:</p>
<pre><code>npm install -g express
npm link express
</code></pre><p>After issuing these last two commands, you are set to use Express with your 
current project. If you create another project that uses express, you can give
it access to the Express library by again issuing this command:</p>
<pre><code>npm link express
</code></pre><p>This will link in express using the global copy downloaded earlier. This 
technique saves disk space, as it means you need only one copy of Express on 
your system. </p>
<p>Here is the server for the <strong>HelloExpress</strong> program:</p>
<pre><code>var express = require(&#39;express&#39;);
var app = express();
var fs = require(&#39;fs&#39;);

var port = process.env.PORT || 30025;

app.get(&#39;/&#39;, function(req, res) {
    var html = fs.readFileSync(__dirname + &#39;/Public/index.html&#39;);
    res.writeHeader(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});   
    res.write(html);
    res.end();
});

app.use(&quot;/&quot;, express.static(__dirname + &#39;/Public&#39;));
app.listen(port);
console.log(&#39;Listening on port :&#39; + port);
</code></pre><p>This code has a method called app.get. It defines a default route that will
be called when the user browses to Port 30025:</p>
<pre><code>http://localhost:30025
</code></pre><p>The <strong>app.get</strong> method shown here reads in a file called index.html, then 
publishes it on the Node web server. When reading in the file, it uses a 
library called fs (FileSystem) and a method called readFileSync.</p>
<p>To make this program work, create a directory called Public. In it, put a 
very simple HTML file such as this one:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot;&gt;
  &lt;title&gt;Express Hello&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Hello Experss&lt;/h1&gt;
&lt;p&gt;A simple Node Express program&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>The file shown above is the one that will be read in by the node 
readFileSync method, and then served up by the node web server.</p>
<p>Now start the node webserver by running this command:</p>
<pre><code>node server.js
</code></pre><p>Here is another NODE example that uses express:</p>
<pre><code>    var express = require(&#39;express&#39;);
    var app = express();
    var fs = require(&#39;fs&#39;);

    var port = process.env.PORT || 30025;

    app.get(&#39;/&#39;, function(req, res) {
        console.log(&quot;root request sent&quot;);
        var html = fs.readFileSync(__dirname + &#39;/public/index.html&#39;);
        res.writeHeader(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});   
        res.write(html);
        res.end();
    });

    app.get(&#39;/dirname&#39;, function(req, result) {
        result.send({&#39;result&#39;: __dirname});
    });

    app.get(&#39;/port&#39;, function(request, result) {
        result.send({&#39;result&#39;: port});
    });

    app.use(express.static(__dirname + &#39;/public&#39;));

    app.listen(port);
    console.log(&#39;Express server started on port %s&#39;, port);
</code></pre><p>The first three lines are like import or include statements in other languages
such as Java, C# or C++:</p>
<pre><code>var express = require(&#39;express&#39;);
var app = express();
var fs = require(&#39;fs&#39;);
</code></pre><p>The first line asks that we load in a library called Express. The second line
creates an instance of the express object. The third line brings a library called
fs (filesystem) that is built into node.</p>
<p>The next line establishs the port that your project will run on:</p>
<pre><code>var port = process.env.PORT || 30025;
</code></pre><p>The words process.env.PORT refers to the environment variable called PORT. On
many machines this will not be set, so our code specifies the value for PORT if
PORT is not assigned. If you need help with environment variables, see this 
page:</p>
<ul>
<li><a href="http://www.elvenware.com/charlie/os/windows/faq.html#environment">http://www.elvenware.com/charlie/os/windows/faq.html#environment</a></li>
</ul>
<p>The next lines of code defines the action that our program will take if the
user goes to the root of our site. For instance, if we are running on localhost,
then the following method is called when the user goes to <a href="http://localhost:30025">http://localhost:30025</a>:</p>
<pre><code>    app.get(&#39;/&#39;, function(req, res) {
        console.log(&quot;root request sent&quot;);
        var html = fs.readFileSync(&#39;public/index.html&#39;);
        res.writeHeader(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});   
        res.write(html);
        res.end();
    });
</code></pre><p>This code logs a debug message to the console. Then it reads in an HTML file 
from the file system and packages it up using the HTTP protocol. It then 
sends it to the user. In a typical scenario, the user invoked this method by 
typing a URL in the address bar of a browser. Therefore the HTTP 
packet is delivered to a browser and rendered there so the user can read it.</p>
<p>The following two lines of code mirror back the current directory and PORT on 
which the node server is running:</p>
<pre><code>    app.get(&#39;/dirname&#39;, function(req, result) {
        result.send({&#39;result&#39;: __dirname});
    });

    app.get(&#39;/port&#39;, function(request, result) {
        result.send({&#39;result&#39;: port});
    });
</code></pre><p>These commands are invoked when the user types one of the following URLS</p>
<pre><code>http://localhost:30025/dirname
http://localhost:30025/port
</code></pre><p>The express library matches up the route designated by the URLs to the app.get
or app.post method that corresponds to it. For instance, the following URL 
designates a <em>route</em> called <strong>dirname</strong>:</p>
<pre><code>http://localhost:30025/dirname
</code></pre><p>This method is called when Express detects that the user designated the dirname
route:</p>
<pre><code>app.get(&#39;/dirname&#39;, function(req, result) { etc...
</code></pre><p>Express knows how to handle by HTTP get verbs and HTTP post verbs:</p>
<pre><code>app.post(&#39;/dirname&#39;, function(req, result) { etc...
</code></pre><p>More on this later.</p>
<p>For now, you can Read more here:</p>
<ul>
<li><a href="http://expressjs.com/api.html#app.VERB">http://expressjs.com/api.html#app.VERB</a></li>
</ul>
<h2 id="working-with-post">Working with Post</h2>
<p>We used to use a tool called bodyParser() when working with post. But
now we should use connect:</p>
<pre><code>npm install connect --save
</code></pre><p>And in your code:</p>
<pre><code>var connect = require( &quot;connect&quot; );

app.use(connect.urlencoded());
app.use(connect.json());
</code></pre><p>And then use it:</p>
<pre><code>app.post(&#39;/add&#39;, function(request, response) {
    console.log(&#39;add called&#39;);    
    console.log(request.body);    
    var operandA = parseInt(request.body.operandA);
    var operandB = parseInt(request.body.operandB);
    var result = addingMachine.myObject.add(operandA, operandB);
    response.send({ &quot;result&quot;: result });
});
</code></pre><p>Example code is found here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/NodeCode/NodeRoutes01/server.js">NodeRoutes01</a></li>
<li><a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/NodeCode/NodeRoutes02/server.js">NodeRoutes02</a></li>
</ul>
<h2 id="using-a-directory-with-app-use">Using a Directory with app.use</h2>
<p>There is one more very important line is the code sample shown in the previous
section:</p>
<pre><code>app.use(express.static(__dirname + &#39;/public&#39;));
</code></pre><p>As you recall, our default route for this node script loads a file called 
index.html that is stored in a folder called public:</p>
<pre><code>    var html = fs.readFileSync(__dirname + &#39;/public/index.html&#39;);
</code></pre><p>The app.use command shown above ensures that Express knows to look in the
public directory for your files. If you don&#39;t employ app.use to make directories
known to express, then your program may not be able to locate your files.</p>
<p>Inside of index.html, you may want to reference JavaScript and CSS files. If 
you place them in the public directory, then you should reference them like 
this:</p>
<pre><code>&lt;script src=&quot;/public/jquery.js&quot;&gt;&lt;/script&gt;
</code></pre><p>Finally, let&#39;s think for a moment about how to load index.html in our default
handler. In many cases the following code will work, using a relative path
to find the public directory:</p>
<pre><code>var html = fs.readFileSync(&#39;public/index.html&#39;);
</code></pre><p>However, the following code is preferred:</p>
<pre><code>var html = fs.readFileSync(__dirname + &#39;/public/index.html&#39;);    
</code></pre><p>This code references the path to the directory where your node program
was launched, and then adds public/index.html to it. For instance, if your
server.js file were in a directory called C:\src\ then the following path
would be used by readFileSync:</p>
<pre><code>C:\src\public\index.html
</code></pre><p>If your program were in subdirectory of your home directory on Linux, then the
path used by readFileSync might look like this:</p>
<pre><code>/home/sally/src/public/index.html
</code></pre><h2 id="express-generated-applications">Express Generated Applications</h2>
<p>Once you have some of the core concepts behind Express under your belt,
it is time to move on to full Express application. To get started, be
sure you have both Express and a template library called Jade installed:</p>
<pre><code>npm install -g express
npm install -g jade
</code></pre><p>Make sure the express application is on your path. It is usually found
in AppData/Roaming. For instance, the Express executable is found here
on my system:</p>
<pre><code>    C:\Users\Charlie\AppData\Roaming\npm\node\_modules.bin
</code></pre><p>On some systems it is here:</p>
<pre><code>C:\Users\Charlie\AppData\Roaming\npm\
</code></pre><p>In either case, you are looking for a program called express and 
express.cmd. Make sure they are on your path.</p>
<p>It may also be available here in your generated applications:</p>
<pre><code>    node_modules.bin
</code></pre><p>Now let Express generate the framework for your application. For instance,
the following command generates an application called MyApp01:</p>
<pre><code>express MyApp01
</code></pre><p>This command creates a directory called MyApp01. Inside it you will find
one main file and three subdirectories:</p>
<pre><code>    MyApp01
    MyApp01/app.js   // We usually call this file server.js
    MyApp01/public
    MyApp01/routes
    MyApp01/views
</code></pre><p>Alternatively, you can do something like this, which provides a library
called stylus for use with CSS files:</p>
<pre><code>express -c stylus MyApp02
</code></pre><p>You can read about stylus in more depth later in this document.</p>
<p>By default, Express applications run on port 3000. Since we typically
run our applications on port 30025, the first thing you might do is
open <strong>app.js</strong> and modify the line that specifies the default port:</p>
<pre><code>app.set(&#39;port&#39;, process.env.PORT || 30025);    
</code></pre><h2 id="jade">Jade</h2>
<p>Jade is a template library like Handlebars. It also is a bit like
Markdown, in that it provides a shorthand syntax for composing 
HTML pages.</p>
<p>Here is an example of how to layout a Jade template:</p>
<pre><code>doctype 5
html
    head
        title= title
        link(rel=&#39;stylesheet&#39;, href=&#39;/stylesheets/style.css&#39;)
    body
        nav
            ul
                li 
                    a(href=&quot;/&quot;) page01
                li 
                    a(href=&quot;/page02&quot;) page02
                li 
                    a(href=&quot;/page03&quot;) page03
        h1 #{title}
        block content
</code></pre><p>When working with jade, indentation is crucial. You should indent with either tabs or spaces, but not both. You frequently need to open your file in an editor that allows you to visualize your white space. Then you should count your space, and make sure it follows an exact pattern. Suppose, for instance, that you are uses tabs for your indentation. In the pseudo code shown below, each hyphen (dash -) represents one tab.</p>
<p>Example 1 is like what&#39;s shown above:</p>
<pre><code>doctype
html
- head
- - title
- - link
- body
- - nav
- - - ul
- - - - li
- - - - li
- - - - li
- - h1
- - block content
</code></pre><p>Example 2 is a common pattern in bootstrap files:</p>
<pre><code>block content
- container
- - header
- - navbar
- - - nav
- - - - ul
- - - - - li
- - - - - li
- - - - - h3
- - - h1
- - - p
- - - h1
- - - div
- - - footer
- - - - p
</code></pre><p>When looking at the pseudo code above, the point is that you can explicitly count how many tabs appear before each HTML element. You want to achieve that level of specificity when working with Jade. </p>
<p><strong>HINT</strong>: <em>Here are some ways to turn on visual whitespace in various editors:</em></p>
<ul>
<li>NotePad++: <strong>View | Show Symbol | Show White Space and Tab</strong></li>
<li>Geany: <strong>View | Editor | Show White Space</strong></li>
</ul>
<p>Most programming editors have options like these.</p>
<p>In the next few paragraphs I describe how Jade templates get linked
in to our applications. Much of the code I describe is autogenerated
for you when you first create the express application. However, some
of the code you have to write yourself. Of course, whether the code
is autogenerated, or created automatically, you should be sure that
you understand all the pieces and what they do.</p>
<p>We can integrate our Jade template pages by creating a JavaScript 
file (often called index.js) in our Routes directory that defines 
our routes. These routes detail how the templates should be 
rendered. We also add code to our main express JavaScript file. Here is 
an example:</p>
<pre><code>exports.index = function(request, response){
  response.render(&#39;index&#39;, { title: &#39;Margie&#39;, foo: &#39;bar&#39; });
};

exports.page02 = function(request, response){
  response.render(&#39;page02&#39;, { title: &#39;Margie&#39;, foo: &#39;bar&#39; });
};

exports.page03 = function(request, response){
  response.render(&#39;page03&#39;, { title: &#39;Margie&#39;, foo: &#39;bar&#39; });
};
</code></pre><p>The code shown above defines some template variables called title
and foo. It also links in three Jade templates from the <strong>views</strong>
directory. The templates referenced in the above code are called:</p>
<ul>
<li>index.jade</li>
<li>page02.jade</li>
<li>page03.jade</li>
</ul>
<p>In our <strong>app.js</strong> file we link in the views directory and Jade like this:</p>
<pre><code>app.set(&#39;views&#39;, __dirname + &#39;/views&#39;);
app.set(&#39;view engine&#39;, &#39;jade&#39;);
</code></pre><p>And then in <strong>app.js</strong> we also include the following code:</p>
<pre><code>// Link in the routes directory where index.js lives
var routes = require(&#39;./routes&#39;);

// Link in the routes themselves.
app.get(&#39;/&#39;, routes.index);
app.get(&#39;/page02&#39;, routes.page02);
app.get(&#39;/page03&#39;, routes.page03);
</code></pre><p>Some resources:</p>
<ul>
<li><a href="http://jade-lang.com/">Home page</a></li>
<li><a href="http://html2jade.aaron-powell.com/">HTML to Jade</a></li>
</ul>
<h2 id="jade-indent">Jade Indent</h2>
<p>When thinking about Jade, indentation is crucial. Suppose I write this:</p>
<pre><code>div
p
</code></pre><p>That creates two separate, unrelated elements, a div and paragraph.</p>
<pre><code>&lt;div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
</code></pre><p>Suppose I write this:</p>
<pre><code>div
   p
</code></pre><p>Now the paragraph is part of the div because it is indented to the right beneath it.</p>
<pre><code>&lt;div&gt;
   &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>Suppose you create a div and make it your controller:</p>
<pre><code>div(ngController=&quot;MyController&quot;)
p {{firstName}}
</code></pre><p>The above code probably won&#39;t work because the paragraph is not part of the controller and hence <strong>{{firstName}}</strong> is out of scope. To fix it, do this:</p>
<pre><code>div(ngController=&quot;MyController&quot;)
   p {{firstName}}
</code></pre><p>Now the paragraph is part of the controller.</p>
<p>When trying to see exactly what is going on with the spacing in a Jade file, considering opening it in geany and turning on <strong>View | Editor | Show White Space</strong>. Or open it in NotePad++ and choose <strong>View | Show Symbol | Show White Space and Tab</strong>.</p>
<p>In WebStorm, you can also turn on visible white space, I believe it is: <strong>File | Settings | Editor | General | Appearance | White Space</strong>.</p>
<h2 id="stylus">Stylus</h2>
<p>Stylus is a library that allows you to create CSS pages using a technique
that is a bit reminicescent of a template library or of markdown. In 
other words, it provides an alternative syntax for composing CSS pages,
as well as a syntax for working with variables and parameters while
composing CSS pages.</p>
<p><a href="http://learnboost.github.io/stylus/">The Stylus Home Page</a></p>
<p>When you add stylus to a node express page, the following line of code
should be present in your main express file:</p>
<pre><code>    app.use(require(&#39;stylus&#39;).middleware(__dirname + &#39;/public&#39;));
</code></pre><p>Here is a Simple Styl Page</p>
<pre><code>border-stuff()
    border solid thin black

body
    background-color #00AA00
    padding: 50px
    font: 14px &quot;Lucida Grande&quot;, Helvetica, Arial, sans-serif

a
    color: #004400

nav
    background-color #00CC00
    border-stuff(0)
    padding 25px
    ul
        list-style none
        li
            display inline
            border-stuff(0)
            margin 10px
            padding 5px
            background-color #00FF00
</code></pre><h2 id="jasmineNode">Test with Jasmine-Node</h2>
<p>First install jasmine-node:</p>
<pre><code>sudo npm install -g jasmine-node
</code></pre><p>You will also want to install request locally with one of the following:</p>
<pre><code>npm install request
npm install request --save-dev
</code></pre><p>The second option saves your command into <strong>package.json</strong>, if <strong>package.json</strong>
already exists.</p>
<p>Create a simple route you want to test:</p>
<pre><code>app.get(&#39;/hello&#39;, function(request, response) { &#39;use strict&#39;;
    response.send(&#39;Hi there.&#39;);
});
</code></pre><p>Define a basic Jasmine-Node test by saving the following 
as <strong>Tests/SimpleSpec.js</strong>:</p>
<pre><code>var request = require(&#39;request&#39;);

describe(&quot;A suite&quot;, function() {
    it(&quot;should respond with hello world&quot;, function(done) {
        request(&quot;http://localhost:30025/hello&quot;, function(error, response, body) {
            expect(body).toEqual(&quot;Hi there.&quot;);
            done();
        });
    });
}); 
</code></pre><p>Now start your server running in one shell:</p>
<pre><code>node Server.js
</code></pre><p>Then open a second shell and run your tests:</p>
<pre><code>jasmine-node Tests/
</code></pre><p>Voila! You are done.</p>
<h2 id="require">Require</h2>
<p>Let&#39;s look at this line of code:</p>
<pre><code>var express = require(&#39;express&#39;)
</code></pre><p>It says that you want to load a copy of a file from the Express package and retrieve an object from it.</p>
<p>In <strong>package.json</strong> we ask <strong>npm</strong> to install the express library into <strong>node modules</strong>:</p>
<pre><code>  &quot;dependencies&quot;: {
    &quot;body-parser&quot;: &quot;~1.12.0&quot;,
    &quot;cookie-parser&quot;: &quot;~1.3.4&quot;,
    &quot;debug&quot;: &quot;~2.1.1&quot;,
    &quot;express&quot;: &quot;~4.12.2&quot;,    // Ask NPM to load Express
    &quot;jade&quot;: &quot;~1.9.2&quot;,
    &quot;morgan&quot;: &quot;~1.5.1&quot;,
    &quot;serve-favicon&quot;: &quot;~2.2.0&quot;
  }
</code></pre><p>Because that line is found in <strong>package.json</strong>, the following directory is created in <strong>node_modules</strong>:</p>
<pre><code>Week04-AngularMongoState\node_modules\express
</code></pre><p>In that folder is a directory called <strong>lib</strong> and there is found a file called <strong>express.js</strong>. It is that file that is loaded when we call <strong>require</strong> and pass in <strong>express</strong>. Since we need the express library in a nodejs express project, it is important that we don&#39;t change that line. </p>
<h2 id="nodemon-watches-for-changes">Nodemon Watches for Changes</h2>
<p>Install nodemon:</p>
<pre><code>npm install -g nodemon
</code></pre><p>Now use it to start your application:</p>
<pre><code>nodemon server.js
</code></pre><p>Now you won&#39;t have to restart your application each time you change
the source.</p>
<h2 id="debug-node-in-eclipse">Debug Node in Eclipse</h2>
<p>Here is how to debug outside of Eclipse:</p>
<ul>
<li><a href="http://nodejs.org/api/debugger.html">http://nodejs.org/api/debugger.html</a></li>
</ul>
<p>Though it is not necessary for debugging, this is a good time to check that
you have JsHint installed. If you don&#39;t have it installed, or if you are at all
unclear how to install new software into Eclipse, then please see this link:</p>
<ul>
<li><a href="http://elvenware.com/charlie/development/android/Eclipse.shtml#jsHint">http://elvenware.com/charlie/development/android/Eclipse.shtml#jsHint</a></li>
</ul>
<p>Just to review, here is the URL for JsHint:</p>
<ul>
<li><a href="http://github.eclipsesource.com/jshint-eclipse/updates/">http://github.eclipsesource.com/jshint-eclipse/updates/</a></li>
</ul>
<p>After you choose Help | Install New Software and click the add button, you fill
in the dialog like this:</p>
<p><img src="http://elvenware.com/charlie/development/android/images/JsHint02.png" alt="Install JsHint in Eclipse"></p>
<p>Let&#39;s now start talking about debugging inside Eclipse. You need to 
Install V8 into Eclipse. Choose <strong>Help | Install Software</strong> as above, and 
enter this URL:</p>
<ul>
<li><a href="http://chromedevtools.googlecode.com/svn/update/dev/">http://chromedevtools.googlecode.com/svn/update/dev/</a></li>
</ul>
<p><img src="images/ChromeV8Install10.png" alt="V8 Install"></p>
<p>Next you need to install Node Eclipse. Again Choose <strong>Help | Install Software</strong>
and this time use this URL:</p>
<ul>
<li><a href="http://www.nodeclipse.org/updates">http://www.nodeclipse.org/updates</a></li>
</ul>
<p>Start the program like this:</p>
<pre><code>node --debug-brk server01.js
</code></pre><p>Regardless of the port that you told your program to run on, the debugger
runs on port 5858:</p>
<p>G:\Git\OpenId03&gt;node --debug-brk server01.js
debugger listening on port 5858</p>
<p>When starting the server in the browser, however, you should still use the
port you assigned:</p>
<pre><code>http://localhost:30025
</code></pre><p>In Eclipse set up a Debug run configuration. First bring up the Debug Run 
Configuration dialog:</p>
<p><img src="images/NodeDebug00.png" alt="Launch Debug Config Dialog"></p>
<p>Then set up the configuration for the V8 engine on port 5858:</p>
<p><img src="images/NodeDebug01.png" alt="Debug Run Configuration"></p>
<p>I am not able to set breakpoints using the tools. Instead, I have to go into
the code and manually type the word <strong>debugger;</strong> on the line where I want the
debugger to break. Then I do the following:</p>
<ul>
<li>type <strong>node --debug-brk server01.js</strong> at the command line</li>
<li>start the debugger in Eclipse, press F8 once to get passed the first breakpoint.</li>
<li>launch my program in in the browser: <a href="http://localhost:30025">http://localhost:30025</a> </li>
</ul>
<p>The program will then stop at my breakpoint:</p>
<p><img src="images/NodeDebug02.png" alt="The debugger hits breakpoint and stops on line 27"></p>
<p>You can step through the debugger with the following keys:</p>
<ul>
<li>F5 (Step into)</li>
<li>F6 (Step over)</li>
<li>F8 (Continue - run)</li>
</ul>
<p><img src="images/NodeDebug03.png" alt="Viewing the request.query object in the debugger"></p>
<h2 id="upstart">UpStart</h2>
<p>UpStart is a Linux utility that ships with recent Ubuntu releases. 
It can be used to ensure that your node servers or other program 
stay in memory even after you have closed your shell. It will even 
restart the programs automatically if the OS is rebooted.</p>
<p>Note that this project includes a file called ExpressSend.config. 
You can use this file to ensure that your application is launched 
when your OS boots, and that it will stay running, even if it 
temporarily crashes.</p>
<p>In JsObjects, there is a program called ExpressSend:</p>
<pre><code>JsObjects/JavaScript/NodeCode/ExpressSend
</code></pre><p>If you open ExpressSend.config in an editor, you will see a few 
portions of the line that begins with the word exec that you might 
want to edit to convert them for use in your own programs. For 
instance, seee the line that begins like this:</p>
<pre><code>exec /usr/bin/nodejs /home/charlie/ExpressSend/server.js
</code></pre><p>If your version of the server is located elsewhere, then change the 
line as necessary. For instance:</p>
<pre><code>exec /usr/bin/nodejs /home/belinda/bin/server.js
</code></pre><p>Note that I replaced charlie/ExpressSend with belinda/bin. You 
should edit your version of ExpressSend.config to reflect that paths 
and file names on your system.</p>
<p>You can create a <a href="http://www.cyberciti.biz/tips/understanding-unixlinux-symbolic-soft-and-hard-links.html">symbolic 
link</a> to a deeply nested directory like this:</p>
<pre><code>ln -s /home/ubuntu/Git/Prog282-Hints/CanvasGrid03 CanvasGrid
</code></pre><p>If you give that command in your home directory, then you will end
up with a directory that looks like this:</p>
<pre><code>/home/ubuntu/CanvasGrid
</code></pre><p>The point, of course, is that this new directory is an alias, soft
link to the CanvasGrid03 directory.</p>
<p>Place ExpressSend.config in the /etc/init directory:</p>
<pre><code>/etc/init/ExpressSend.config
</code></pre><p>The command to copy it to appropriate directory would be:</p>
<pre><code>sudo cp ExpressSend.config /etc/init/.
</code></pre><p>Once the file is in the /etc/init directory, you can start your 
program by typing the following:</p>
<pre><code>sudo start ExpressSend
</code></pre><p>You can stop it with following command:</p>
<pre><code>sudo stop ExpressSend
</code></pre><p>When you reboot the system, your program will start automatically.</p>
<p>Error messages and other output from your program are recorded in 
the following location:</p>
<pre><code>/var/log/node.log 
</code></pre><p>If you examine the script, you can see that this file name is configurable.</p>
<p>You should create one script of this type for each program that you 
want to launch.</p>
<p>In your node program, you may need to alter paths to your files so
that they include the __dirname variable:</p>
<pre><code>    var html = fs.readFileSync(__dirname + &#39;/Public/index.html&#39;);
</code></pre><p>The following <strong>might</strong> also work, though i need to test it more:</p>
<pre><code>var html = fs.readFileSync(&#39;./Public/index.html&#39;);
</code></pre><p>For now, I recommend the first option. This is necessary because your
program is no longer being launched from the directory in which you
created it, but instead, is start from the /etc/init directory. There
fore you need to use __dirname, which resolves to the complete path
to your file. For instance:</p>
<pre><code>/home/charlie/git/MyProgram/Public/index.html
</code></pre><p>The <strong>__dirname</strong> variable, which is built into Node, gives you
the /home/charlie/git/MyProgram part of the path. Of course, on your
system that bit of the path will probably be different. Here is more
information on dirname:</p>
<pre><code>&lt;http://nodejs.org/docs/latest/api/globals.html#globals_dirname&gt;
</code></pre><h2 id="more-on-upstart">More on Upstart</h2>
<p>We specify where the log file will be written in this part of our upstart 
scripts:</p>
<pre><code>exec /usr/bin/nodejs /home/ubuntu/ExpressSend/server.js &gt;&gt; /var/log/node.log 2&gt;&amp;1
</code></pre><p>This command has three parts that we need to get write:</p>
<ul>
<li><strong>exec</strong> - This command executes a process or program.</li>
<li><strong>/usr/bin/nodejs</strong> - This parameter points at our nodejs program. This is the program to be executed</li>
<li><strong>/home/ubuntu/ExpressSend/server.js</strong> - This is the path to the script that nodejs will run.</li>
</ul>
<p>Then we redirect the output from the program to a text file called node.log that is located in the /var/log directory:</p>
<pre><code>&gt;&gt; /var/log/node.log 2&gt;&amp;1
</code></pre><p>To see the content of that file, run this command:</p>
<pre><code>cat /var/log/node.log
</code></pre><p>That is the most important command when it comes to debugging our UpStart scripts.</p>
<p>Let&#39;s talk for a minute more about this strange command:</p>
<pre><code>&gt;&gt; /var/log/node.log 2&gt;&amp;1
</code></pre><p>The &gt; character redirects the output from one command to some other place, 
usually a file. So this command sends the output of the echo command to a 
file called foo.txt:</p>
<pre><code>echo foo &gt; foo.txt
</code></pre><p>After the command is run, foo.txt contains the string foo.</p>
<p>This command appends the output of the echo command to foo.txt:</p>
<pre><code>echo bar &gt;&gt; foo.txt
</code></pre><p>Now foo.txt contains both foo and bar. The &gt; operator will overwrite 
foo.txt, and the &gt;&gt; operator will append data to it.</p>
<p>All this is called redirection, which is different from piping, which is 
done with the | symbol.</p>
<p>This part of the command is more complicated:</p>
<pre><code>2&gt;&amp;1 
</code></pre><p>There are actually two streams of output that can occur when we launch a 
program. One is the standard output stream, and that is what we are redirecting 
above. The other is stderr, which is an error stream. By error stream, I mean
that it is a stream that contains the output produced by errors in our program.</p>
<p>The bizarre looking <strong>2&gt;&amp;1</strong> command redirects stderr to the same place as 
stdout. This means that both the normal text, and the error text, is being 
redirected to the same place. In our case, they are both being redirected to 
<strong>node.log</strong>. When we read (cat) <strong>/var/log/node.log</strong>, we are therefore seeing 
all the standard output, and all the error output, from our program.</p>
<h2 id="eaddrinuse-and-upstart">EADDRINUSE and UpStart</h2>
<p>The EADDRINUSE error is <a href="#EADDRINUSE">introduced above</a>. Attemps to fix the error might be complicated if you are on a Linux box and using Upstart. UpStart keeps your program running even after you close the command prompt. This means you can&#39;t stop the program by just typing Ctrl-C. </p>
<p>When using UpStart, remember to stop any running programs, such as our
ExpressSend sample, like this:</p>
<pre><code>sudo stop ExpressSend
</code></pre><p>You might think that you can tell if a program is running on a port
by going to browser and seeing if anything comes up when you type in 
the address and port of your server:</p>
<p><a href="http://192.168.0.1:30025">http://192.168.0.1:30025</a></p>
<p>That should help you tell if something is running on that port, but 
it might not if you tried to launch something on that port, but it 
failed during the launch. In particular, sometimes an attempt to 
start a node program with UpStart will fail:</p>
<pre><code>sudo start ExpressSend
</code></pre><p>You have to check <strong>/var/log/node.log</strong> to see if there are errors. But 
the port can be munged up even if the program did not start 
correctly. To fix the problem, just tell the program to stop running. If 
necessary, remove the script from /etc/init. This can be important 
because Linux will try to rerun the script when your server restarts:</p>
<p>sudo rm /etc/init/ExpressSend.config</p>
<p>Like all powerful tools, UpStart can be a double edged sword. It gives
you control over your system, but the power it grants you can also be
source of trouble. </p>
<h2 id="creating-directories-and-copying-files">Creating Directories and Copying Files</h2>
<p>See the Library in the following project for an example of how to copy
files and make directories:</p>
<pre><code>JsObjects/JavaScript/Syntax/MakeDirectory.
</code></pre><p>To create a directory:</p>
<pre><code>    var mkdirp = require(&#39;mkdirp&#39;);

    var createDirectory = function(directory) {
        mkdirp(directory, function(err) {
            if (err) {
                console.log(err);
            } else {
                console.log(&quot;Created directory&quot;);
            }
        });    
    };
</code></pre><p>For mkdirp: <strong>npm install mkdirp</strong></p>
<p>And to copy a file:</p>
<pre><code>    var copyFile = function(source, target) {

        var rd = fs.createReadStream(source);
        rd.on(&quot;error&quot;, function(err) {
            done(err);
        });
        var wr = fs.createWriteStream(target);
        wr.on(&quot;error&quot;, function(err) {
            done(err);
        });
        wr.on(&quot;close&quot;, function(ex) {
            done(&#39;Success: &#39; + ex);
        });
        rd.pipe(wr);

        function done(msg) {
            console.log(msg);
        }
    };
</code></pre><h2 id="folder-manipulation">Folder Manipulation</h2>
<p>A library with a routine for ensuring a directory exists and for
recursively removing directories.</p>
<pre><code>var mkdirp = require(&#39;mkdirp&#39;);
var fs = require(&#39;fs&#39;);
var path = require(&quot;path&quot;);

var SimpleDir = (function() {

    function SimpleDir() {
    }

    var makeDir = function(folder) {
        mkdirp(folder);
    }

    // Test if a directory exists, if it does not exist create it
    SimpleDir.prototype.ensureDir = function(folder) {
        fs.exists(folder, existsFunc);
    }

    // Synchronous version of directory exists
    SimpleDir.prototype.ensureDirSync = function(folder) {
        currentFolder = folder;
        if (fs.existsSync(folder)) {
            return fs.statSync(folder);
        } else {
            makeDir(folder);
            return &#39;successfully created directory&#39;;
        }        
    };

    // Remove directories recursively
    // Credit to tkihira: https://gist.github.com/tkihira/2367067
    SimpleDir.prototype.rmdirSync = function(dir) {
        var list = fs.readdirSync(dir);
        for(var i = 0; i &lt; list.length; i++) {
            var filename = path.join(dir, list[i]);
            var stat = fs.statSync(filename);

            if(filename == &quot;.&quot; || filename == &quot;..&quot;) {
                // pass these files
            } else if(stat.isDirectory()) {
                // rmdir recursively
                this.rmdirSync(filename);
            } else {
                // rm filename
                fs.unlinkSync(filename);
            }
        }
        fs.rmdirSync(dir);
    };

    return SimpleDir;
})();

exports.dirs = new SimpleDir();
</code></pre><p>You might use it in node like this:</p>
<pre><code>var dirLib = require(&#39;./Library/SimpleDir&#39;);

var folder = &#39;foo/bar/bam&#39;;

dirLib.dirs.ensureDirSync(folder);
dirLib.dirs.rmdirSync(&#39;foo&#39;);
</code></pre><h2 id="node-and-environment-variables">Node and Environment Variables</h2>
<p>If you have set a global environment variable called JSOBJECTS, you
can access it like this:</p>
<pre><code>process.env.JSOBJECTS
</code></pre><p>Suppose you set JSOBJECTS to C:\Temp\JsObjects:</p>
<pre><code>set JSOBJECTS=C:\Temp\JsObjects
</code></pre><p>Now you can access this variable inside your node code:</p>
<pre><code>var jsObjects = process.env.JSOBJECTS;
</code></pre><h2 id="jshint">JSHint and Node</h2>
<p>You can run JSHint from node. First install JSHint:</p>
<pre><code>npm install -g jshint
</code></pre><p>Now try running JSHint by typing the command <strong>jshint</strong> at the command line. 
If you see an error about the path, then set the following environment variable:</p>
<pre><code>set HOME=%HOMEPATH%
</code></pre><p>It is a bug in JsHint that makes us do this. On Linux and the Mac you probably
won&#39;t need to set the environment variable.</p>
<p>And finally try running jshint against one of your files:</p>
<pre><code>jshint index.js
</code></pre><ul>
<li><a href="http://nodejs.org/api/modules.html#modules_loading_from_the_global_folders">See also Node and env</a></li>
</ul>
<h2 id="maintain-repository">Maintain Repository</h2>
<p>Every little bit, run:</p>
<pre><code>git gc
</code></pre><p>Verify it:</p>
<pre><code>C:\Git\repo&gt;git verify-pack -verbose .git\objects\pack\pack-4beeb...idx
</code></pre><h2 id="find-big-files-that-you-don-t-need">Find big files that you don&#39;t Need</h2>
<p>Run git gc per above.</p>
<p>Now find any huge files:</p>
<pre><code>git rev-list --objects --all &gt; bar.txt    
</code></pre><p>Look for entries about your big file:</p>
<pre><code>git log --pretty=oneline -- /Tech/Monkey.png
</code></pre><p>Like this:</p>
<pre><code>C:\Git\repo&gt;git log --pretty=oneline -- Tech/Graphics/HtmlSwitch/Monkey.JPG
3c6a55fa8d507e31864e5651ca1fec3a9eb2b5d1 delete big files
69d6f1ed3de5198b9595d2edae818bb00ef4444d Adding switch examples

git filter-branch --index-filter &quot;git rm --cached --ignore-unmatch Tech/Graphics/HtmlSwitch/Monkey.JPG&quot; -- 69d6f1^
</code></pre><p>Or:</p>
<pre><code>git filter-branch --index-filter &quot;git rm --cached --ignore-unmatch Tech/Graphics/HtmlSwitch/Monkey.JPG&quot; -- 69d6f1^
</code></pre><p>Or: </p>
<pre><code>git filter-branch --index-filter &quot;git rm -rf --cached --ignore-unmatch Tech/Graphics/HtmlSwitch/Monkey.JPG&quot; HEAD
</code></pre><p>At this point you ought to be able to push your changes.</p>
<p>Linux or Mac users, See this GIST:</p>
<ul>
<li><a href="https://gist.github.com/shennyg/1047737">https://gist.github.com/shennyg/1047737</a></li>
</ul>
<h2 id="karmaChrome">Karma and CHROME_BIN</h2>
<p>Here&#39;s a tip:</p>
<pre><code>echo &#39;export CHROME_BIN=&quot;/usr/bin/chromium-browser&quot;&#39; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc
</code></pre><p>Just remember that you put the call in <strong>.bashrc</strong> in case there is some reason why you don&#39;t want that behavior later on. In other words, you have now set <strong>CHROME_BIN</strong> for all bash sessions you create until you remove that line. Frankly, that seems like a totally reasonable thing to do, but just remember that you did it, in case there is some reason you want different behavior later on. Also, we don&#39;t want to put too much in our <strong>.bashrc</strong> file or they will become too complex, and take too long to execute. This one line alone won&#39;t cause problems, of course.</p>
<p>I believe I had referenced this bash file:</p>
<p><a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Design/BridgeSailor/RunKarma.sh">https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Design/BridgeSailor/RunKarma.sh</a></p>
<p>It is a script, and needs to be run as such: </p>
<pre><code>sh RunKarma.sh
</code></pre><p>or</p>
<pre><code>chmod +x RunKarma.sh // Done once
./RunKarma.sh        // Any time you want to run the script once it has the executable flag set by the chmod call.
</code></pre><p>Then when it runs, it starts a new shell, then sets the environment variable \$CHROME_BIN in the new shell to <strong>/usr/bin/chromium-browser</strong>, and then executes the line <strong>karma start</strong>. The point, I assume, is that Karma needs to know where chromium is located, and it checks the \$CHROME_BIN environment variable as at least one way of finding it.</p>
<p>If you put the line: <strong>export CHROME_BIN=/usr/bin/chromium-browser</strong> at the end of your .bashrc file, then each time you start a new bash shell, that environment variable will be set.</p>
<p>The line <strong>source ~/.bashrc</strong> is a way to have the <strong>.bashrc</strong> file executed without having to start a new shell. It executes the line inside the present shell, and it can change the current shell, and particularly the environment variables for the current shell.</p>
<p><a href="http://superuser.com/questions/46139/what-does-source-do">http://superuser.com/questions/46139/what-does-source-do</a></p>
<p>The point here is this. If you run <strong>source .bashrc</strong>, or if you start a new shell the normal way, then the current shell, the one you are in, is affected. It is a way of making sure that your current shell, the one at whose command line you are currently working, has executed all the commands in <strong>.bashrc</strong>. But if you run a script with the dot (.) command, then a new shell is launched, the script is run, and when it is finished you are returned to the original shell and changes the script made to the environment are forgotten. Consider running our command:</p>
<pre><code>./RunKarma.sh
</code></pre><p>It creates a new shell, sets the environment variable CHROME_BIN for that shell to <strong>/usr/bin/chromium-browser</strong>. The script then starts Karma. When you hit Control-C to end the run, then you are returned to original shell, and the CHROME_BIN environment variable is returned to the state it was in before you ran the command.  Since it is unlikely that anything else but Karma cares about that environment variable, then that is a reasonable solution. You could probably put ./RunKarma in your bin directory, so that you did not have to put it inside of each project.... (Yes, I tried that, and it seems to work).</p>
<p>Remember that you can check the current value of CHROME_BIN by typing:</p>
<pre><code>echo \$CHROME_BIN
</code></pre><p>On Windows it would be:</p>
<pre><code>echo %CHROME_BIN%
</code></pre><h2 id="cloud-9">Cloud 9</h2>
<p>Cloud 9 is an online IDE. You can find it here:</p>
<p><a href="https://c9.io/">https://c9.io</a></p>
<p>On your account page, you can link to your GitHub account.</p>
<p>Installing NPM modules:</p>
<p><a href="https://docs.c9.io/installing_npm_modules.html">https://docs.c9.io/installing_npm_modules.html</a></p>
</div></body></html>