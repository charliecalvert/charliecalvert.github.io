<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>GettingStarted</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap-theme.min.css"><!-- link(href='/libs/css/BootstrapIndex.css', rel='stylesheet', type='text/css')--><link href="/css/style.css" rel="stylesheet" type="text/css"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><script src="/components/jquery/dist/jquery.js"></script><script src="/components/angular/angular.js"></script><script src="/components/angular-route/angular-route.js"></script><script src="/components/bootstrap/dist/js/bootstrap.min.js"></script><!-- script(src='/libs/scripts/elvenware.js', type='text/javascript')--><script src="/libs/scripts/Control.js"></script><!-- script(src='http://localhost:35729/livereload.js')--></head><body><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/about">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/development/index.html">Strongly Typed</a></li><li><a href="/development/web/index.html">Web & Scripts</a></li><li><a href="/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>GettingStarted</h1><p>Welcomes to GettingStarted</p><ul><!--TOC_Start--><li><a href="#chapter-01-introduction">Chapter 01 - Introduction</a></li>
<li><a href="#general-considerations">General Considerations</a></li>
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#creativity">Creativity</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#bad-smells">Bad Smells</a></li>
<li><a href="#arrogance">Arrogance</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#refactoring">Refactoring</a></li>
<li><a href="#design">Design</a></li>
<li><a href="#guidelines">Guidelines</a></li>
<li><a href="#order-and-discipline">Order and Discipline</a></li>
<li><a href="#be-practical">Be Practical</a></li>
<li><a href="#part-ii">Part II</a></li>
<li><a href="#introductionToJavaScript">Introduction to JavaScript</a></li>
<li><a href="#helloWorldAtTheCommandPrompt">Hello World at the Command Prompt</a></li>
<li><a href="#helloWorldInTheBrowser">Hello World in the Browser</a></li>
<li><a href="#discreet-javascript">Separating HTML and JavaScript</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#theCaseOfFileNames">The Case of File Names</a></li>
<li><a href="#client-server-js">Client Side, Server Side</a></li>
<li><a href="#console.Log">Console.Log</a></li>
<li><a href="#learnMore">Learn More</a></li>
<li><a href="#theRightTools">The Right Tools</a></li>
<li><a href="#the-right-books">The Right Books</a></li>
<li><a href="#some-caveats">Some Caveats</a></li>
<li><a href="#some-links">Some Links</a></li>
<li><a href="#news-links">News Links</a></li>
<li><a href="#blog-links">Blog Links</a></li>
<li><a href="#microsoft">Microsoft</a></li><!--TOC_End--></ul><h1 id="chapter-01-introduction">Chapter 01 - Introduction</h1>
<p>This chapter covers general development strategies. The focus is on JavaScript and related tools but much of what is said applies to any computer language. The primary goal is help intermediate developers develop the skills necessary to begin the transition to expect developer. Nevertheless, beginners will find some useful material in the early chapters. More experienced developers who are new to JavaScript can learn some of the basics and danger points in the language. After reading this chapter, you can move on to the more practical, hands-on chapter called <a href="JavaScriptsBasics.html">JavaScript Basics</a>.</p>
<h2 id="general-considerations">General Considerations</h2>
<p>This book is designed to teach intermediate level developers how to write testable, maintainable, robust, well-structured code.</p>
<p>Most developers who complete beginning level courses can:</p>
<ul>
<li>declare variables</li>
<li>write loops</li>
<li>branch on logical statements or operators</li>
<li>compose functions and pass values to them and from them.</li>
</ul>
<p>These fundamental tasks are essential, and must be mastered before serious study of programming can commence. In the chapter called JavaScript basics I do show how these tasks are performed using the JavaScript language, but that is not the focus of this text.</p>
<p>The best programmers take pride in their code. They want to write code that works, of course, but they also want to write code that is easy to understand and easy to maintain. In particular, they want to create code that is:</p>
<ol>
<li>Testable</li>
<li>Maintainable</li>
<li>Reusable</li>
<li>Robust</li>
<li>Fast enough</li>
</ol>
<p>Order here is important. Nearly every method or function we write should be, before everything else, testable. Once we can test it, then we can refactor it so as to make it more maintainable, reusable and robust. We also refactor our code to make it more readable. In most cases our code only needs to be fast enough not to annoy the user; there is rarely a need to make a fetish out of performance issues.</p>
<p>Good code:</p>
<ul>
<li>Has carefully chosen identifiers</li>
<li>Is well formatted</li>
<li>Divided into short, testable functions that serve a single purpose</li>
<li>Organized in well designed modules that perform a single task</li>
<li>Designed in accordance with basic programming guidelines such as:<ul>
<li>Loose coupling</li>
<li>The Single Responsibility Principle</li>
<li>The Open Closed Principle</li>
</ul>
</li>
</ul>
<h2 id="philosophy">Philosophy</h2>
<p>This text is designed to be readily comprehensible. Too many books are clever rather than clear. Any developer should be able to read this text and understand what it teaches about the art of development.</p>
<p>This book is aimed at a particular niche:</p>
<ul>
<li>Helping intermediate level programmers learn to create programs that work</li>
<li>Helping intermediate developers be prepared to learn how to become, or how to work with, expert developers</li>
</ul>
<p>This book is designed to take an ordinary developer and teach them the perspective of a master developer. I want to show developers that there is more to programming that simply writing loops, branch statements, and calling functions. Too many developers are stuck at the intermediate level because they don&#39;t have the knowledge needed to understand expert books, strategies and algorithms.  Once they understand the difference between learning the basics, and mastering proper application design, then they will be able to move forward in their careers. Even if they never become experts themselves, they will be skilled enough to work on advanced teams that develop interesting and important projects.</p>
<h2 id="creativity">Creativity</h2>
<p>Many developers with a strong creative bent lack the analytic skills necessary to help them write good code and bring their ideas to fruition. One of my goals is to help people like this succeed. If you have a creative bent, but are having trouble bringing your ideas to fruition in code, then you will find this text is designed to help you succeed.</p>
<p>Your discipline, creativity, business smarts, or ideas will never be worth anything if you can&#39;t bring your idea to fruition. My goal is to teach a manner of programming that people of &quot;average&quot; talent can use to help them accomplish their goals.</p>
<h2 id="performance">Performance</h2>
<p>“Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.” — Donald Knuth in &quot;Structured Programming with Go To Statements&quot;</p>
<p>We should not concern ourselves with performance issues unless we hit a specific problem with execution time. Even then, we should probably not worry about the problem until the latter stages of program development.</p>
<p>Developer time and project schedule are often more important than minor optimizations in noncritical code. Most users will not notice whether or not one infrequently called method is 5 nanoseconds slower than it could be after four or five hours of optimization. But everyone notices if a project is behind schedule. So don&#39;t focus on performance until the latter stages of development. Focus instead on writing clean, easy to maintain code. It will be much easier to optimize clean code than spaghetti code.</p>
<p>If, near the end of a project, you find you do have a performance problem, don&#39;t ever try to guess where it is, even if it seems obvious. Instead, use a profiler to measure performance and find the slow spots. Then review your architecture and see if there are ways to speed things up.</p>
<p>I&#39;ve taught hundreds of students, and I have found that it is very rare for them to write code that is too slow. It is, however, common for them to write code that is buggy and overly complex. However, I have seen a number of student projects awash on the rocks because they tried to optimize a routine that probably never would have a significant impact on program performance. It is also common to see developers craft messy, hard to read code by adding optimizations that the compiler will do for you automatically. Or conversely, some attempts to optimize code prevent the compiler from performing much better optimizations.</p>
<p>Suppose a method that is called once runs in 100 milliseconds. Spending hours to get it run in 80 milliseconds is probably a waste of time. If you end up creating messy, hard to read, or repetitious code in the process, then you probably did more harm than good.</p>
<p>In general, however, it is not performance that causes intermediate level programmers to fail. Students fail to complete projects or quash bugs because they fail to properly craft their code.</p>
<p>It simply does not matter how fast your code is if it doesn&#39;t work and can&#39;t be tested. The first goal is to write clean, easy to maintain code that can form the building blocks for our tests and for a working program.</p>
<p><strong>NOTE</strong>: <em>I recognize that some projects, such as the core modules of an OS or compiler code generation, are very much concerned with even small performance issues. My argument here is not that there are no cases where performance is important, but only that it is generally not a high priority for typical programming assignments.</em></p>
<h2 id="bad-smells">Bad Smells</h2>
<p>Throughout this text I will try to highlight the kinds of errors in judgment that signal serious, deep rooted problems in a code base. If you look at a few samples of code from a big project, and see certain mistakes repeated over and over, then it is often fair to assume that the whole project is rife with problems. Developers often call these bad smells. We will talk about them in depth later on, but common problems include:</p>
<ul>
<li>Repetitious code</li>
<li>Large objects that take on too many tasks</li>
<li>Large methods that do too much and have lots of private variables</li>
<li>Multiple occurrences of the same switch statement</li>
<li>Long parameter lists</li>
<li>String constants, and especially the same string constant, scattered throughout a method, object or program.</li>
<li>Dead code or commented out code</li>
<li>Tight coupling. One class knows too much about another class</li>
</ul>
<h2 id="arrogance">Arrogance</h2>
<p>Arrogance stalks through the ranks of modern programmers like the plague spreading through the streets of of medieval town. Arrogance is more than simply a boorish and unattractive trait, it causes real damage. It hampers careers and in some cases destroys lives.</p>
<p>There is nothing more pathetic than a poor developer who loses a job because they are too arrogant to accept even simple tips on how to write better code. It&#39;s one thing to lose a job due to lack of skill, and another to lose it because you reject the principles of good application development out of sheer arrogance. The developer who is too &quot;intelligent&quot; to learn is a developer who will likely have a very short, or highly underpaid, career.</p>
<p>Here are some of the things that I hear from arrogant developers who simply don&#39;t have the sense to see how much they still need to learn:</p>
<ol>
<li>My code doesn&#39;t need to be tested. It just works.</li>
<li>I don&#39;t need to modularize or structure my code.</li>
<li>Properly formatting my code is a waste of time.</li>
<li>I have my own system for formatting code, the team guidelines don&#39;t apply to me.</li>
<li>I hate callbacks/recursion/rest calls/functional programming/tuples/promises etc because they are stupid</li>
<li>Other people can&#39;t understand my code not because its a mess, but because they are dumb.</li>
<li>Language X is stupid, my favorite language is brilliant.</li>
<li>My platform, my OS, my version of my OS, is the only great development environment, everything else is junk.</li>
<li>I don&#39;t need Git, I&#39;ve backed up all my code on a thumb drive.</li>
<li>One letter identifiers make my code shorter and easier to read.</li>
<li>I don&#39;t need to refactor my code.</li>
</ol>
<p>In short, if you think everything that is unfamiliar or hard to understand is stupid, then you probably need to examine your assumptions. If you refuse to take the time to make your code fit in with your teammates code, then you are headed for trouble.</p>
<p>Having said this, it is not necessarily fatal for a talented developer to be narrow minded in some particular area. A classic example of such a person would be Eric Raymond, who is guilty of the OS chauvinism listed above. Of course, Eric Raymond is so talented, so hard working, and so knowledgeable that he can afford to burden himself with a few glaring flaws. The odds that you are equally talented are vanishingly small. In Raymond&#39;s case, one could even argue that he turned his weakness into a strength. His over the top support of Unix lit the fire in his belly that helped him produce some very important books.</p>
<p>But some developers are narrow minded not just in a few cases, but in multiple ways. In programming, as in many areas of life, it is the people who mistakenly think they know a lot who are most dangerous. In most, but not all, cases, good developers are humble developers. Arrogance is usually a sign of ignorance. Most arrogant people lack the self-knowledge necessary to see their own flaws.</p>
<p>An average developer who thinks they are great is a liability. An average developer who is open minded, teachable, and hard working is usually a strong asset.</p>
<h2 id="testing">Testing</h2>
<p>There are no hard and fast definitions for the kinds of tests that people write. However, I generally break tests out in two types:</p>
<ul>
<li>Tests run from the developer&#39;s perspective</li>
<li>Tests run from the user&#39;s perspective</li>
</ul>
<p>Of course, it is usually the developer who runs all these tests. The difference between them is in what is being tested. Developer tests are testing code, while user tests are testing features. The person who hires you to do your work probably won&#39;t understand most developer tests, but they will understand a test that shows that a particular feature works. In fact, end users can often define what user tests need to be written, but they would not know how to define a developer test.</p>
<p>Developer tests are usually either:</p>
<ul>
<li><em>Unit tests</em> that test a single object and use mocks for dependencies</li>
<li><em>Integration tests</em> that test the interaction between two or more objects</li>
</ul>
<p>User tests are typically either:</p>
<ul>
<li><em>Functional tests</em> that prove that a feature works correctly</li>
<li><em>Acceptance tests</em> that check if the program as a whole works correctly and within reasonable performance limits</li>
</ul>
<p>It is common for acceptance tests to be used as a means of proving that a program meets the specifications set forth by the person who hired out the work. &quot;Here are tests that prove that our program does what you asked us to do.&quot;</p>
<p>Again, there is some disagreement between developers as to exactly how to define the various tests outlined above. For instance, I find it hard to draw a solid line between functional testing and acceptance testing in certain cases.</p>
<p> We will study all of the tests outlined above, but the primary focus will be on developer tests.</p>
<h2 id="refactoring">Refactoring</h2>
<p>Refactoring is the art of improving code without adding new features or fixing bugs. Typically we refactor our code to make it more:</p>
<ul>
<li>reusable</li>
<li>readable (comprehensible)</li>
<li>maintainable</li>
</ul>
<p>If we can create code that is testable, then it should be possible to refactor it so that it is maintainable, reusable and robust. The art of writing robust code is the art of learning how to test our code, how to refactor our code, how to make it reusable.</p>
<p>Testable code should be, by definition, reusable. It is used once in your program, and once in your tests. Thus it is reusable. If it is not easily reusable in both your tests and your program, then it needs to be refactored.</p>
<p>We need to know what impact a bug fix will have on the rest of our program. That is one of the reasons we test our code. After we make a bug fix, we run our tests to see what impact the change had on our code.</p>
<p>The art of writing code that is easy to test and easy to maintain turns out to be one of the most complex and important tasks a developer must master. Except in very rare cases, it can only be achieved through repeated refactoring. Just because your code works, or appears to work, that does not mean it is finished. As mentioned early, good code should be:</p>
<ol>
<li>Testable</li>
<li>Maintainable</li>
<li>Reusable</li>
<li>Robust</li>
<li>Fast enough</li>
</ol>
<p>We achieve these goals by refactoring our code.</p>
<h2 id="design">Design</h2>
<p>How do we learn to write maintainable, well designed code? Two key factors that help us achieve our goal are:</p>
<ol>
<li>Adopting good programming principles</li>
<li>A deep understanding of our tools and our language.</li>
</ol>
<p>By programming principles I&#39;m talking about things like:</p>
<ul>
<li>Agile Design</li>
<li>Programming guidelines such as the single responsibility principle</li>
<li>Team dynamics</li>
<li>Test Driven Development (TDD)</li>
<li>Behavior Driven Development (BDD)</li>
</ul>
<p>But knowing the theory is not enough. You also need a deep, intuitive, understanding of JavaScript or any other language you use. This is crucial if you want to write good code. You will constantly be forced to make implementation decisions when you write code. You will not be able to make any of those decisions unless you first have an understanding of what features are available in the language, and when and how to use them.</p>
<p>The bottom line is that you need to have a two pronged approach to development. On the one hand you need to understand good development principles, and on the other hand you need to dig into the details of your chosen language. Good developers can move fairly easily between computer languages, but their should be one or two languages that they choose to study in depth, and on which they focus most of their energy.</p>
<h2 id="guidelines">Guidelines</h2>
<p>So what are the programming principles mentioned in the previous section? Well, it turns out that their are many patterns and theories of development that you can study. However, in this book we will spend most of our time focused on just a few key princples:</p>
<ul>
<li><a href="http://agiledata.org/essays/tdd.html">Test Driven Development (TDD)</a></li>
<li><a href="http://edn.embarcadero.com/article/30372">Loose Coupling</a></li>
<li><a href="http://www.oodesign.com/single-responsibility-principle.html">The Single Responsibility Principle</a></li>
<li><a href="http://www.oodesign.com/open-close-principle.html">The Open Closed Principle</a></li>
</ul>
<p>A well designed architecture supports the <a href="https://en.wikipedia.org/wiki/Open/closed_principle">Open Closed Principle</a>:</p>
<ul>
<li><em><strong>Modules, Classes and Functions should be open to extension but closed to modification.</strong></em></li>
</ul>
<p>Along with <a href="https://en.wikipedia.org/wiki/Loose_coupling">loose coupling</a> the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single-responsibility principle</a> and <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> are core guidelines for our work. The open closed principle is one of the foundations of good software design. My classes are not really about Linux, git, Angular, jQuery, or express. They are about how to build applications using our core ideas:</p>
<p>Another important design principle not emphasized in this class is the <a href="http://www.oodesign.com/dependency-inversion-principle.html">Dependency Inversion Principle</a>.</p>
<p>Slide decks that might be useful:</p>
<ul>
<li>Agile Overview: <a href="http://bit.ly/1qf6V4t">http://bit.ly/1qf6V4t</a></li>
<li>Refactoring: <a href="http://bit.ly/elfrefactor">http://bit.ly/elfrefactor</a></li>
</ul>
<p>We will also spend a small amount of time studying:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Behavior Driven Development (BDD)</a></li>
</ul>
<p>As a general rule, these are the rules, ideas and guiding principles that make possible agile development:</p>
<ul>
<li><a href="http://www.agilemanifesto.org/">http://www.agilemanifesto.org/</a></li>
<li><a href="http://www.agilemanifesto.org/principles.html">http://www.agilemanifesto.org/principles.html</a></li>
</ul>
<h2 id="order-and-discipline">Order and Discipline</h2>
<p>If you don&#39;t need to be a genius in order to write good code, then what traits do you need? The short answer is that you need to be very well organized. If your tests, objects, modules, scripts and documents are well organized you don&#39;t need to be a genius to use them effectively.</p>
<p>It is not easy to get organized. In fact, it takes some special traits. Perhaps a list of such traits might look something like this:</p>
<ul>
<li>An orderly and logical mind</li>
<li>An obsessive concern for detail</li>
<li>A degree of patience that others consider a bit freakish</li>
<li>The ability to go inward, to work alone, in silence, for hours, combined with the ability to work with others on a team</li>
</ul>
<p>Good developers adopt or create systems for organizing their code, their tools, and their documents. Without this ability, developers tend to waste vast amounts of time, or fail altogether. The problem is that most developers don&#39;t see how important it is to work on developing good strategies for organizing code, scripts and documents. They always want to &quot;get on with it.&quot; The think, for instance, that adding a new feature is more important than writing a test or ensuring that an object is reusable.</p>
<p>Much of this book is about learning what organizational techniques are best. Whether the subject is writing tests, writing methods, writing objects, writing scripts, or storing files, we will always be looking for the best techniques and most effective way to organize our work. The theory is that these organizational skills can help us succeed.</p>
<p>However, even if you picked a terrible technique for organizing your code, and stuck with it, you might have a chance of succeeding. Even poor organization is much better than no organization. However, most good developers have a tendency to develop relatively efficient ways to organize their code and tools.</p>
<h2 id="be-practical">Be Practical</h2>
<p>Because we live in a consumer society, many Americans have a tendency to accumulate a lot of junk that is not really needed. This is fine until it comes time to clean up the house. It can be very difficult to create an orderly, neat home if it is filled with an endless array of consumer products.</p>
<p>So the day comes when we have to start throwing away, giving away, or selling the things that clutter our house. For most people, this is a difficult process. It takes very little creativity to find justifications for keeping even broken things that we haven&#39;t used in years. But eventually, the light must dawn, and we start to winnow. The best winnowers learn that having a few things that work, and that can be found, is much better than having hundreds of things, only some of which work, and most of which can&#39;t be found without a long search.</p>
<p>I&#39;m sure you see the analogy I&#39;m setting up. I&#39;m sure you can also come up with counter arguments. There are some programs that do just about everything and do it well. My suggestion, however, is that you adopt the clean house analogy to your programs: It is much better to write a small, simple program than a large complex program. If you really need additional features, consider creating a new program, or at least a completely pluggable module, that encapsulates the new functionality.</p>
<p>Almost all computer languages provide simple mechanisms for calling one program from another program. Most operating, systems, and especially Unix based systems, are designed to allow multiple programs to work in concert. The practical thing to do is create only small, simple programs that do only a few things.</p>
<p>Many times I have started writing a program, only to find myself bogged down in details that threatened to overwhelm me. To fight the chaos I began to strip layers of complexity. At times that meant I had to limit the features in my program, but frequently these features were not nearly as important as they were costly, or they could find a home in a second program. In the end, I ended up with a shorter, simpler program than the one I initially meant to write. But my program worked and my users liked it.</p>
<p>I was much better off with a robust program that worked, than with a flaky program that was cool but not reliable. And when users looked at my code, they rarely complained. It was
simple but robust. It is hard to criticize code that works!</p>
<p>A lot of good developers have missed their chance to create a useful or important program because they have added too many features or focused too much on writing
&quot;clever&quot; code that is fast and small, but which is also hard to debug, maintain and understand. Instead of focusing on speed and size, focus on the
following concepts, and others that will be developed throughout this text.</p>
<p>Write code that:</p>
<ul>
<li>Is easy to read and maintain</li>
<li>Contains only absolutely necessary features</li>
<li>Sacrifices features that will be used by only a small percentage of users</li>
<li>is aligned with best practices, especially those outlined by the Agile school
of development</li>
</ul>
<h1 id="part-ii">Part II</h1>
<p>Enough theory. Let&#39;s start writing code.</p>
<h2 id="introductionToJavaScript">Introduction to JavaScript</h2>
<p>Large parts of the web are driven by three related technologies: HTML, CSS and JavaScript. The differences between these technologies can blur at times, but the following assertions may help you understand the primary purpose of each component:</p>
<ul>
<li><strong>HTML</strong> files contain content such as text, bitmaps or videos</li>
<li><strong>CSS</strong> let&#39;s you define how the content should appear</li>
<li><strong>JavaScript</strong> allows you to perform actions that animate that content</li>
</ul>
<p>It is possible to completely scramble these rolls. You can put content in JavaScript files and use HTML to define the appearance of your content. It is not, however, good practice to do these things. I prefer to take a relatively hard line, and to insist that:</p>
<ul>
<li>Content, and content alone be placed in HTML files,</li>
<li>That appearance (font, bold, spacing, margins, etc) be specified only in CSS files</li>
<li>And that JavaScript be used only to perform actions.</li>
</ul>
<p>You will, on occasionl see me break the third rule, but the first two I adhere to except in cases where I want to prove a point, or illustrate a concept, rather than show how to write good code.</p>
<h2 id="helloWorldAtTheCommandPrompt">Hello World at the Command Prompt</h2>
<p>If you want to learn JavaScript, it can be helpful to start with a command line utility. To get started, install <a href="http://nodejs.org/">NodeJs</a>,
and run scripts from the command prompt:</p>
<ul>
<li><a href="/charlie/development/web/JavaScript/NodeJs.html">Node on Elvenware</a></li>
</ul>
<p>Other options include:</p>
<ul>
<li>Java: rhino</li>
<li>Windows: cscript and perhaps there is some kind of chakra command line tool.</li>
<li>Mac: JavaScriptCore</li>
</ul>
<p>Frankly, I know little of these alternative JavaScript or JavaScript-like engine. Nevertheless, I suggest that you stick with NodeJs unless you have specific reason to do otherwise. Obviously I&#39;m in no position to discuss their relative merits, but I am confident that NodeJs is both a very popular and well regarded solution. For instance, if you are interested in participating in the job market, circa 2016, NodeJs would be the obvious choice for server side or command line based JavaScript.</p>
<p>After installing node, create a simple source file like this one:</p>
<pre><code class="lang-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gettingStarted</span><span class="hljs-params">(count)</span> <span class="hljs-comment">{
    for (var i = 0; i &lt; count; i++) {
        console.log("I'm getting started");
    }</span>
}

<span class="hljs-title">gettingStarted</span><span class="hljs-params">(5)</span>;</span>
</code></pre>
<p>Save the file as <strong>getting-started.js</strong>. To run the program, type the following at the command prompt:</p>
<p>  node getting-started.js</p>
<p>for instance</p>
<pre><code>$ <span class="hljs-keyword">node</span> <span class="hljs-title">getting-started</span>.js
I'm getting <span class="hljs-literal">started</span>
I'm getting <span class="hljs-literal">started</span>
I'm getting <span class="hljs-literal">started</span>
I'm getting <span class="hljs-literal">started</span>
I'm getting <span class="hljs-literal">started</span>
</code></pre><p>That&#39;s all you need to node to start creating simple command line script that help you learn JavaScript. We will write many such programs, and expand considerably on these basics. I suggest you create such programs whenever you have feel the need to experiment with basic JavaScript syntax. Meanwhile, I&#39;m going to switch the focus to the browser, as that is still the primary platform for the JavaScript language. I just wanted to show you how to create simple JavaScript command line scripts because they are so useful when you are learning the language.</p>
<h2 id="helloWorldInTheBrowser">Hello World in the Browser</h2>
<p>JavaScript is, of course, most frequently seen running along with HTML and CSS in a browser.</p>
<p>In Listing 01 you can see a very simple &quot;Hello World&quot; HTML file that uses JavaScript. You can save this file as <strong>very-simple.html</strong>.</p>
<p>I stated earlier, that I do not like the practice of embedding JavaScript directly in an HTML file. Nevertheless, I&#39;m going to show you how it is done, if for no other purpose than to make clear exactly what I don&#39;t think you should do.</p>
<p><strong>Listing 01: Hello world in JavaScript.</strong></p>
<pre><code class="lang-javascript"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>     
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Very Simple<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"JavaScript intro"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"simple"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"simple"</span>).innerHTML = <span class="hljs-string">"A very simple JavaScript Hello-World program."</span>;    
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Just to be clear, the offending lines are the following:</p>
<pre><code class="lang-javascript"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"simple"</span>).innerHTML = <span class="hljs-string">"A very simple JavaScript Hello-World program."</span>;    
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>The call to <strong>getElementById</strong> and the reference to the <strong>innerHTML</strong> property are clear invocations of the JavaScript engine and thus should not be found in an HTML file. It may be a common practice, and there may even be occasions when this kind of syntax makes sense, but nevertheless, I&#39;m going to be quite dogmatic here and say that one should not embed JavaScript in an HTML file. Even if you see a great and highly respected writer or developer doing such a thing, you should simply cluck your tongue, shake your head, and murmur, perhaps not quite loud enough for anyone to hear: &quot;The shame. Oh, the shame.&quot; If you have trouble with this rule, consider it this way: You have, I&#39;m sure, been taught never to use <strong>goto</strong> statements. There are, in fact, occasions when it makes to use <strong>goto</strong> statements, but we nevertheless don&#39;t use them because we don&#39;t trust ourselves to use them correctly. In short, they form part of a slippery slope leading directly to the dark places never discussed in polite company. The same is true of embedding JavaScript in HTML. Yes, I too can see cases when it makes to do it, but I don&#39;t because &quot;<em>The road to hell is paved with goto statements and embedded JavaScript!</em>&quot;</p>
<p>After creating the saving the file shown above, navigate to it with a file explorer or some similar tool. Double click on it, or right click and choose <strong>Open with...</strong>. Because the file has an HTML extension, it should open automatically in a web browser or allow you to choose the browser in which you want to run it. Some browsers will also let you choose <strong>File | Open</strong> from the menu and browse for the file you want to open. If you are using Chrome, press <strong>Ctrl + O</strong> to open a file.</p>
<p>From the command prompt, navigate to the directory where you saved the file:</p>
<ul>
<li>One Windows try <strong>start very-simple.html</strong></li>
<li>On Linux try <strong>firefox very-simple.html</strong> or <strong>chromium-browser very-simple.html</strong></li>
</ul>
<p><img src="images/VerySimpleJavaScript.png" alt="Very Simple JavaScript file"></p>
<p><strong>Figure 01: The very-simple.html file running in Chrome.</strong></p>
<p>You can see the path to the file in the address bar. This is a normal Windows path with slashes rather than back-slashes. Notice also that it is prefaced with the code <strong>file:///.</strong>. Later you can learn how to set up a web server to publish your code, but for now, it is fine to just browse for the file on your hard drive.</p>
<h2 id="discreet-javascript">Separating HTML and JavaScript</h2>
<p>By now you understand that embedding JavaScript in an HTML file is a dangerous practice, like experimenting with crack or opiates. So how can we separate our HTML and JavaScript? The solution is simple.</p>
<p><strong>Listing 03: The very-simple-02.html file</strong></p>
<pre><code class="lang-javascript"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>     
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Very Simple<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"JavaScript intro"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"very-simple.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"simple"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>Listing 04: The JavaScript file: very-simple.js.</strong></p>
<pre><code class="lang-javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"simple"</span>).innerHTML = <span class="hljs-string">"A very simple JavaScript Hello-World program."</span>;
}
</code></pre>
<p><strong>Note: You can download this sample from <a href="http://www.elvenware.com/charlie/downloads/VerySimple.zip">here</a>.</strong></p>
<p>When running the code in Listings 03 and 04, you should be sure to put both files in the same directory. For instance, you may have a folder called <strong>C:\Source</strong> or <strong>~/Source</strong> where you store your source files. Put both files in that directory:</p>
<pre><code>Source/very-simple-<span class="hljs-number">02</span><span class="hljs-selector-class">.html</span>
Source/very-simple.js
</code></pre><p>Run this program just as you did the first example. Alternatively, you can see it in action here:</p>
<ul>
<li><a href="http://bit.ly/very-simple">http://bit.ly/very-simple</a></li>
</ul>
<p>The key line of code is the HTML file is this one:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"very-simple.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>This instructs the browser to load the <strong>very-simple.js</strong> file into memory where it can be executed by the browser&#39;s JavaScript engine. For instance, in Chrome it will be executed by the V8 engine, in Firefox by the SpiderMonkey engine, and in Edge or IE by the chakra engine.</p>
<p>This bit of JavaScript code scans through the HTML file and returns a handle to the paragraph element that his the ID <strong>simple</strong>:</p>
<pre><code class="lang-javascript">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"simple"</span>)
</code></pre>
<p>To this we add the following, which inserts some text into the paragraph:</p>
<pre><code class="lang-javascript">.innerHTML = "<span class="hljs-keyword">A</span> very simple JavaScript Hello-World program."<span class="hljs-comment">;</span>
</code></pre>
<p>We could have also written the following:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> simpleParagraph = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"simple"</span>);
    simpleParagraph.innerHTML = <span class="hljs-string">"A very simple JavaScript Hello-World program."</span>;
}
</code></pre>
<p>Both code sample do the same thing, only one is a bit shorter.</p>
<p>Note that we also make a call to <strong>onload</strong>. We do this to be sure that the HTML that contains our <strong>simple</strong> paragraph element is loaded before the HTML is executed.</p>
<h2 id="best-practices">Best Practices</h2>
<p>It is a good practice to always separate your HTML code into three files:</p>
<ul>
<li>Put your content in HTML files with an HTML extension: MyFile.html</li>
<li>Put your presentation code in CSS files with a CSS extension: MyFile.css</li>
<li>Put your JavaScript in JavaScript files with JS extension: MyFile.js</li>
</ul>
<p>If you need to use the same CSS or JavaScript in multiple HTML files,
then it is obvious that it is best to put that CSS or JavaScript in a
separate file. Otherwise, you would be forced to endlessly repeat the
same code in multiple HTML files. Then, if you wanted to fix a bug in
your JavaScript or CSS, you would need to fix it in each HTML file that
included the code. In a large web site, that might mean you would need
to edit thousands of HTML files just to make one simple fix.</p>
<p>But suppose you CSS or JavaScript that you only wanted to use in one
file? Why should you split them up into three files? Wouldn&#39;t it mean
that:</p>
<ul>
<li>Your code ran faster because there would be one download instead of
3?</li>
<li>It would be easier to make sure that code that belonged together
never got separated?</li>
</ul>
<p>The answer to both these questions is yes. And still, despite these
arguments, I think you should always separate your code out into three
files. I believe this for the following reasons:</p>
<ul>
<li>It promotes good habits</li>
<li>More often than you think, there will come a time when you will want
to use the CSS or JavaScript in a second HTML file. If it is not
already split out into multiple files, then you will get lazy and
copy it from one file to another, ending up with duplicate code.</li>
<li>Ultimately, it is easier to write good clean, easy to read, and easy
to maintain code if you don&#39;t mix different types of source in a
single file</li>
<li>And finally, there are tools that can be run over HTML files before
you release them that will automatically consolidate them into a
single file.</li>
</ul>
<p><em>NOTE: This last point is not really as good an argument as it sounds.
Ultimately, I believe you are better off with a maintainable code base
that runs a bit slow, than you are with a fast code base that is
impossible to understand, maintain or improve. Furthermore, most
developers who try to optimize their code end up spending hours, days,
or even months fussing with code in order to save milliseconds that the
user never notices. The rule you want to follow is simple: unless you
can see obvious, and certain, proof that you have a performance problem,
you should not waste time trying to optimize your code. Instead, focus
on writing clean code that is easy to maintain. One thing we know for
certain: users always prefer code that works and has the right features
to code that does not work and lacks key features. If you write messy,
hard to maintain code, you will nearly always find it harder to add
features to that code base than it is to add features to well written
programs.</em></p>
<h2 id="theCaseOfFileNames">The Case of File Names</h2>
<p>I should say a word about the case of the file names I create. There are
six different ways to name files, three of which are wrong, and three of
which are right:</p>
<ol>
<li>file01.html</li>
<li>vrysmpl.html</li>
<li>verysimple.html</li>
<li>very_simple.html</li>
<li>very-simple.html</li>
<li>VerySimple.html</li>
</ol>
<p>The first example is wrong because the name has no meaning: it tells you
nothing about the contents of the file. The second name is wrong because
it contains abbreviations. Twenty years ago developers used
abbreviations to save space on machines where memory or hard drive space
was scarce, or where operating systems did not support names with more
than 8 characters. This is no longer necessary for a variety of reasons,
and now abbreviations are merely a sign that developers are too lazy to
type out the whole word. (To every rule, there are exceptions, and there
are occasions when the code in very short methods is easier to read when
it makes use of abbreviations. But those are the exceptions to a good
rule, and there is rarely a case where any good is accomplished by
showing newcomers such shortcuts.) The third example is wrong because it
provides no means of helping the reader to separate out the face that
<strong>verysimple</strong> is a name consisting of two words.</p>
<p>The fourth example is correct, but is now considered a bit old
fashioned. Most people prefer using a dash, rather than an underscore,
because they believe it is easier to type. In either case, the basic
strategy is good, because there are no abbreviations, and the words are
cleanly separated. The whole issue of case is moot in this strategy,
since all letters are rendered in lower case. The last example is the
one I prefer, because it is most familiar to me, and I find it easier to
read a long list of names rendered in this format. It uses Pascal
casing, where multiword names are run together into one name, and each
word in the name begins with a capital letter.</p>
<p>NOTE: One good argument from the folks who prefer using dashes to using
Pascal casing runs as follows. Suppose you have a common acronym such as
IBM. Perhaps you have method from IBM that performs fast addition. You
would want to call this method <strong>IBMFastAddition</strong>. This name runs the
words IBM and Fast together into one name and thereby breaks an
important rule about clearly delineating the words in a name. I
therefore would name this method <strong>IbmFastAddition;</strong> now we can clearly
see that Ibm is meant to be treated as a discreet unit. In fact, I
always treat acronyms this way: I capitalize the first letter and put
the other letters in lower case. This system works, but some find it
less than optimal. If you used dashes, you could write something like
this instead: <strong>ibm-fast-addition</strong>. This is arguably easier to read
than the Pascal casing example. But I don&#39;t find so terribly much
difference, and sometimes I think Pascal casing is easier to read. For
instance, I think <strong>SimpleHtmlToElvenwareConverter</strong> is easier to read
than <strong>simple-html-to-elvenware-converter</strong>. But gosh, it is a silly
thing to get upset about. I distrust anyone who gets overly excited
about such issues. I think even great programmers, such as Douglas
Crockford, do little more than display their rare blind spots when they
get overly exercised over issues that so clearly are more matters of
taste than of science. In fact, I have seen people foolishly ignore
Crockford&#39;s many strengths because he is so obviously overly zealous in
this one area. He&#39;s doing more harm to himself than good by being so
narrow minded.</p>
<p>Ultimately, the choice you make between the last three &quot;correct&quot;
examples is a matter of personal taste. There are only two primary
caveats you need to keep in mind:</p>
<ul>
<li>Whatever strategy you pick: stick with it! Once you have decided on
a strategy then you, and everyone who works with you, must stick to
that strategy in all the code you produce.</li>
<li>If you go to work for a shop that has already adopted a strategy,
then you must happily conform with it. A good manager will work with
you, and have patience while you come to see the error of your ways.
Bad managers will simply make your life miserable until you either
come to your senses or move on. In either case, there is no question
that it is irrational and counter productive to create code that
uses a style that does conform to the needs of the others in your
group.</li>
</ul>
<p>The case of a file name is one thing, but the case of formatting code in
a source file is a different matter. Almost all languages have an agreed
upon style of casing, indentation, etc. You should make a real effort to
discover the strategy for the language you are using, and to follow it
as best you can. In this document, I attempt to follow the standards for
formatting JavaScript code. With a few minor exceptions, if you see me
vary from what you consider to be the best strategy for formatting
JavaScript, then please send me email and let me know. My goal is to
conform to the standards set by the JavaScript community. If I want to
assert my individuality, I wrote prose or poetry; when I write code, I
try to conform to standards. The only case for individuality in code is
the case for writing the cleanest, easiest to understand code of any
developer on your team. There is no place for a quirky style of
capitalization or indentation.</p>
<h2 id="client-server-js">Client Side, Server Side</h2>
<p>JavaScript has one set of rules when run in a browser, and another set when run outside a browser. There are, therefore, two distinct flavors of JavaScript discussed in this text.</p>
<ul>
<li>Client side JavaScript implemented by the various browser makers:<ul>
<li>In Chrome and Chromium: We use the Chrome V8 Javascript Engine</li>
<li>In Firefox we use the SpiderMonkey JavaScript engine</li>
<li>Safari uses JavaScriptCore, aka as Nitro, SquirrelFish and SquirrelFish Extreme</li>
<li>Chakra is the JavaScript engine in IE and Edge</li>
</ul>
</li>
<li>Server Side<ul>
<li>Most server side JavaScript code is written with NodeJs, which uses the Chrome V8 Engine.</li>
</ul>
</li>
</ul>
<p>The big gap here is between client side and server side code. Even though the V8 engine is used in both Chrome and NodeJs, the code you write on the server side is often quite different from the code used in a browser. It is not that JavaScript syntax changes, but rather than the available libraries are so different, and the techniques for loading JavaScript code are so different, that one needs a different mind set when writing NodeJs code and writing client side code.</p>
<p>As a rule, you need no longer concern yourself too much with the difference between the various browsers. Client side code needs to be tested in all browsers, but you should be able to craft code that works in all browsers so long as you approach the matter carefully and methodically. In particular, judicious use of libraries such as jQuery can help you write client side code that works in all browsers.</p>
<p><strong>NOTE</strong>: <em>I should probably qualify what I say above. The basic syntax of the language does not change when you switch from a browser to the server. The only exception, of course, is when a browser has a buggy implementation of JavaScript, and that still happens, though less frequently than it did several years ago.) But even when everything works correctly, certain key features of the language, such as the <strong>this</strong> keyword, have a different significance inside a browser and outside a browser. Also, key elements of the client side API, such as the <strong>alert</strong> function, are not typically available by default on the server. In general, I think it is easier to move from the browser to <strong>nodejs</strong>, than it is to move from <strong>nodejs</strong> to the quirky world of browsers.</em></p>
<p>The code you saw in the previous section provides a
good framework for beginning and intermediate level JavaScript
programmers who want to learn more about the language. Start out by
opening up code similar to what you see in Listing 3 and 4. As a matter
of fact, you can simply reuse VerySimple.html over and over again. As we
explore the JavaScript language, all you need do is change the name of
the JavaScript file that you are linking in. For instance, linking
VerySimple01.js for one program, then VerySimple02.js for the next
program. Better yet, follow best practices and rename each JavaScript
file to reflect its contents. For instance, ExploringLoops.js would be a
good name for a JavaScript file that you created when you wanted to
learn about how loops are written in JavaScript.</p>
<p>Before leaving the subject of how to structure your code, there is one
last subject to cover. A key tool developers use when debugging their
code, and when they are exploring JavaScript, is a call to
<strong>console.log</strong>:</p>
<pre><code class="lang-%7B.code%7D">console.log(<span class="hljs-comment">"This is a a debug message"</span>);
</code></pre>
<h2 id="console.Log">Console.Log</h2>
<p>You can use console.log to log debug information.</p>
<pre><code>console.log(<span class="hljs-symbol">'This</span> line <span class="hljs-keyword">of</span> code executed');
</code></pre><p>If you run your JavaScript in a browser, then use the Browser&#39;s debugger to
view the results. For instance, in Chrome, press F12 to bring up the
Developer Tools. Then turn to the <strong>Console</strong> page. If you are using a
command line tool like <strong>node</strong>, then you can see the results at the command
line itself.</p>
<p>Suppose you are a beginning level JavaScript programmer who wants to
learn how to write a function that adds numbers. Now it is a good and
admirable thing to want to design an HTML file that will allow the user
to enter numbers, push a button, and display the result of an operation
on those numbers. However, in this life there is a time for everything,
and lets suppose that right now you don&#39;t want to focus on inputting or
displaying numbers: you just want to write a method called <strong>add</strong>and
see if it works. Here is how you can use console.log to help you
reach your goal.</p>
<p>Begin your the same basic HTML file described above:</p>
<p><strong>Listing 05: The HTML File</strong></p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Very Simple<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"calculator.js"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>As you can see, the code shown in Listing 5 is similar to the code found
in Listing 3. The only difference is that the source file linked in is
called <strong>Calculator.js</strong> rather than <strong>VerySimple.js</strong>. Here is the code
for <strong>Calculator.js</strong>:</p>
<p>Listing 06: Code that uses console.log.</p>
<pre><code>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{  
      <span class="hljs-keyword">var</span> sum = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
      <span class="hljs-built_in">console</span>.log(sum);
    };
</code></pre><p>Launch your HTML file in Chrome. Press F12 or Ctrl-Shift+I to open the
Developer Tools and turn to the console page. You should see the output from
any of your console.log statements in the console window. Note also that the
console window allows you to add arbitrary statements that will be run
against the JavaScript on your page.</p>
<p><a href="images/Console01.png"><img src="images/Console01Small.png" alt="Console Window"></a></p>
<p><strong>Figure 0X</strong>: The Chrome JavaScript Console window.</p>
<p>In the screen shot, you can see the output of the call to <strong>console.log</strong>.
I have also used the Chrome console window to explicitly type in some
code:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">12</span>)</span></span>
</code></pre><p>After typing this code, my JavaScript method is called, and the result of the
call to the <strong>add</strong> method is shown. This technique can be used to help you
debug your JavaScript code without having to create an interface for your program.</p>
<p>Note: You can also use
<a href="http://elvenware.com/charlie/development/web/UnitTests/">qUnit</a> to write
unit tests that can help you debug your code. I typically use both
<strong>console.log</strong> and <strong>qUnit</strong>. However, if I were forced to choose between the two
techniques, then I would choose <strong>qUnit</strong> or some other unit test framework. I
am not forced to make that decision, so I use console.log and qUnit. But if
I were forced to choose, I would choose unit testing over logging.
Ultimately, unit testing is a more robust solution. In particular, it is
easy to automate unit tests, while there is no simple way to automate
checking the results of calls to <strong>console.log</strong>. You can visually confirm the
results, but that is not that same as getting an automated error report such
as you get from <strong>qUnit</strong>.</p>
<h2 id="learnMore">Learn More</h2>
<p>Here is a rendering of the hidden code that prints the first two lines
found on this page:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
 <span class="hljs-built_in">document</span>.writeln(<span class="hljs-string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);
 <span class="hljs-built_in">document</span>.writeln(<span class="hljs-string">"&lt;p&gt;These lines written using JavaScript.&lt;/p&gt;"</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><p>This code changes the page you are viewing by inserting two lines of
text when the document loads. Because the change occurs as the document
is first loaded, you are not aware that an action is being performed.
Nevertheless, this is a dynamic event, and not a static rendering of
text as you see in standard HTML. For a more dynamic example of how
JavaScript can change the appearance of a page, see the next section,
called Insert Adjacent HTML.</p>
<p>The code shown above is embedded in this document directly below the
caption that reads <strong>JavaScript Basics</strong>. Right click this document and
choose <strong>View Source</strong> to see it.</p>
<p>NOTE: <em>It is important to understand that the text you see above is not
the actual code that gets executed. The real code is inside this HTML
page, but hidden from view. Whenever you include an angle bracket: \&lt;>
in your HTML, then the words inside those brackets are called a tag, and
they become hidden from view when the page is rendered in a browser. In
this case, all the words between the opening \<script\> and closing
\</script\> tags are considered part of the script tag, and are hidden
from view. To show an angle bracket to the reader of an HTML page, you
write the following code: <strong>\&lt;</strong> or <strong>></strong>. The first bit of code is an
open angle bracket, and the second a close angle bracket. HTML is pretty
simple and straight forward most of the time, but this is one of those
places where it can be a bit hard to understand what is going on if you
are a newcomer. Nothing will better help you grasp these concepts than
actually getting your hands dirty and writing some code. Sometimes you
can learn best by doing.</em></p>
<p>Install the JavaScript ChromeTools Debugger in Eclipse:</p>
<p><a href="http://code.google.com/p/chromedevtools/wiki/HowToInstall">http://code.google.com/p/chromedevtools/wiki/HowToInstall</a></p>
<h2 id="theRightTools">The Right Tools</h2>
<p>There are some wonderful tools out there for developing big applications with HTML and JavaScript. Three that I use frequently are Eclipse/Aptana, and WebStorm.</p>
<p>If you are writing the kind of simple program needed to follow along with this text, however, I think it is simplest to use the following tools:</p>
<ul>
<li><a href="https://www.geany.org/">Geany</a></li>
<li><a href="https://www.google.com/chrome/browser/desktop/">Chrome</a></li>
<li><a href="https://nodejs.org/en/">NodeJs</a></li>
<li>notepad++</li>
</ul>
<h2 id="the-right-books">The Right Books</h2>
<p>Good books to read on JavaScript.</p>
<ul>
<li><a href="https://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680"><strong>Maintainable JavaScript</strong></a>, by Nikalas Zakas, the author of <strong>JavaScript for Web Developers</strong>. MJ is a short book that is easier to read than JGP, but which follows much of the advice found in Crockford&#39;s book.</li>
<li><a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>. A general purpose guide to writing good code.</li>
<li><a href="https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/1617292850"><strong>Secrets of the JavaScript Ninjas</strong></a> by jQuery&#39;s John Resig is an excellent book. A bit heavy going in places, but full of excellent advice.</li>
<li><a href="http://eloquentjavascript.net/">Eloquent JavaScript</a>: An in depth look at the language available <a href="http://eloquentjavascript.net/">on the internet</a>.</li>
<li>A difficult but valuable book is <strong>JavaScript the Good Parts</strong> by Douglas Crockford. It is a tough read, but it is the pivotal book about JavaScript that taught everyone how to properly use the language.</li>
<li><a href="https://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527">JavaScript, the Definitive Guide</a> by David Flanagan. Considered <em>the</em> book on JavaScript by many, but I find Zakas easy to understand and the Ninja book to have more depth. But still an important and useful book.</li>
<li><a href="https://www.amazon.com/Principles-Object-Oriented-JavaScript-Nicholas-Zakas/dp/1593275404">The Principles of Object Oriented JavaScript</a> by Nikalas Zakas. If you wish JavaScript were C#.... Includes numerous insights into how JavaScript is structured. I couldn&#39;t put it down.</li>
</ul>
<p>This might also be of some help:</p>
<p><a href="http://www.elvenware.com/charlie/development/web/JavaScript/">http://www.elvenware.com/charlie/development/web/JavaScript/</a></p>
<p>And here are the two &quot;home pages&quot; for web development:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">Mozilla Developer Network</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/javascript?sort=frequent&amp;pageSize=15">Stack Overflow</a></li>
<li><a href="http://www.hanselman.com/blog/StopSayingLearningToCodeIsEasy.aspx">Stop Saying Coding is Easy</a></li>
</ul>
<p>I also want to read <strong>JavaScript Patterns</strong> by Stoyan Stefanov and I am currently reading <strong>Functional JavaScript</strong>. The latter book is very good, but perhaps too advanced for most of us.</p>
<ul>
<li><a href="https://developers.google.com/events/io/">Google IO</a></li>
<li><a href="http://hanselminutes.com/">Scott Hanselman</a></li>
<li><a href="http://stackoverflow.com/questions/409056/top-rated-javascript-blogs">JavaScript Blogs</a></li>
<li><a href="http://net.tutsplus.com/articles/web-roundups/30-developers-you-must-subscribe-to-as-a-javascript-junkie/">33 Developers to follow</a></li>
</ul>
<h2 id="some-caveats">Some Caveats</h2>
<p>Having laid out the goals and principles on which we shall be working, I think it is important to make some additional points.</p>
<p>Some advanced students will find points in my text where they might think:
&quot;Hey, I know a better way to do that! My way uses less code, or my way saves
10 clock cycles.&quot; All that is good and well, but is the code that you
propose also both maintainable and easy to understand? Are you sacrificing
maintainability on the alter of speed? In some cases, I may in fact know
about that &quot;better way,&quot; but I have chosen to stick to a simple, easier to
understand syntax in order to teach people how to write robust, easy to
maintain code. Saving ten clock cycles simply is not worth it if the techniques involved prevent average developers from learning how to write and maintain a complex program.</p>
<p><strong>NOTE</strong>: <em>Of course, there will be cases where there really will be
a simpler and easier way to do something than the one I show. If you think
you have found a better way to do something, then please write me and let me
know. Before you write, however, consider whether your code is not only
small and fast, but also easy to read, and easy to maintain. For me, these
virtues are more important than brevity or performance. This does not mean
that I don&#39;t take brevity and performance into account, but only that they
are not my first priority.</em></p>
<p>I believe many of these developers are quite capable of creating good
programs that would meet their own needs and the needs of most users.
However, they never achieve their goals because they are too focused on
performance. In short, they are aiming to high. They want to make their code
impossibly fast, and end up creating programs that no one, not even
themselves can maintain. As a result, they fail. My goal is to define a
style of programming that can help these developers achieve their goals.</p>
<h2 id="some-links">Some Links</h2>
<p>Consider using a JavaScript style guide:</p>
<ul>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml">http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml</a></li>
<li><a href="http://contribute.jquery.org/style-guide/js/">http://contribute.jquery.org/style-guide/js/</a></li>
<li><a href="https://github.com/rwldrn/idiomatic.js/">https://github.com/rwldrn/idiomatic.js/</a></li>
</ul>
<h2 id="news-links">News Links</h2>
<ul>
<li><a href="http://www.google.com/search?q=javascript+news">http://www.google.com/search?q=javascript+news</a></li>
<li><a href="http://www.google.com/search?q=web+app+development+news">http://www.google.com/search?q=web+app+development+news</a></li>
<li><a href="http://www.google.com/search?q=node+js+news">http://www.google.com/search?q=node+js+news</a></li>
</ul>
<h2 id="blog-links">Blog Links</h2>
<ul>
<li><a href="http://www.google.com/search?q=javascript+blogs">http://www.google.com/search?q=javascript+blogs</a></li>
<li><a href="http://www.google.com/search?q=web+app+development+blogs">http://www.google.com/search?q=web+app+development+blogs</a></li>
</ul>
<h2 id="microsoft">Microsoft</h2>
<p>Also, if you end up in the Microsoft world, read and listen to everything that these two people say:</p>
<p>Anders:</p>
<ul>
<li><a href="https://twitter.com/ahejlsberg">https://twitter.com/ahejlsberg</a></li>
<li><a href="https://channel9.msdn.com/events/speakers/Anders-Hejlsberg">https://channel9.msdn.com/events/speakers/Anders-Hejlsberg</a></li>
</ul>
<p>Mads:</p>
<ul>
<li><a href="https://twitter.com/madstorgersen">https://twitter.com/madstorgersen</a></li>
<li><a href="https://channel9.msdn.com/Events/Speakers/Mads-Torgersen">https://channel9.msdn.com/Events/Speakers/Mads-Torgersen</a></li>
</ul>
</div></body></html>