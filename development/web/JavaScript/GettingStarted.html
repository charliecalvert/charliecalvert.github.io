<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>GettingStarted</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap-theme.min.css"><!-- link(href='/libs/css/BootstrapIndex.css', rel='stylesheet', type='text/css')--><link href="/css/style.css" rel="stylesheet" type="text/css"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><script src="/components/jquery/dist/jquery.js"></script><script src="/components/angular/angular.js"></script><script src="/components/angular-route/angular-route.js"></script><script src="/components/bootstrap/dist/js/bootstrap.min.js"></script><!-- script(src='/libs/scripts/elvenware.js', type='text/javascript')--><!-- script(src="/libs/scripts/Control.js")--><!-- script(src='http://localhost:35729/livereload.js')--></head><body><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/about">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/development/index.html">Strongly Typed</a></li><li><a href="/development/web/index.html">Web & Scripts</a></li><li><a href="/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>GettingStarted</h1><p>Welcomes to GettingStarted</p><ul><!--TOC_Start--><li><a href="#chapter-01-introduction">Chapter 01 - Introduction</a></li>
<li><a href="#general-considerations">General Considerations</a></li>
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#arrogance">Arrogance</a></li>
<li><a href="#style-guide">Style Guide</a></li>
<li><a href="#refactoring">Refactoring</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#design">Design</a></li>
<li><a href="#guidelines">Guidelines</a></li>
<li><a href="#order-and-discipline">Order and Discipline</a></li>
<li><a href="#be-practical">Be Practical</a></li>
<li><a href="#part-ii">Part II</a></li>
<li><a href="#introductionToJavaScript">Introduction to JavaScript</a></li>
<li><a href="#helloWorldAtTheCommandPrompt">Hello World at the Command Prompt</a></li>
<li><a href="#helloWorldInTheBrowser">Hello World in the Browser</a></li>
<li><a href="#theCaseOfFileNames">The Case of File Names</a></li>
<li><a href="#aSimpleJavaScriptDevelopmentStrategy">A Simple JavaScript Development Strategy</a></li>
<li><a href="#console.Log">Console.Log</a></li>
<li><a href="#learnMore">Learn More</a></li>
<li><a href="#theRightTools">The Right Tools</a></li>
<li><a href="#the-right-books">The Right Books</a></li>
<li><a href="#some-caveats">Some Caveats</a></li>
<li><a href="#some-links">Some Links</a></li>
<li><a href="#news-links">News Links</a></li>
<li><a href="#blog-links">Blog Links</a></li>
<li><a href="#microsoft">Microsoft</a></li><!--TOC_End--></ul><h1 id="chapter-01-introduction">Chapter 01 - Introduction</h1>
<p>This chapter covers general development strategies. The chapter focuses on JavaScript and related tools but much of what is said applies to all computer languages. Beginners will learn enough to get started, more experienced developers can read this text to learn about the approach to learning used in this on=line book. After reading this chapter, you can move on to the more practical, hands-on chapter called <a href="JavaScriptsBasics.html">JavaScript Basics</a>.</p>
<h2 id="general-considerations">General Considerations</h2>
<p>This book covers JavaScript basics. Our primary goal will be to teach intermediate level developers how to write testable, maintainable, well-structured code.</p>
<p>Most developers who complete beginning level courses can:</p>
<ul>
<li>declare variables</li>
<li>write loops</li>
<li>branch on logical statements or operators</li>
<li>compose functions and pass values to them and from them.</li>
</ul>
<p>These fundamental tasks are essential, and must be mastered before we can move on to learning many of the lessons that form the core of this book. I will show how these tasks are performed using the JavaScript language, but that is not the focus of this text.</p>
<p>Once we know the basics, we need to learn how to properly structure our code. The best programmers take pride in their code. They want to write code that works, of course, but more importantly, they want to write code that is easy to understand and easy to maintain. In particular, they want to create code that is:</p>
<ol>
<li>Testable</li>
<li>Maintainable</li>
<li>Reusable</li>
<li>Robust</li>
<li>Fast enough</li>
</ol>
<p>Order here is important. Nearly every method or function we write should be, before everything else, testable. Once we can test it, then we can refactor it so as to make it more maintainable, reusable and robust. We also refactor our code to make it more readable.</p>
<p>Good code:</p>
<ul>
<li>Has carefully chosen identifiers</li>
<li>Is well formatted</li>
<li>Divided into short, testable functions</li>
<li>Organized in well designed modules</li>
<li><p>Designed in accordance with basic programming guidelines such as:</p>
<ul>
<li>Loose coupling</li>
<li>The Single Responsibility Principle</li>
<li>The Open Closed Principle</li>
</ul>
<h3 id="philosophy">Philosophy</h3>
<p>I want, perhaps above all other things, for this text to be comprehensible. Too many books are clever rather than clear. Any developer should be able to read this text and understand what it teaches about the art of development.</p>
<p>This book is aimed at a particular niche:</p>
<ul>
<li>Helping intermediate level programmers learn to create programs that work</li>
<li>Helping intermediate developers be prepared to learn how to become, or how to work with, expert developers</li>
</ul>
<p>My goal is not to teach advanced development skills. There are other books, and other authors, who already do a fine job with that task. Instead, I want to show developers that there is more to programming that simply writing loops, branch statements, and calling functions. Too many developers are stuck at the intermediate level because they don&#39;t have the knowledge needed to understand expert books, strategies and algorithms. This book is designed to take an ordinary developer and teach them the perspective of a master developer. Once they understand the difference between learning the basics, and mastering proper application design, then they will be able to move forward in their careers. Even if they never become experts themselves, they will be skilled enough to work on advanced teams that develop interesting and important projects.</p>
<p>String analytic and logical ability is a plus in the programming profession. Some developers are both be skilled at their craft, and also creative. Unfortunately, many other people with a strong creative bent lack the analytic skills necessary to help them write good code and bring their ideas to fruition. One of my goals is to help people like this succeed. If you have a creative bent, but are having trouble bringing your ideas to fruition in code, then hopefully this text will prove useful to you.</p>
<p>Some great jazz musicians such as Miles Davis and Pat Metheny are not considered to be the best in their field from a purely technical perspective. Instead, they tend to combine a strong creative bent with solid skills and an intense work ethic.</p>
<p>It is not always purely technical skill alone that counts. Some great authors, Theodore Dreiser, Sinclair Lewis, and Upton Sinclair come to mind, were not great stylists. Instead, they were creative and hard working.</p>
<p>Your discipline, creativity, business smarts, or ideas will never be worth anything if you can&#39;t bring your idea to fruition. My goal is to teach a manner of programming that people of &quot;average&quot; talent can use to help them accomplish their goals.</p>
</li>
</ul>
<h3 id="performance">Performance</h3>
<p>“Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.” — Donald Knuth in &quot;Structured Programming with Go To Statements&quot;</p>
<p>In general, I am not interested in performance issues. I&#39;ve taught hundreds of students, and I have found that it is very rare for them to write code that is too slow. It is, however, common for them to write code that is buggy and overly complex.</p>
<p>If you do have a performance problem, use a profiler to measure performance and find the slow spots. Then review your architecture and see if there are ways to speed things up.</p>
<p>In general, however, it is not performance that causes intermediate level programmers to fail. Students fail to complete projects, or write projects that are overly buggy, because they fail to properly craft their code.</p>
<p>Well written code is easy to understand, easy to test and easy to maintain. It should also be efficient code, but it need not be the most efficient code possible.</p>
<p>It simply does not matter how fast your code is if it doesn&#39;t work and can&#39;t be tested. The first goal is to write clean, easy to maintain code that can form the building blocks for our tests and for a working program.</p>
<p>We should not concern ourselves with performance issues unless we hit a specific problem with execution time. In most cases, it is developer time that is at a premium. One loop may execute 5 nanoseconds faster than another, but no one is likely to notice such tiny delays. But everyone notices if a project is behind schedule. So don&#39;t focus on performance, focus on writing clean, easy to maintain code. We want to finish the project first, then we can, on the rare occasions when it is necessary to do so, see if performance can be improved.</p>
<p>For the kinds of assignments most programmers encounter in their careers, performance bottlenecks are of concern only in rare cases. For most developers, especially beginner and intermediate developers, the big priority is learning to write good code that is easy to understand and easy to maintain. Code that helps us bring the project to completion is what we want. That it may be a few clock cycles slower or faster at run time is rarely a concern.</p>
<p><strong>NOTE</strong>: <em>I recognize that some projects, such as the core modules of an OS or compiler code generation, are very much concerned with even small performance issues. My argument here is not that there are no cases where performance is important, but only that it is generally not a high priority for typical programming assignments.</em></p>
<h2 id="arrogance">Arrogance</h2>
<p>Arrogance stalks through the ranks of modern programmers like the plague in medieval Europe. It is not only a boorish and unattractive trait, but it also causes much damage.</p>
<p>There is nothing more pathetic than a poor developer who loses a job because they are too arrogant to accept even simple tips on how to write better code. It&#39;s one thing to lose a job due to lack of skill, and another to lose it because you reject the principles of good application development out of sheer arrogance. The developer who is too &quot;intelligent&quot; to learn is a developer who will likely have a very short, or highly underpaid, career.</p>
<p>Here are some of the things that I hear from arrogant developers who simply don&#39;t have the sense to see how much they still need to learn:</p>
<ol>
<li>My code doesn&#39;t need to be tested.</li>
<li>I don&#39;t need to modularize or structure my code.</li>
<li>Properly formatting my code is a waste of time.</li>
<li>I have my own system for formatting code, the team guidelines don&#39;t apply to me.</li>
<li>Other people can&#39;t understand my code not because its a mess, but because they are dumb.</li>
<li>Language X is stupid, my favorite language is brilliant.</li>
<li>My platform, my OS, my version of my OS, is the only great development environment, everything else is junk.</li>
<li>I don&#39;t need Git, I&#39;ve backed up all my code on a thumb drive.</li>
<li>One letter identifiers make my code shorter and easier to read.</li>
<li>I don&#39;t need to refactor my code.</li>
</ol>
<p>If you think things like this even though others have warned you of the danger, then you probably need to examine your assumptions.</p>
<p>In some cases you may in fact be very talented and yet narrow minded in some particular area. A blind spot may obscure your view of facts that others find easy to recognize. A classic example of such a person would be Eric Raymond, who is guilty of the OS chauvinism listed above. Of course, Eric Raymond is so talented, so hard working, and so knowledgeable that he can afford to burden himself with a few glaring flaws. The odds that you are equally talented are vanishingly small. In Raymond&#39;s case, one could even argue that he turned his weakness into a strength. His over the top support of Unix lit the fire in his belly that helped him produce some very important books.</p>
<p>In programming, as in many areas of life, it is the people who mistakenly think they know a lot who are most dangerous. In most, but not all, cases, good developers are humble developers. Arrogance is usually a sign of ignorance. Most arrogant people lack the self-knowledge necessary to see their own flaws.</p>
<p>There are only a few great programmers who have valid reasons to be arrogant. The best of them usually have the grace to at least try to hide their high opinion of themselves. They know arrogance is a flaw, not a virtue.</p>
<p>The classic arrogant programmer is not only conceited, but also:</p>
<ul>
<li>Truly too ignorant to see the depth of his own weakness</li>
<li>Lacking insight into his own personality</li>
<li>Morally incapable of telling the difference between a virtue like humility, and a flaw like arrogance</li>
</ul>
<p>Such people are frequently, unemployed, underemployed or underpaid. Just remember, if you really are the Michael Phelps or Paul McCartney of programming, it is odd that no one but you recognizes the fact. Certainly it is odd that you are good developer if you have not written at least one acknowledged great piece of code.</p>
<p>But don&#39;t despair. You may not be genius, but you probably are smart enough to get a good job at good pay. The first step is to drop the attitude. Once you become teachable, then you can begin to learn new, valuable, skills that are needed in the workplace.</p>
<h2 id="style-guide">Style Guide</h2>
<p>My goal, then, is to teach people with average abilities to write good code. I picture the average reader of this material as being someone who likes to program, who likes technology, but who did not necessarily test at the top of their class.</p>
<p>Most people who become interested in programming are fairly intelligent. People who don&#39;t have good logical skills simply never get far
enough in their computer studies to ever write a line of code. Or if they do get that far, they get discouraged very quickly.</p>
<p>There are, however, a lot of programmers who exhibit reasonable skill as programmers, but who struggle with the more advanced concepts. It is this group of people who I target when I write.</p>
<p>Programming is a profession that attracts some of the smartest people in the world. The future of programming is usually defined by these people.
Throughout this text I will try to reference great developers and refer people to their web pages or pass on advice spoken or written by this elite. These super smart people are not, however, the target audience for whom I write.</p>
<p>If, at times, you find my suggestions overly cautious, or perhaps even a bit pedantic, it is simply because I believe that average developers have very little room to cheat on style or design. The best programmers usually write code that is elegant, well formated, and well designed. It is smart programmers with poor skills who write bad code and get away with it. They are making their own lives overly complicated, and the complicate the lives of those who use their code. But the shortcuts and carelessness that mar their code will destroy the code of an average programmer striving to perform a complex task. The best strategy is to follow a clearly defined set of rules that help you write clean, easy to understand code.</p>
<h2 id="refactoring">Refactoring</h2>
<p>A developer who seeks to fix a bug must understand not only how to fix the bug, but what impact that fix will have on the rest of the program. That is one of the reasons we test our code. After we make a bug fix, we run our tests to see what impact the change had on our code.</p>
<p>The art of writing robust code is the art of learning how to test our code, how to refactor our code, how to make it reusable. If you can create code that is testable,
then it should be possible to refactor it so that it is maintainable, reusable and robust.</p>
<p>Testable code is by definition reusable. It is used once in your program, and once in your tests. Thus it is reusable.</p>
<p>The art of writing code that is easy to test and easy to maintain turns out to be one of the most complex and important tasks a developer must master. Except in very rare cases, it can only be achieved through repeated refactoring. Just because your code works, or appears to work, that does not mean it is finished. As mentioned early, good code should be:</p>
<ol>
<li>Testable</li>
<li>Maintainable</li>
<li>Reusable</li>
<li>Robust</li>
<li>Fast enough</li>
</ol>
<p>We achieve these goals by refactoring our code.</p>
<h2 id="testing">Testing</h2>
<p>There are no hard and fast definitions for the kinds of tests that people write. However, I generally break tests out in two types:</p>
<ul>
<li>Tests run from the developer&#39;s perspective</li>
<li>Tests run from the user&#39;s perspective</li>
</ul>
<p>Of course, it is usually the developer who runs all these tests. The difference between them is in what is being tested. Developer tests are testing code, while user tests are testing features. The person who hires you to do your work probably won&#39;t understand most developer tests, but they will understand a test that shows that a particular feature works. In fact, end users can often define what user tests need to be written, but they would not know how to define a developer test.</p>
<p>Developer tests are usually either:</p>
<ul>
<li><em>Unit tests</em> that test a single object and use mocks for dependencies</li>
<li><em>Integration tests</em> that test the interaction between two or more objects</li>
</ul>
<p>User tests are typically either:</p>
<ul>
<li><em>Functional tests</em> that prove that a feature works correctly</li>
<li><em>Acceptance tests</em> that check if the program as a whole works correctly and within reasonable performance limits</li>
</ul>
<p>It is common for acceptance tests to be used as a means of proving that a program meets the specifications set forth by the person who hired out the work. &quot;Here are tests that prove that our program does what you asked us to do.&quot;</p>
<p>Again, there is some disagreement between developers as to exactly how to define the various tests outlined above. For instance, I find it hard to draw a solid line between functional testing and acceptance testing in certain cases.</p>
<p> We will study all of the tests outlined above, but the primary focus will be on developer tests.</p>
<h2 id="design">Design</h2>
<p>How do we learn to write maintainable, well designed code? Two key factors that help us achieve our goal are:</p>
<ol>
<li>Adopting good programming principles</li>
<li>A deep understanding of our tools and our language.</li>
</ol>
<p>By programming principles I&#39;m talking about things like:</p>
<ul>
<li>Agile Design</li>
<li>Programming guidelines such as the single responsibility principle</li>
<li>Program Architecture</li>
<li>Team dynamics</li>
<li>Test Driven Development (TDD)</li>
<li>Behavior Driven Development (BDD)</li>
</ul>
<p>But knowing the theory is not enough. You also need a deep, intuitive, understanding of JavaScript or any other language you use. This is crucial if you want to write good code. You will constantly be forced to make implementation decisions when you write code. You will not be able to make any of those decisions unless you first have an understanding of what features are available in the language, and when and how to use them.</p>
<h2 id="guidelines">Guidelines</h2>
<p>We are going to spend much learning how to refactor code so that we can safely fix bugs and add new features.</p>
<p>A well designed architecture supports the <a href="https://en.wikipedia.org/wiki/Open/closed_principle">Open Closed Principle</a>:</p>
<ul>
<li><em><strong>Modules, Classes and Functions should be open to extension but closed to modification.</strong></em></li>
</ul>
<p>Along with <a href="https://en.wikipedia.org/wiki/Loose_coupling">loose coupling</a> the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single-responsibility principle</a> and <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> are core guidelines for our work. The open closed principle is one of the foundations of good software design. My classes are not really about Linux, git, Angular, jQuery, or express. They are about how to build applications using our core ideas:</p>
<ul>
<li><a href="http://agiledata.org/essays/tdd.html">Test Driven Development (TDD)</a></li>
<li><a href="http://edn.embarcadero.com/article/30372">Loose Coupling</a></li>
<li><a href="http://www.oodesign.com/single-responsibility-principle.html">The Single Responsibility Principle</a></li>
<li><a href="http://www.oodesign.com/open-close-principle.html">The Open Closed Principle</a></li>
</ul>
<p>Another important design principle not emphasized in this class is the <a href="http://www.oodesign.com/dependency-inversion-principle.html">Dependency Inversion Principle</a>.</p>
<p>Slide decks that might be useful:</p>
<ul>
<li>Agile Overview: <a href="http://bit.ly/1qf6V4t">http://bit.ly/1qf6V4t</a></li>
<li>Refactoring: <a href="http://bit.ly/elfrefactor">http://bit.ly/elfrefactor</a></li>
</ul>
<p>As a general rule, these are the rules, ideas and guiding principles that make possible agile development:</p>
<ul>
<li><a href="http://www.agilemanifesto.org/">http://www.agilemanifesto.org/</a></li>
<li><a href="http://www.agilemanifesto.org/principles.html">http://www.agilemanifesto.org/principles.html</a></li>
</ul>
<h2 id="order-and-discipline">Order and Discipline</h2>
<p>No one can succeed at development without:</p>
<ul>
<li>An orderly and logical mind</li>
<li>An obsessive concern for detail</li>
<li>A degree of patience that others consider a bit freakish</li>
<li>At least the capability to go inward, to work alone, in silence for hours</li>
<li>An ability to work with others on a team</li>
</ul>
<p>It is extremely frustrating to watch a disciplined and inspired person fail at coding over and over again because they simply lack the ability to be orderly to be and get organized. Good developers adopt or create systems for organizing their code, their materials, and their documents. If you don&#39;t, or can&#39;t, do this, you will fail every single time.</p>
<p>Much of this book is about learning what organizational techniques are best. In particular, we will focus on how to write unit tests and code that is testable. We will organize our code around our tests and the modules that they test. These are proven techniques with a great track record.</p>
<p>However, even if you picked a terrible technique for organizing your code, and stuck with it, you might have a chance of succeeding. But without some organizing principle that you can stick with, you will fail.</p>
<h2 id="be-practical">Be Practical</h2>
<p>Many times I have started writing a program, only to find myself bogged down in details that threatened to overwhelm me. Over
time I began to sense that I began to sense that my code contained unnecessary features. I began to strip layers of complexity. At times that
meant I had to limit the features in my program, but frequently these
features were not nearly as important as they were costly. In the end, I
ended up with a shorter, simpler program than the one I initially meant to
write. But my program worked and my users liked it.</p>
<p>I was much better off with a robust program that worked, than with a flakey program that was cool but not reliable. And when users looked at my code, they rarely complained. It was
simple but robust. It is hard to criticize code that works!</p>
<p>A lot of good developers have missed their chance to create a useful or important program because they have added too many features or focused too much on writing
&quot;clever&quot; code that is fast and small, but which is also hard to debug, maintain and understand. Instead of focusing on speed and size, focus on the
following concepts, and others that will be developed throughout this text.</p>
<p>Write code that:</p>
<ul>
<li>is easy to read</li>
<li>is easy to maintain</li>
<li>Contains only absolutely necessary features</li>
<li>Sacrifices features that will be used by only a small percentage of users</li>
<li>is aligned with best practices, especially those outlined by the Agile school
of development</li>
</ul>
<h1 id="part-ii">Part II</h1>
<p>Enough theory. Let&#39;s start writing code.</p>
<h2 id="introductionToJavaScript">Introduction to JavaScript</h2>
<p>Large parts of the web are driven by three related technologies: HTML, CSS
and JavaScript. Though the differences between the roles played by these
technologies can blur at times, the following assertions will help you
understand the primary purpose of each component:</p>
<ul>
<li>HTML files contain content such as text, bitmaps or videos</li>
<li>CSS let&#39;s you define how the content should appear</li>
<li>JavaScript allows you to perform actions that animate that content</li>
</ul>
<p>It is possible to completely scramble these rolls. For instance, you can put
content in JavaScript files and use HTML to define the appearance of your
content. It is not, however, always considered good practice to do any of
these things. Some good developers follow the guidelines for apportioning roles in most, but
not all cases. I prefer, however, to take a hard line, and to insist that content,
and content alone be placed in HTML files, that appearance be specified only in
CSS files, and that JavaScript be used only to perform actions.</p>
<p>At this stage, I am keeping the terms I&#39;m using deliberately vague. I have
not rigorously defined what I mean by the &quot;appearance&quot; of a page, or what it
means to performs an action with a JavaScript file. I believe, however, that
I will succeed in making making these concepts clear over time. The reader
simply has to have patience, and over time you should develop a clear and
well defined understanding of the roles played by each of the three
components of a web page.</p>
<h2 id="helloWorldAtTheCommandPrompt">Hello World at the Command Prompt</h2>
<p>If you want to learn JavaScript, it can be helpful to start with a command line utility. To get started, install <a href="http://nodejs.org/">NodeJs</a>,
and run scripts from the command prompt:</p>
<ul>
<li><a href="/charlie/development/web/JavaScript/NodeJs.html">Node on Elvenware</a></li>
</ul>
<p>A much less frequently used solution is to install Rhino, which is built on top of the Java VM:</p>
<pre><code>sudo apt-<span class="hljs-keyword">get</span> install rhino
rhino-jsc
</code></pre><p>Built into Windows is a tool called <strong>cscript.exe</strong>. It is fairly solid, but is not a good choice compared to NodeJs. For instance, <strong>console.log</strong> does not appear to be
defined. Instead you need to use something like <strong>WScript.Print &quot;Foo&quot;</strong>. This is not a flaw in the implementation, but it can be confusing, particularly to newcomers, who will find most examples of server side code targets the NodeJs and the Chrome V8 engine.</p>
<p>On the Mac, I would also default to NodeJs. But if you want to play with <em>JavaScriptCore</em>, see:</p>
<ul>
<li><a href="http://www.phpied.com/javascript-shell-scripting/">http://www.phpied.com/javascript-shell-scripting/</a></li>
</ul>
<h2 id="helloWorldInTheBrowser">Hello World in the Browser</h2>
<p>JavaScript is frequently embedded in or attached to an HTML file.</p>
<p>In Listing 01, for instance, you can see a very simple &quot;Hello World&quot; program that uses JavaScript. You can save this file as</p>
<p><strong>very-simple.html</strong>.</p>
<p><strong>Listing 01: Hello world in JavaScript.</strong></p>
<pre><code class="lang-javascript"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>     
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Very Simple<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"JavaScript intro"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"simple"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"simple"</span>).innerHTML = <span class="hljs-string">"A very simple JavaScript Hello-World program."</span>;    
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Browse to this file with a file explorer or some similar tool. Double click on it, or right click and choose <strong>Open with...</strong>. Because the file has an HTML extension, it should open automatically in a web browser or allow you to choose the browser in which you want to run it. Some browsers will also let you choose <strong>File
| Open</strong> from the menu and browse for the file you want to open. If you are using Chrome, press <strong>Ctrl + O</strong> to open a file.</p>
<p><img src="images/VerySimpleJavaScript.png" alt="Very Simple JavaScript file"></p>
<p><strong>Figure 01: The very-simple.html running in Chrome.</strong></p>
<p>You can see the path to the file in the address bar. This is a normal
Windows path with slashes rather than back-slashes. Notice also that it
is prefaced with the code <strong>file:///.</strong>. Later you can learn how to set
up a web server to publish your code, but for now, it is fine to just
browse for the file on your hard drive.</p>
<p>In the above example, the JavaScript is embedded smack dab in the middle of
our HTML.</p>
<p>In this book, however, a basic and nearly immutable rule is not to put HTML and JavaScript in the same file. Instead, create two or more files: one set of files should contain only HTML; the other only JavaScript. Provide a link from the \<head\> element in the HTML to the JavaScript file or files:</p>
<p><strong>Listing 03: The very-simple.html file</strong></p>
<pre><code class="lang-javascript"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>     
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Very Simple<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"JavaScript intro"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"very-simple.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"simple"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>Listing 04: The JavaScript file: very-simple.js.</strong></p>
<pre><code class="lang-javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"simple"</span>).innerHTML = <span class="hljs-string">"A very simple JavaScript Hello-World program."</span>;
}
</code></pre>
<p><strong>Note: You can download this sample from
<a href="http://www.elvenware.com/charlie/downloads/VerySimple.zip">here</a>.</strong></p>
<p><strong>NOTE</strong>: When running the code in Listings 03 and 04, you should be
sure to put both files in the same directory. For instance, you may have
a folder called <strong>C:\Source</strong> or <strong>~/Source</strong> where you store your source files. Put both
files in that directory:</p>
<pre><code>Source/very-simple<span class="hljs-selector-class">.html</span>
Source/very-simple.js
</code></pre><p>Run this program just as you did the first example. Alternatively, you can see it in action here:</p>
<ul>
<li><a href="http://bit.ly/very-simple">http://bit.ly/very-simple</a></li>
</ul>
<p>It is a good practice to always separate your HTML code into
three files:</p>
<ul>
<li>Put your content in HTML files with an HTML extension: MyFile.html</li>
<li>Put your presentation code in CSS files with a CSS extension:
MyFile.css</li>
<li>Put your JavaScript in JavaScript files with JS extension:
MyFile.js</li>
</ul>
<p>If you need to use the same CSS or JavaScript in multiple HTML files,
then it is obvious that it is best to put that CSS or JavaScript in a
separate file. Otherwise, you would be forced to endlessly repeat the
same code in multiple HTML files. Then, if you wanted to fix a bug in
your JavaScript or CSS, you would need to fix it in each HTML file that
included the code. In a large web site, that might mean you would need
to edit thousands of HTML files just to make one simple fix.</p>
<p>But suppose you CSS or JavaScript that you only wanted to use in one
file? Why should you split them up into three files? Wouldn&#39;t it mean
that:</p>
<ul>
<li>Your code ran faster because there would be one download instead of
3?</li>
<li>It would be easier to make sure that code that belonged together
never got separated?</li>
</ul>
<p>The answer to both these questions is yes. And still, despite these
arguments, I think you should always separate your code out into three
files. I believe this for the following reasons:</p>
<ul>
<li>It promotes good habits</li>
<li>More often than you think, there will come a time when you will want
to use the CSS or JavaScript in a second HTML file. If it is not
already split out into multiple files, then you will get lazy and
copy it from one file to another, ending up with duplicate code.</li>
<li>Ultimately, it is easier to write good clean, easy to read, and easy
to maintain code if you don&#39;t mix different types of source in a
single file</li>
<li>And finally, there are tools that can be run over HTML files before
you release them that will automatically consolidate them into a
single file.</li>
</ul>
<p><em>NOTE: This last point is not really as good an argument as it sounds.
Ultimately, I believe you are better off with a maintainable code base
that runs a bit slow, than you are with a fast code base that is
impossible to understand, maintain or improve. Furthermore, most
developers who try to optimize their code end up spending hours, days,
or even months fussing with code in order to save milliseconds that the
user never notices. The rule you want to follow is simple: unless you
can see obvious, and certain, proof that you have a performance problem,
you should not waste time trying to optimize your code. Instead, focus
on writing clean code that is easy to maintain. One thing we know for
certain: users always prefer code that works and has the right features
to code that does not work and lacks key features. If you write messy,
hard to maintain code, you will nearly always find it harder to add
features to that code base than it is to add features to well written
programs.</em></p>
<h2 id="theCaseOfFileNames">The Case of File Names</h2>
<p>I should say a word about the case of the file names I create. There are
six different ways to name files, three of which are wrong, and three of
which are right:</p>
<ol>
<li>file01.html</li>
<li>vrysmpl.html</li>
<li>verysimple.html</li>
<li>very_simple.html</li>
<li>very-simple.html</li>
<li>VerySimple.html</li>
</ol>
<p>The first example is wrong because the name has no meaning: it tells you
nothing about the contents of the file. The second name is wrong because
it contains abbreviations. Twenty years ago developers used
abbreviations to save space on machines where memory or hard drive space
was scarce, or where operating systems did not support names with more
than 8 characters. This is no longer necessary for a variety of reasons,
and now abbreviations are merely a sign that developers are too lazy to
type out the whole word. (To every rule, there are exceptions, and there
are occasions when the code in very short methods is easier to read when
it makes use of abbreviations. But those are the exceptions to a good
rule, and there is rarely a case where any good is accomplished by
showing newcomers such shortcuts.) The third example is wrong because it
provides no means of helping the reader to separate out the face that
<strong>verysimple</strong> is a name consisting of two words.</p>
<p>The fourth example is correct, but is now considered a bit old
fashioned. Most people prefer using a dash, rather than an underscore,
because they believe it is easier to type. In either case, the basic
strategy is good, because there are no abbreviations, and the words are
cleanly separated. The whole issue of case is moot in this strategy,
since all letters are rendered in lower case. The last example is the
one I prefer, because it is most familiar to me, and I find it easier to
read a long list of names rendered in this format. It uses Pascal
casing, where multiword names are run together into one name, and each
word in the name begins with a capital letter.</p>
<p>NOTE: One good argument from the folks who prefer using dashes to using
Pascal casing runs as follows. Suppose you have a common acronym such as
IBM. Perhaps you have method from IBM that performs fast addition. You
would want to call this method <strong>IBMFastAddition</strong>. This name runs the
words IBM and Fast together into one name and thereby breaks an
important rule about clearly delineating the words in a name. I
therefore would name this method <strong>IbmFastAddition;</strong> now we can clearly
see that Ibm is meant to be treated as a discreet unit. In fact, I
always treat acronyms this way: I capitalize the first letter and put
the other letters in lower case. This system works, but some find it
less than optimal. If you used dashes, you could write something like
this instead: <strong>ibm-fast-addition</strong>. This is arguably easier to read
than the Pascal casing example. But I don&#39;t find so terribly much
difference, and sometimes I think Pascal casing is easier to read. For
instance, I think <strong>SimpleHtmlToElvenwareConverter</strong> is easier to read
than <strong>simple-html-to-elvenware-converter</strong>. But gosh, it is a silly
thing to get upset about. I distrust anyone who gets overly excited
about such issues. I think even great programmers, such as Douglas
Crockford, do little more than display their rare blind spots when they
get overly exercised over issues that so clearly are more matters of
taste than of science. In fact, I have seen people foolishly ignore
Crockford&#39;s many strengths because he is so obviously overly zealous in
this one area. He&#39;s doing more harm to himself than good by being so
narrow minded.</p>
<p>Ultimately, the choice you make between the last three &quot;correct&quot;
examples is a matter of personal taste. There are only two primary
caveats you need to keep in mind:</p>
<ul>
<li>Whatever strategy you pick: stick with it! Once you have decided on
a strategy then you, and everyone who works with you, must stick to
that strategy in all the code you produce.</li>
<li>If you go to work for a shop that has already adopted a strategy,
then you must happily conform with it. A good manager will work with
you, and have patience while you come to see the error of your ways.
Bad managers will simply make your life miserable until you either
come to your senses or move on. In either case, there is no question
that it is irrational and counter productive to create code that
uses a style that does conform to the needs of the others in your
group.</li>
</ul>
<p>The case of a file name is one thing, but the case of formatting code in
a source file is a different matter. Almost all languages have an agreed
upon style of casing, indentation, etc. You should make a real effort to
discover the strategy for the language you are using, and to follow it
as best you can. In this document, I attempt to follow the standards for
formatting JavaScript code. With a few minor exceptions, if you see me
vary from what you consider to be the best strategy for formatting
JavaScript, then please send me email and let me know. My goal is to
conform to the standards set by the JavaScript community. If I want to
assert my individuality, I wrote prose or poetry; when I write code, I
try to conform to standards. The only case for individuality in code is
the case for writing the cleanest, easiest to understand code of any
developer on your team. There is no place for a quirky style of
capitalization or indentation.</p>
<h2 id="aSimpleJavaScriptDevelopmentStrategy">A Simple JavaScript Development Strategy</h2>
<p>JavaScript has one set of rules when run in a browser, and another set when run outside a browser. There are, therefore, two distinct flavors of JavaScript discussed in this text.</p>
<ul>
<li>Client side JavaScript implemented by the various browser makers:<ul>
<li>In Chrome and Chromium: We use the Chrome V8 Javascript Engine</li>
<li>In Firefox we use the SpiderMonkey JavaScript engine</li>
<li>Safari uses JavaScriptCore, aka as Nitro, SquirrelFish and SquirrelFish Extreme</li>
<li>Chakra is the JavaScript engine in IE and Edge</li>
</ul>
</li>
<li>Server Side<ul>
<li>Most server side JavaScript code is written with NodeJs, which uses the Chrome V8 Engine.</li>
</ul>
</li>
</ul>
<p>The big gap here is between client side and server side code. Even though the V8 engine is used in both Chrome and NodeJs, the code you write on the server side is often quite different from the code used in a browser. It is not that JavaScript syntax changes, but rather than the available libraries are so different, and the techniques for loading JavaScript code are so different, that one needs a different mind set when writing NodeJs code and writing client side code.</p>
<p>As a rule, you need no longer concern yourself too much with the difference between the various browsers. Client side code needs to be tested in all browsers, but you should be able to craft code that works in all browsers so long as you approach the matter carefully and methodically. In particular, judicious use of libraries such as jQuery can help you write client side code that works in all browsers.</p>
<p><strong>NOTE</strong>: <em>I should probably qualify what I say above. The basic syntax of the language does not change when you switch from a browser to the server. The only exception, of course, is when a browser has a buggy implementation of JavaScript, and that still happens, though less frequently than it did several years ago.) But even when everything works correctly, certain key features of the language, such as the <strong>this</strong> keyword, have a different significance inside a browser and outside a browser. Also, key elements of the client side API, such as the <strong>alert</strong> function, are not typically available by default on the server. In general, I think it is easier to move from the browser to <strong>nodejs</strong>, than it is to move from <strong>nodejs</strong> to the quirky world of browsers.</em></p>
<p>The code you saw in the previous section provides a
good framework for beginning and intermediate level JavaScript
programmers who want to learn more about the language. Start out by
opening up code similar to what you see in Listing 3 and 4. As a matter
of fact, you can simply reuse VerySimple.html over and over again. As we
explore the JavaScript language, all you need do is change the name of
the JavaScript file that you are linking in. For instance, linking
VerySimple01.js for one program, then VerySimple02.js for the next
program. Better yet, follow best practices and rename each JavaScript
file to reflect its contents. For instance, ExploringLoops.js would be a
good name for a JavaScript file that you created when you wanted to
learn about how loops are written in JavaScript.</p>
<p>Before leaving the subject of how to structure your code, there is one
last subject to cover. A key tool developers use when debugging their
code, and when they are exploring JavaScript, is a call to
<strong>console.log</strong>:</p>
<pre><code class="lang-%7B.code%7D">console.log(<span class="hljs-comment">"This is a a debug message"</span>);
</code></pre>
<h2 id="console.Log">Console.Log</h2>
<p>You can use console.log to log debug information.</p>
<pre><code>console.log(<span class="hljs-symbol">'This</span> line <span class="hljs-keyword">of</span> code executed');
</code></pre><p>If you run your JavaScript in a browser, then use the Browser&#39;s debugger to
view the results. For instance, in Chrome, press F12 to bring up the
Developer Tools. Then turn to the <strong>Console</strong> page. If you are using a
command line tool like <strong>node</strong>, then you can see the results at the command
line itself.</p>
<p>Suppose you are a beginning level JavaScript programmer who wants to
learn how to write a function that adds numbers. Now it is a good and
admirable thing to want to design an HTML file that will allow the user
to enter numbers, push a button, and display the result of an operation
on those numbers. However, in this life there is a time for everything,
and lets suppose that right now you don&#39;t want to focus on inputting or
displaying numbers: you just want to write a method called <strong>add</strong>and
see if it works. Here is how you can use console.log to help you
reach your goal.</p>
<p>Begin your the same basic HTML file described above:</p>
<p><strong>Listing 05: The HTML File</strong></p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Very Simple<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"calculator.js"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>As you can see, the code shown in Listing 5 is similar to the code found
in Listing 3. The only difference is that the source file linked in is
called <strong>Calculator.js</strong> rather than <strong>VerySimple.js</strong>. Here is the code
for <strong>Calculator.js</strong>:</p>
<p>Listing 06: Code that uses console.log.</p>
<pre><code>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{  
      <span class="hljs-keyword">var</span> sum = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
      <span class="hljs-built_in">console</span>.log(sum);
    };
</code></pre><p>Launch your HTML file in Chrome. Press F12 or Ctrl-Shift+I to open the
Developer Tools and turn to the console page. You should see the output from
any of your console.log statements in the console window. Note also that the
console window allows you to add arbitrary statements that will be run
against the JavaScript on your page.</p>
<p><a href="images/Console01.png"><img src="images/Console01Small.png" alt="Console Window"></a></p>
<p><strong>Figure 0X</strong>: The Chrome JavaScript Console window.</p>
<p>In the screen shot, you can see the output of the call to <strong>console.log</strong>.
I have also used the Chrome console window to explicitly type in some
code:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">12</span>)</span></span>
</code></pre><p>After typing this code, my JavaScript method is called, and the result of the
call to the <strong>add</strong> method is shown. This technique can be used to help you
debug your JavaScript code without having to create an interface for your program.</p>
<p>Note: You can also use
<a href="http://elvenware.com/charlie/development/web/UnitTests/">qUnit</a> to write
unit tests that can help you debug your code. I typically use both
<strong>console.log</strong> and <strong>qUnit</strong>. However, if I were forced to choose between the two
techniques, then I would choose <strong>qUnit</strong> or some other unit test framework. I
am not forced to make that decision, so I use console.log and qUnit. But if
I were forced to choose, I would choose unit testing over logging.
Ultimately, unit testing is a more robust solution. In particular, it is
easy to automate unit tests, while there is no simple way to automate
checking the results of calls to <strong>console.log</strong>. You can visually confirm the
results, but that is not that same as getting an automated error report such
as you get from <strong>qUnit</strong>.</p>
<h2 id="learnMore">Learn More</h2>
<p>Here is a rendering of the hidden code that prints the first two lines
found on this page:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
 <span class="hljs-built_in">document</span>.writeln(<span class="hljs-string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);
 <span class="hljs-built_in">document</span>.writeln(<span class="hljs-string">"&lt;p&gt;These lines written using JavaScript.&lt;/p&gt;"</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><p>This code changes the page you are viewing by inserting two lines of
text when the document loads. Because the change occurs as the document
is first loaded, you are not aware that an action is being performed.
Nevertheless, this is a dynamic event, and not a static rendering of
text as you see in standard HTML. For a more dynamic example of how
JavaScript can change the appearance of a page, see the next section,
called Insert Adjacent HTML.</p>
<p>The code shown above is embedded in this document directly below the
caption that reads <strong>JavaScript Basics</strong>. Right click this document and
choose <strong>View Source</strong> to see it.</p>
<p>NOTE: <em>It is important to understand that the text you see above is not
the actual code that gets executed. The real code is inside this HTML
page, but hidden from view. Whenever you include an angle bracket: \&lt;>
in your HTML, then the words inside those brackets are called a tag, and
they become hidden from view when the page is rendered in a browser. In
this case, all the words between the opening \<script\> and closing
\</script\> tags are considered part of the script tag, and are hidden
from view. To show an angle bracket to the reader of an HTML page, you
write the following code: <strong>\&lt;</strong> or <strong>></strong>. The first bit of code is an
open angle bracket, and the second a close angle bracket. HTML is pretty
simple and straight forward most of the time, but this is one of those
places where it can be a bit hard to understand what is going on if you
are a newcomer. Nothing will better help you grasp these concepts than
actually getting your hands dirty and writing some code. Sometimes you
can learn best by doing.</em></p>
<p>Install the JavaScript ChromeTools Debugger in Eclipse:</p>
<p><a href="http://code.google.com/p/chromedevtools/wiki/HowToInstall">http://code.google.com/p/chromedevtools/wiki/HowToInstall</a></p>
<h2 id="theRightTools">The Right Tools</h2>
<p>There are some wonderful tools out there for developing big applications with HTML and JavaScript. Three that I use frequently are Eclipse/Aptana, and WebStorm.</p>
<p>If you are writing the kind of simple program needed to follow along with this text, however, I think it is simplest to use the following tools:</p>
<ul>
<li><a href="https://www.geany.org/">Geany</a></li>
<li><a href="https://www.google.com/chrome/browser/desktop/">Chrome</a></li>
<li><a href="https://nodejs.org/en/">NodeJs</a></li>
<li>notepad++</li>
</ul>
<h2 id="the-right-books">The Right Books</h2>
<p>Good books to read on JavaScript.</p>
<ul>
<li><a href="https://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680"><strong>Maintainable JavaScript</strong></a>, by Nikalas Zakas, the author of <strong>JavaScript for Web Developers</strong>. MJ is a short book that is easier to read than JGP, but which follows much of the advice found in Crockford&#39;s book.</li>
<li><a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>. A general purpose guide to writing good code.</li>
<li><a href="https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/1617292850"><strong>Secrets of the JavaScript Ninjas</strong></a> by jQuery&#39;s John Resig is an excellent book. A bit heavy going in places, but full of excellent advice.</li>
<li><a href="http://eloquentjavascript.net/">Eloquent JavaScript</a>: An in depth look at the language available <a href="http://eloquentjavascript.net/">on the internet</a>.</li>
<li>A difficult but valuable book is <strong>JavaScript the Good Parts</strong> by Douglas Crockford. It is a tough read, but it is the pivotal book about JavaScript that taught everyone how to properly use the language.</li>
<li><a href="https://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527">JavaScript, the Definitive Guide</a> by David Flanagan. Considered <em>the</em> book on JavaScript by many, but I find Zakas easy to understand and the Ninja book to have more depth. But still an important and useful book.</li>
<li><a href="https://www.amazon.com/Principles-Object-Oriented-JavaScript-Nicholas-Zakas/dp/1593275404">The Principles of Object Oriented JavaScript</a> by Nikalas Zakas. If you wish JavaScript were C#.... Includes numerous insights into how JavaScript is structured. I couldn&#39;t put it down.</li>
</ul>
<p>This might also be of some help:</p>
<p><a href="http://www.elvenware.com/charlie/development/web/JavaScript/">http://www.elvenware.com/charlie/development/web/JavaScript/</a></p>
<p>And here are the two &quot;home pages&quot; for web development:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">Mozilla Developer Network</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/javascript?sort=frequent&amp;pageSize=15">Stack Overflow</a></li>
<li><a href="http://www.hanselman.com/blog/StopSayingLearningToCodeIsEasy.aspx">Stop Saying Coding is Easy</a></li>
</ul>
<p>I also want to read <strong>JavaScript Patterns</strong> by Stoyan Stefanov and I am currently reading <strong>Functional JavaScript</strong>. The latter book is very good, but perhaps too advanced for most of us.</p>
<ul>
<li><a href="https://developers.google.com/events/io/">Google IO</a></li>
<li><a href="http://hanselminutes.com/">Scott Hanselman</a></li>
<li><a href="http://stackoverflow.com/questions/409056/top-rated-javascript-blogs">JavaScript Blogs</a></li>
<li><a href="http://net.tutsplus.com/articles/web-roundups/30-developers-you-must-subscribe-to-as-a-javascript-junkie/">33 Developers to follow</a></li>
</ul>
<h2 id="some-caveats">Some Caveats</h2>
<p>Having laid out the goals and principles on which we shall be working, I think it is important to make some additional points.</p>
<p>Some advanced students will find points in my text where they might think:
&quot;Hey, I know a better way to do that! My way uses less code, or my way saves
10 clock cycles.&quot; All that is good and well, but is the code that you
propose also both maintainable and easy to understand? Are you sacrificing
maintainability on the alter of speed? In some cases, I may in fact know
about that &quot;better way,&quot; but I have chosen to stick to a simple, easier to
understand syntax in order to teach people how to write robust, easy to
maintain code. Saving ten clock cycles simply is not worth it if the techniques involved prevent average developers from learning how to write and maintain a complex program.</p>
<p><strong>NOTE</strong>: <em>Of course, there will be cases where there really will be
a simpler and easier way to do something than the one I show. If you think
you have found a better way to do something, then please write me and let me
know. Before you write, however, consider whether your code is not only
small and fast, but also easy to read, and easy to maintain. For me, these
virtues are more important than brevity or performance. This does not mean
that I don&#39;t take brevity and performance into account, but only that they
are not my first priority.</em></p>
<p>I believe many of these developers are quite capable of creating good
programs that would meet their own needs and the needs of most users.
However, they never achieve their goals because they are too focused on
performance. In short, they are aiming to high. They want to make their code
impossibly fast, and end up creating programs that no one, not even
themselves can maintain. As a result, they fail. My goal is to define a
style of programming that can help these developers achieve their goals.</p>
<h2 id="some-links">Some Links</h2>
<p>Consider using a JavaScript style guide:</p>
<ul>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml">http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml</a></li>
<li><a href="http://contribute.jquery.org/style-guide/js/">http://contribute.jquery.org/style-guide/js/</a></li>
<li><a href="https://github.com/rwldrn/idiomatic.js/">https://github.com/rwldrn/idiomatic.js/</a></li>
</ul>
<h2 id="news-links">News Links</h2>
<ul>
<li><a href="http://www.google.com/search?q=javascript+news">http://www.google.com/search?q=javascript+news</a></li>
<li><a href="http://www.google.com/search?q=web+app+development+news">http://www.google.com/search?q=web+app+development+news</a></li>
<li><a href="http://www.google.com/search?q=node+js+news">http://www.google.com/search?q=node+js+news</a></li>
</ul>
<h2 id="blog-links">Blog Links</h2>
<ul>
<li><a href="http://www.google.com/search?q=javascript+blogs">http://www.google.com/search?q=javascript+blogs</a></li>
<li><a href="http://www.google.com/search?q=web+app+development+blogs">http://www.google.com/search?q=web+app+development+blogs</a></li>
</ul>
<h2 id="microsoft">Microsoft</h2>
<p>Also, if you end up in the Microsoft world, read and listen to everything that these two people say:</p>
<p>Anders:</p>
<ul>
<li><a href="https://twitter.com/ahejlsberg">https://twitter.com/ahejlsberg</a></li>
<li><a href="https://channel9.msdn.com/events/speakers/Anders-Hejlsberg">https://channel9.msdn.com/events/speakers/Anders-Hejlsberg</a></li>
</ul>
<p>Mads:</p>
<ul>
<li><a href="https://twitter.com/madstorgersen">https://twitter.com/madstorgersen</a></li>
<li><a href="https://channel9.msdn.com/Events/Speakers/Mads-Torgersen">https://channel9.msdn.com/Events/Speakers/Mads-Torgersen</a></li>
</ul>
</div></body></html>