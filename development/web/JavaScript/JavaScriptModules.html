<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>JavaScriptModules</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>JavaScriptModules</h1><p>Welcome to JavaScriptModules</p><ul><!--TOC_Start--><li><a href="#javascript-modules">JavaScript Modules</a></li>
<li><a href="#related-pages">Related Pages</a></li>
<li><a href="#partI">Part I</a></li>
<li><a href="#partII">Part II</a></li>
<li><a href="#partIII">Part III</a></li>
<li><a href="#proto">Cannot Read Property Prototype of Undefined</a></li>
<li><a href="#thoughts-on-private-and-public-methods-and-the-module-pattern">Thoughts on Private and Public Methods and the Module Pattern</a></li>
<li><a href="#module-basics">Module Basics</a></li>
<li><a href="#references">References</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="javascript-modules"></a>
<h1>JavaScript Modules</h1>
<p>This document covers the JavaScript Module Pattern</p>
<p>When in doubt, go back to the <a href="index.html">index</a>.</p>
<a class="anchor" id="related-pages"></a>
<h2>Related Pages</h2>
<ul>
<li><a href="http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#objects">Basic Objects</a></li>
<li><a href="http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#compareObjFunc">Compare Object Functions</a></li>
</ul>
<p>There are many different ways to write JavaScript. Most of them are
either outright wrong, or less than optimal. There is more than one way
to write good JavaScript code. However, I think there is one commonly
used pattern that you should use as your default style. It is called the
Module Pattern.</p>
<a class="anchor" id="partI"></a>
<h2>Part I</h2>
<p>Here is an example of a simple implementation of the Module Pattern that
can serve as a basic starting point for all JavaScript files that you
create:</p>
<pre>var MyObject = (function() {
    'use strict';

    function MyObject() {
        // Add constructor code here
    }

    MyObject.prototype.run = function () {
        // Add your program code here
    };      

    return MyObject;
})();

// This will be called when page is ready
$(document).ready(function() {
    'use strict';

    var myObject = new MyObject();
    myObject.run();
});
</pre>
<p>Here is the HTML you can use with a JavaScript file like the one shown
above:</p>
<pre><!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>JavaScript00 Sample</title>
        <script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>
        <script src="JavaScriptBasics01.js" type="text/javascript"></script>
    </head>
    <body>
        <h1>This is my JavaScript Module Pattern Test Page</h1>
    </body>
</html>
</pre>
<p>Here is a simple way to think about the transformation that takes place
when we move from a simple JavaScript object to one that is more
complex. Here is a simple JavaScript object:</p>
<pre>var myApp = {
    property1: 0,
    property2: 1,
    function1: function() {},
    function2: function() {}
};
</pre>
<p>If you want to use this object, you might right something like this:</p>
<pre>myApp.function1();
myApp.property1 = 3;
</pre>
<p>Here is the same object using the Modular pattern:</p>
<pre>var MyApp = (function myFunction() {'use strict';

    var property1 = 0;
    var property2 = 1;

    function MyApp() { }

    MyApp.prototype.function1 = function() { };

    var function2 = function() { };

    return MyApp;
})();

var myApp = new MyApp();
myApp.function1();
</pre>
<p>Notice that when using the modular pattern we:</p>
<ul>
<li>Call new (that is, we create a constructor)</li>
<li>We can&#39;t directly access the private properties</li>
<li>We use the prototype syntax to create a public method.</li>
</ul>
<a class="anchor" id="partII"></a>
<h2>Part II</h2>
<p>Here is a more complete example of the JavaScript module pattern: </p>
<pre>var Point = (function() {
    'use strict';

    // Private variables
    var x = 0;
    var y = 0;

    // Private function
    var bar = function () { return 25; };

    // Constructor
    function Point(x1, y1) {
        x = x1;
        y = y1;
    }    

    // Public method
    Point.prototype.add = function () {
        return x + y + bar();
    };      

    return Point;
}());

window.onload = function() {
    'use strict';

    var el = document.getElementById('content');    
    var point = new Point(3, 4);      
    el.innerHTML =  point.add(); // Print 32    
};
</pre>
<p>Notice that the entire method is wrapped in parenthesis:</p>
<pre>var Point = (function() {
  //Code omitted here
}());
</pre>
<p>For now, let&#39;s call this section of syntax the &quot;wrapping function.&quot; The
parenthesis around the <em>wrapping function</em> are simply a means of reminding us that we are creating a wrapping function. By putting an open parenthesis at the start, we signal to ourselves that a wrapping function is about to be declared. Then we can scan down for the closing parens and its accompanying function call: ());</p>
<p>In this example, <strong>x</strong>, <strong>y</strong> and <strong>bar</strong>() are all part of the
<strong>Closure</strong>. When you are thinking about the closure, forget the
<em>wrapping function</em>. Focus only on the Point method, which is our
constructor. The code between it and the wrapping method is all part of
a closure. In other words, the method <strong>Point</strong> (our constructor) has access
to <strong>x</strong>, <strong>y</strong> and <strong>bar()</strong> because they are a part of closure. That is the way
closures work: a method has access to the variables and functions
immediately outside the area where it is invoked.</p>
<p>The closure is the function <strong>Point</strong> and the variables around it that it &quot;remembers&quot;. It can access these variables even after the wrapping function has finished executing. The wrapping function is the actual owner of variables like X and Y:</p>
<pre>var Point = (function() {
    'use strict';

    // Private variables
    var x = 0;
    var y = 0;

    // Code omitted here
})(); // End of wrapping function
</pre>
<p>X and Y belong to our anonymous wrapping function. They belong to the function assigned to the variable Point in the above code fragment. But here, the closure, our <strong>Point</strong> constructor, can &quot;remember&quot; them even though the wrapping function goes out of scope after wrapping function finishes executing. You would think that x and y are gone. Have been cleaned up by the garbage collector and left this fleeting world. But it is not so. They live on because they are caught in the constructor&#39;s closure.</p>
<p>To create a rather silly analogy, a closure is a like a backpack that our constructor or other functions can carry in order to remember the variables that surround them, even if the function that &quot;owns&quot; those variables has gone out of scope. It&#39;s like an inventory in an RPG game. It is a set of tools that the function can access. I don&#39;t necessarily mean to imply that this would be a good way to implement an inventory in an RPG game, only that the function is like the character, and the variables caught in its closure are like its inventory. Its a bag of tricks it can access and carry with it, even when it leaves its home function.</p>
<p>The variables x and y are private. Had they been declared like this,
they would have been public:</p>
<pre>this.x = 1;
</pre>
<p>Consider this function</p>
<pre>var bar = function () { return 25; };
</pre>
<p>This is an anonymous functions assigned to the variable bar. You can
invoke the function immediately if you wish:</p>
<pre>var bar = function() { return 25; }();
</pre>
<p>In this code we are not assigning a function object to a variable.
Instead we are assigning the result of the function, which is 25, to the
variable.</p>
<p>The problem with this syntax is that it does not tell us that we are
invoking the method instead of returning it until we get to the very end
of the statement. In a long method that can be quite a distance.  As a
result, we have adopted the following convention:</p>
<pre>var bar = (function() { return 25; })();
</pre>
<p>Here the parenthesis around the anonymous function tells us right at the
start that we are going to invoke the function. This is a convention,
not a rule. We don&#39;t have to have the outer parenthesis but we are
better off if we do, and JSHint will catch us out if we don&#39;t include
it. Here is a simple example that illustrates the entire point:</p>
<pre>    var functionObject = function() {
        return 1;
    };

    var simpleValue = (function() {
        return 2;
    })();

    $(document).ready(function() {
        $("#functionObject").html(functionObject());
        $("#simpleValue").html(simpleValue);        
    });
</pre>
<p>Notice that we execute <strong>functionObject(),</strong> while we treat
<strong>simpleValue</strong> as the simple <strong>number</strong> type that it is:</p>
<pre>...html(functionObject());
...html(simpleValue);
</pre>
<p>In our module pattern, however, we don&#39;t return a simple value, we
return a function, which is a constructor because we call new on it:</p>
<pre>function Point(x1, y1) {
        x = x1;
        y = y1;
}    

return Point;
</pre>
<p>... // Code omitted here</p>
<pre>var point = new Point(3, 4);
</pre>
<p>But what we get back is not just the function <strong>Point,</strong> but the entire
closure, which includes <strong>x</strong>, <strong>y</strong> and <strong>bar</strong>(). The reason we like
this pattern, however, is because the <em>wrapping function</em> forms a
barrier between the closure and the global name space. So we get a fully
protected functional object, with public methods that use prototype, and
private methods and variables that are part of the closure, and none of
it leaks into the global namespace!</p>
<a class="anchor" id="partIII"></a>
<h2>Part III</h2>
<p>Now let&#39;s add a static method:</p>
<pre>var Point = (function() {
    'use strict';

    // Private variables
    var x = 0;
    var y = 0;

    // Private function
    var bar = function () { return 25; };

    // Constructor
    function Point(x1, y1) {
        x = x1;
        y = y1;
    }    

    // Public static
    Point.hiss = function() {
        return "Hiss";
    };

    // Public method
    Point.prototype.add = function () {
        return x + y + bar();
    };      

    return Point;
})();

window.onload = function() {
    'use strict';
    var el = document.getElementById('content');
    var el2 = document.getElementById('content2');
    var point = new Point(3, 4);      
    el.innerHTML =  point.add(); // Print 32
    el2.innerHTML = Point.hiss();
};
</pre>
<p>Note that we Point.hiss, not point.hiss(). This is because hiss() is
static.</p>
<p>Get the
Source: <a href="/courses/795060/files/23272886/download?wrap=1" title="Point03.zip">Point03.zip</a></p>
<a class="anchor" id="proto"></a>
<h2>Cannot Read Property Prototype of Undefined</h2>
<p>The &quot;cannot read property &#39;prototype&#39; of undefined&quot; usually occurs if
you forget to declare a constructor for your object.</p>
<p>Suppose your module pattern object is supposed to look like this:</p>
<pre>var MyFunction04 = (function() {
    'use strict';

    var field01 = 0;
    var field02 = 0;

    // Constructor
    function MyFunction04(initField01, initField02) {
        field01 = initField01;
        field02 = initField02;
    }

    MyFunction04.prototype.nestedFunction = function() {
        return field01 + field02;
    };

    return MyFunction04; // Return constructor
}());
</pre>
<p>But by mistake, you forgot to declare the constructor:</p>
<pre>    var MyFunction04 = (function() {
        'use strict';

        var field01 = 0;
        var field02 = 0;

        // Somethings missing here abouts....

        MyFunction04.prototype.nestedFunction = function() {
            return field01 + field02;
        };    

        return MyFunction04;
    }());
</pre>
<p>Then in that case you will get the error you are getting.</p>
<p>So you need to be sure to follow this kind of pattern:</p>
<pre>var App = (function() {

    // Don't forget the constructor!
   function App() { }

    return App;
})();
</pre>
<a class="anchor" id="thoughts-on-private-and-public-methods-and-the-module-pattern"></a>
<h2>Thoughts on Private and Public Methods and the Module Pattern</h2>
<p>Some half formed thoughts on public and private methods.</p>
<p>When we use prototype, we create public methods:</p>
<pre>Bar.prototype.goober() = function()
</pre>
<p>When we use var foo = function() we create private methods:</p>
<pre>var foo = function() {}
</pre>
<p>To call a private method from a public method, just call it by name:</p>
<pre>foo();
</pre>
<p>When we call public methods from public methods use this:</p>
<pre>this.goober();
</pre>
<p>There is no simple way to call a public method from a private method using
our module pattern. Sometimes I create a private method and wrap
calls to in a public method:</p>
<pre>var App = (function() {
  function App() {}

   var privateBar = function() {
      // Implement Bar here
   };

  App.prototype.Bar = function() {
     privateBar();
  }

  var foo = function() {
     privateBar();
  }

  return App;
})();
</pre>
<p>With the system shown above we can call privateBar from either a public
function or a private function, thus exposing it to other objects but still
making it easily accessible to private methods in our class.</p>
<a class="anchor" id="module-basics"></a>
<h2>Module Basics</h2>
<p>Simplified modular pattern:</p>
<pre>var MyObject1 = (function() {
     function MyObject2() { }

     return MyObject2;
}());
</pre>
<p>The modular pattern is interested in the <strong>MyObject2</strong> constructor, which is what it returns. As a result MyObject1 ends up being assigned the value <strong>MyObject2</strong>, which is a constructor.</p>
<p>Since MyOjbect2 is a function constructor, it will not work properly unless you call new on it. It doesn&#39;t fail to work entirely if you don&#39;t call new. It just won&#39;t work properly. In particular, it will have no prototype. Without a properly initialized prototype object, then MyObject2 will not work properly. For instance, the method called runReader won&#39;t work. Other methods, such as parse() will work since they don&#39;t depend on the prototype. But in some cases it will be hard to get at the parse() method, but you do provide an event registration event that references it, and so that part of your code will work.</p>
<a class="anchor" id="references"></a>
<h2>References</h2>
<ul>
<li><a href="https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc">JavaScript Modules: A Beginners Guide</a></li>
<li><a href="(http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#objects)">Elvenware Objects</a></li>
<li><a href="(http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#compareObjFunc)">Elvenware Basics Compare Object Functions</a></li>
<li><a href="(http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth)">http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth</a></li>
<li><a href="(http://stackoverflow.com/questions/1114024/constructors-in-javascript-objects)">http://stackoverflow.com/questions/1114024/constructors-in-javascript-objects</a></li>
<li><a href="(http://addyosmani.com/resources/essentialjsdesignpatterns/book/#designpatternsjavascript)">http://addyosmani.com/resources/essentialjsdesignpatterns/book/#designpatternsjavascript</a></li>
<li><a href="http://blixt.org/js">http://blixt.org/js</a></li>
</ul>
</div></body></html>