<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>JavaScriptModules</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>JavaScriptModules</h1><p>Welcome to JavaScriptModules</p><ul><!--TOC_Start--><li><a href="#javascript-modules">JavaScript Modules</a></li>
<li><a href="#related-pages">Related Pages</a></li>
<li><a href="#partI">Part I</a></li>
<li><a href="#partII">Part II</a></li>
<li><a href="#partIII">Part III</a></li>
<li><a href="#proto">Cannot Read Property Prototype of Undefined</a></li>
<li><a href="#thoughts-on-private-and-public-methods-and-the-module-pattern">Thoughts on Private and Public Methods and the Module Pattern</a></li>
<li><a href="#module-basics">Module Basics</a></li>
<li><a href="#references">References</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="javascript-modules"></a>
<h1>JavaScript Modules</h1>
<p>This document covers the JavaScript Module Pattern</p>
<p>When in doubt, go back to the <a href="index.html">index</a>.</p>
<a class="anchor" id="related-pages"></a>
<h2>Related Pages</h2>
<ul>
<li><a href="http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#objects">Basic Objects</a></li>
<li><a href="http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#compareObjFunc">Compare Object Functions</a></li>
</ul>
<p>There are many different ways to write JavaScript. Most of them are
either outright wrong, or less than optimal. There is more than one way
to write good JavaScript code. However, I think there is one commonly
used pattern that you should use as your default style. It is called the
Module Pattern.</p>
<a class="anchor" id="partI"></a>
<h2>Part I</h2>
<p>Here is an example of a simple implementation of the Module Pattern that
can serve as a basic starting point for all JavaScript files that you
create:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyObject = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyObject</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// Add constructor code here</span>
    }

    MyObject.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// Add your program code here</span>
    };      

    <span class="hljs-keyword">return</span> MyObject;
})();

<span class="hljs-comment">// This will be called when page is ready</span>
$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-keyword">var</span> myObject = <span class="hljs-keyword">new</span> MyObject();
    myObject.run();
});
</code></pre>
<p>Here is the HTML you can use with a JavaScript file like the one shown
above:</p>
<pre><code class="lang-xml"><span class="hljs-meta">&lt;!DOCTYPE HTML&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/1999/xhtml"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript00 Sample<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://code.jquery.com/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"JavaScriptBasics01.js"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is my JavaScript Module Pattern Test Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Here is a simple way to think about the transformation that takes place
when we move from a simple JavaScript object to one that is more
complex. Here is a simple JavaScript object:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myApp = {
    property1: <span class="hljs-number">0</span>,
    property2: <span class="hljs-number">1</span>,
    function1: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{},
    function2: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{}
};
</code></pre>
<p>If you want to use this object, you might right something like this:</p>
<pre><code class="lang-javascript">myApp.function1()<span class="hljs-comment">;</span>
myApp.property1 = <span class="hljs-number">3</span><span class="hljs-comment">;</span>
</code></pre>
<p>Here is the same object using the Modular pattern:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyApp = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>{<span class="hljs-string">'use strict'</span>;

    <span class="hljs-keyword">var</span> property1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> property2 = <span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyApp</span><span class="hljs-params">()</span> </span>{ }

    MyApp.prototype.function1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ };

    <span class="hljs-keyword">var</span> function2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ };

    <span class="hljs-keyword">return</span> MyApp;
})();

<span class="hljs-keyword">var</span> myApp = <span class="hljs-keyword">new</span> MyApp();
myApp.function1();
</code></pre>
<p>Notice that when using the modular pattern we:</p>
<ul>
<li>Call new (that is, we create a constructor)</li>
<li>We can&#39;t directly access the private properties</li>
<li>We use the prototype syntax to create a public method.</li>
</ul>
<a class="anchor" id="partII"></a>
<h2>Part II</h2>
<p>Here is a more complete example of the JavaScript module pattern: </p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Point = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-comment">// Private variables</span>
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Private function</span>
    <span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">25</span>; };

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x1, y1</span>) </span>{
        x = x1;
        y = y1;
    }    

    <span class="hljs-comment">// Public method</span>
    Point.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> x + y + bar();
    };      

    <span class="hljs-keyword">return</span> Point;
}());

<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>);    
    <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);      
    el.innerHTML =  point.add(); <span class="hljs-comment">// Print 32    </span>
};
</code></pre>
<p>Notice that the entire method is wrapped in parenthesis:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Point = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">//Code omitted here</span>
}());
</code></pre>
<p>For now, let&#39;s call this section of syntax the &quot;wrapping function.&quot; The
parenthesis around the <em>wrapping function</em> are simply a means of reminding us that we are creating a wrapping function. By putting an open parenthesis at the start, we signal to ourselves that a wrapping function is about to be declared. Then we can scan down for the closing parens and its accompanying function call: ());</p>
<p>In this example, <strong>x</strong>, <strong>y</strong> and <strong>bar</strong>() are all part of the
<strong>Closure</strong>. When you are thinking about the closure, forget the
<em>wrapping function</em>. Focus only on the Point method, which is our
constructor. The code between it and the wrapping method is all part of
a closure. In other words, the method <strong>Point</strong> (our constructor) has access
to <strong>x</strong>, <strong>y</strong> and <strong>bar()</strong> because they are a part of closure. That is the way
closures work: a method has access to the variables and functions
immediately outside the area where it is invoked.</p>
<p>The closure is the function <strong>Point</strong> and the variables around it that it &quot;remembers&quot;. It can access these variables even after the wrapping function has finished executing. The wrapping function is the actual owner of variables like X and Y:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Point = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-comment">// Private variables</span>
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Code omitted here</span>
})(); <span class="hljs-comment">// End of wrapping function</span>
</code></pre>
<p>X and Y belong to our anonymous wrapping function. They belong to the function assigned to the variable Point in the above code fragment. But here, the closure, our <strong>Point</strong> constructor, can &quot;remember&quot; them even though the wrapping function goes out of scope after wrapping function finishes executing. You would think that x and y are gone. Have been cleaned up by the garbage collector and left this fleeting world. But it is not so. They live on because they are caught in the constructor&#39;s closure.</p>
<p>To create a rather silly analogy, a closure is a like a backpack that our constructor or other functions can carry in order to remember the variables that surround them, even if the function that &quot;owns&quot; those variables has gone out of scope. It&#39;s like an inventory in an RPG game. It is a set of tools that the function can access. I don&#39;t necessarily mean to imply that this would be a good way to implement an inventory in an RPG game, only that the function is like the character, and the variables caught in its closure are like its inventory. Its a bag of tricks it can access and carry with it, even when it leaves its home function.</p>
<p>The variables x and y are private. Had they been declared like this,
they would have been public:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">this</span>.x = <span class="hljs-number">1</span>;
</code></pre>
<p>Consider this function</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">25</span>; };
</code></pre>
<p>This is an anonymous functions assigned to the variable bar. You can
invoke the function immediately if you wish:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">25</span>; }();
</code></pre>
<p>In this code we are not assigning a function object to a variable.
Instead we are assigning the result of the function, which is 25, to the
variable.</p>
<p>The problem with this syntax is that it does not tell us that we are
invoking the method instead of returning it until we get to the very end
of the statement. In a long method that can be quite a distance.  As a
result, we have adopted the following convention:</p>
<pre><code><span class="hljs-keyword">var</span> bar = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">25</span>; })();
</code></pre><p>Here the parenthesis around the anonymous function tells us right at the
start that we are going to invoke the function. This is a convention,
not a rule. We don&#39;t have to have the outer parenthesis but we are
better off if we do, and JSHint will catch us out if we don&#39;t include
it. Here is a simple example that illustrates the entire point:</p>
<pre><code class="lang-javascript">    <span class="hljs-keyword">var</span> functionObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    };

    <span class="hljs-keyword">var</span> simpleValue = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    })();

    $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        $(<span class="hljs-string">"#functionObject"</span>).html(functionObject());
        $(<span class="hljs-string">"#simpleValue"</span>).html(simpleValue);        
    });
</code></pre>
<p>Notice that we execute <strong>functionObject(),</strong> while we treat
<strong>simpleValue</strong> as the simple <strong>number</strong> type that it is:</p>
<pre><code>...html(functionObject())<span class="hljs-comment">;</span>
...html(simpleValue)<span class="hljs-comment">;</span>
</code></pre><p>In our module pattern, however, we don&#39;t return a simple value, we
return a function, which is a constructor because we call new on it:</p>
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(x1, y1) {
        x = x1;
        y = y1;
}    

<span class="hljs-keyword">return</span> <span class="hljs-type">Point</span>;
</code></pre><p>... // Code omitted here</p>
<pre><code><span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> <span class="hljs-type">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
</code></pre><p>But what we get back is not just the function <strong>Point,</strong> but the entire
closure, which includes <strong>x</strong>, <strong>y</strong> and <strong>bar</strong>(). The reason we like
this pattern, however, is because the <em>wrapping function</em> forms a
barrier between the closure and the global name space. So we get a fully
protected functional object, with public methods that use prototype, and
private methods and variables that are part of the closure, and none of
it leaks into the global namespace!</p>
<a class="anchor" id="partIII"></a>
<h2>Part III</h2>
<p>Now let&#39;s add a static method:</p>
<pre><code><span class="hljs-keyword">var</span> Point = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-comment">// Private variables</span>
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Private function</span>
    <span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">25</span>; };

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x1, y1</span>) </span>{
        x = x1;
        y = y1;
    }    

    <span class="hljs-comment">// Public static</span>
    Point.hiss = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hiss"</span>;
    };

    <span class="hljs-comment">// Public method</span>
    Point.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> x + y + bar();
    };      

    <span class="hljs-keyword">return</span> Point;
})();

<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>);
    <span class="hljs-keyword">var</span> el2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content2'</span>);
    <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);      
    el.innerHTML =  point.add(); <span class="hljs-comment">// Print 32</span>
    el2.innerHTML = Point.hiss();
};
</code></pre><p>Note that we Point.hiss, not point.hiss(). This is because hiss() is
static.</p>
<p>Get the
Source: <a href="/courses/795060/files/23272886/download?wrap=1" title="Point03.zip">Point03.zip</a></p>
<a class="anchor" id="proto"></a>
<h2>Cannot Read Property Prototype of Undefined</h2>
<p>The &quot;cannot read property &#39;prototype&#39; of undefined&quot; usually occurs if
you forget to declare a constructor for your object.</p>
<p>Suppose your module pattern object is supposed to look like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyFunction04 = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-keyword">var</span> field01 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> field02 = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFunction04</span>(<span class="hljs-params">initField01, initField02</span>) </span>{
        field01 = initField01;
        field02 = initField02;
    }

    MyFunction04.prototype.nestedFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> field01 + field02;
    };

    <span class="hljs-keyword">return</span> MyFunction04; <span class="hljs-comment">// Return constructor</span>
}());
</code></pre>
<p>But by mistake, you forgot to declare the constructor:</p>
<pre><code class="lang-javascript">    <span class="hljs-keyword">var</span> MyFunction04 = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">        'use strict'</span>;

        <span class="hljs-keyword">var</span> field01 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> field02 = <span class="hljs-number">0</span>;

        <span class="hljs-comment">// Somethings missing here abouts....</span>

        MyFunction04.prototype.nestedFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> field01 + field02;
        };    

        <span class="hljs-keyword">return</span> MyFunction04;
    }());
</code></pre>
<p>Then in that case you will get the error you are getting.</p>
<p>So you need to be sure to follow this kind of pattern:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> App = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-comment">// Don't forget the constructor!</span>
   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span><span class="hljs-params">()</span> </span>{ }

    <span class="hljs-keyword">return</span> App;
})();
</code></pre>
<a class="anchor" id="thoughts-on-private-and-public-methods-and-the-module-pattern"></a>
<h2>Thoughts on Private and Public Methods and the Module Pattern</h2>
<p>Some half formed thoughts on public and private methods.</p>
<p>When we use prototype, we create public methods:</p>
<pre><code><span class="hljs-type">Bar</span>.proto<span class="hljs-keyword">type</span>.goober() = function()
</code></pre><p>When we use var foo = function() we create private methods:</p>
<pre><code><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{}
</code></pre><p>To call a private method from a public method, just call it by name:</p>
<pre><code>foo()<span class="hljs-comment">;</span>
</code></pre><p>When we call public methods from public methods use this:</p>
<pre><code><span class="hljs-keyword">this</span>.goober();
</code></pre><p>There is no simple way to call a public method from a private method using
our module pattern. Sometimes I create a private method and wrap
calls to in a public method:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> App = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span><span class="hljs-params">()</span> </span>{}

   <span class="hljs-keyword">var</span> privateBar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-comment">// Implement Bar here</span>
   };

  App.prototype.Bar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
     privateBar();
  }

  <span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
     privateBar();
  }

  <span class="hljs-keyword">return</span> App;
})();
</code></pre>
<p>With the system shown above we can call privateBar from either a public
function or a private function, thus exposing it to other objects but still
making it easily accessible to private methods in our class.</p>
<a class="anchor" id="module-basics"></a>
<h2>Module Basics</h2>
<p>Simplified modular pattern:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyObject1 = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyObject2</span><span class="hljs-params">()</span> </span>{ }

     <span class="hljs-keyword">return</span> MyObject2;
}());
</code></pre>
<p>The modular pattern is interested in the <strong>MyObject2</strong> constructor, which is what it returns. As a result MyObject1 ends up being assigned the value <strong>MyObject2</strong>, which is a constructor.</p>
<p>Since MyOjbect2 is a function constructor, it will not work properly unless you call new on it. It doesn&#39;t fail to work entirely if you don&#39;t call new. It just won&#39;t work properly. In particular, it will have no prototype. Without a properly initialized prototype object, then MyObject2 will not work properly. For instance, the method called runReader won&#39;t work. Other methods, such as parse() will work since they don&#39;t depend on the prototype. But in some cases it will be hard to get at the parse() method, but you do provide an event registration event that references it, and so that part of your code will work.</p>
<a class="anchor" id="references"></a>
<h2>References</h2>
<ul>
<li><a href="https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc">JavaScript Modules: A Beginners Guide</a></li>
<li><a href="(http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#objects)">Elvenware Objects</a></li>
<li><a href="(http://www.elvenware.com/charlie/development/web/JavaScript/Basics.html#compareObjFunc)">Elvenware Basics Compare Object Functions</a></li>
<li><a href="(http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth)">http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth</a></li>
<li><a href="(http://stackoverflow.com/questions/1114024/constructors-in-javascript-objects)">http://stackoverflow.com/questions/1114024/constructors-in-javascript-objects</a></li>
<li><a href="(http://addyosmani.com/resources/essentialjsdesignpatterns/book/#designpatternsjavascript)">http://addyosmani.com/resources/essentialjsdesignpatterns/book/#designpatternsjavascript</a></li>
<li><a href="http://blixt.org/js">http://blixt.org/js</a></li>
</ul>
</div></body></html>