<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>JavaScriptReact</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>JavaScriptReact</h1><p>Welcome to JavaScriptReact</p><ul><!--TOC_Start--><li><a href="#react">React</a></li>
<li><a href="#create-react-app">Create React Application</a></li>
<li><a href="#fetch">Rest with <em>fetch</em></a></li>
<li><a href="#more-fetch">More on <strong>fetch</strong></a></li>
<li><a href="#enospc">ENOSPC Error</a></li>
<li><a href="#props-single-node">Props Single Node Error</a></li>
<li><a href="#react-in-webstorm">React in WebStorm</a></li>
<li><a href="#enzyme-mount-vs-shallow">Enzyme mount vs shallow</a></li>
<li><a href="#react-links">React Links</a></li>
<li><a href="#enzyme-debug-class">Enzym Debug Class</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="react"></a>
<h1>React</h1>
<p>Information on React.</p>
<a class="anchor" id="create-react-app"></a>
<h2>Create React Application</h2>
<p>Here is a simple way to create a React Application.</p>
<p>We want create-react-app to open Chrome or Chromium, not FireFox. (Unless you really prefer FireFox. But I tend to use Chrome or Chromium.)</p>
<p>Click the Gear icon (Menu) at the top right of Lubuntu. Choose <strong>System Settings</strong>. Open up <strong>Details</strong>. Select <strong>Default Applications</strong>. Pick Chrome or Chromium, as you prefer. More details are <a href="https://help.ubuntu.com/stable/ubuntu-help/net-default-browser.html">here</a></p>
<pre>npm install -g create-react-app
mkdir ~/Source
cd ~/Source
create-react-app test
cd test
npm start
</pre>
<a class="anchor" id="fetch"></a>
<h2>Rest with <em>fetch</em></h2>
<p>Use <strong>fetch</strong> to retrieve data from the server. We make REST calls with <strong>fetch</strong>. For those familiar with jQuery, we will use fetch in lieu of <strong>$.ajax</strong> or <strong>$.getJSON</strong>.</p>
<p><strong>fetch</strong> will eventually become part of JavaScript in ES6, but for now we have to install it separately:</p>
<pre>npm install --save whatwg-fetch
</pre>
<p>In some cases, you may need to add it to <strong>webpack.config.js</strong> or <strong>config/webpack.config.dev.js</strong> in the <strong>entry</strong> property:</p>
<pre>entry: [
    'whatwg-fetch',
    ... and so on
]
</pre>
<p>Here is a simple call to fetch:</p>
<pre>bar = () => {
    const that = this;
    fetch('/api/foo')
        .then(function(response) {
            return response.json();
        }).then(function(json) {
            console.log('parsed json', json);
            that.setState(foo => (json));
        }).catch(function(ex) {
            console.log('parsing failed', ex);
        });
};
</pre>
<a class="anchor" id="more-fetch"></a>
<h2>More on <strong>fetch</strong></h2>
<p>You might notice that there are two calls to <strong>.then</strong> methods in our <strong>fetch</strong> promise:</p>
<ul>
<li>The first reports on the status of the call</li>
<li>The second is called when data is returned from the server.</li>
</ul>
<p>This example checks to <strong>reponse.ok</strong> in the first <strong>.then</strong> method of our promise to see that everything is good:</p>
<pre>const getServer = (url, dispatch) => {
    fetch(url)
        .then(function(response) {
            if (response.ok) {
                return response.json();
            } else {
                throw new Error(response.statusText + '\n' +
                    response.url + '\n' +
                    'status: ' + response.status);
            }
        }).then(function(json) {
            dispatch({
                type: 'YOU-RANG',
                youRang: json
            });
        }).catch(function(ex) {
            alert(ex);
            console.log('parsing failed', ex);
        });

};
</pre>
<p>Or in excruciating detail, here are the things you can check when documenting the status of a call:</p>
<pre>const getServer = (url, dispatch) => {
    fetch(url)
        .then(function(response) {
            console.log('fetch ok:', response.ok);
            console.log('fetch status:', response.status);
            console.log('fetch statusText:', response.statusText);
            console.log('fetch type:', response.type);
            console.log('fetch url:', response.url);
            console.log('fetch body used:', response.bodyUsed);
            const json = response.json();
            console.log('fetch json:', json);
            if (response.ok) {
                return json;
            } else {
                throw new Error(response.statusText + '\n' +
                    response.url + '\n' +
                    'status: ' + response.status);
            }
        }).then(function(json) {
            dispatch({
                type: 'YOU-RANG',
                youRang: json
            });
        }).catch(function(ex) {
            alert(ex);
            console.log('parsing failed', ex);
        });

};
</pre>
<a class="anchor" id="enospc"></a>
<h2>ENOSPC Error</h2>
<p>While testing, If you get an <strong>ENOSPC</strong> error, do this:</p>
<ul>
<li><strong>sudo nano /etc/sysctl.conf</strong></li>
<li>Scroll to the bottom of the document.</li>
<li>Add this line: <strong>fs.inotify.max_user_watches = 524288</strong></li>
<li>Save with <strong>Ctrl-O</strong>, exit with <strong>Ctrl-X</strong>.</li>
<li>Then run: <strong>sudo sysctl -p</strong></li>
</ul>
<p><img src="https://s3.amazonaws.com/bucket01.elvenware.com/images/react-props-enospc.png" alt="More watches"></p>
<a class="anchor" id="props-single-node"></a>
<h2>Props Single Node Error</h2>
<p>Here is the error: <em>Method “props” is only meant to be run on a single node. 0 found instead.</em></p>
<p>I got this when I had a mismatch between what I thought a button click method was called and what it was really called. For instance, here is my test:</p>
<pre>wrapper.find('button#foo').simulate('click');
</pre>
<p>And here is my JSX:</p>
<pre><button id="bar" onClick={this.getBar}>Get User</button>
</pre>
<p>Note that the <strong>ID</strong> of the button is <strong>bar</strong>, but I&#39;m trying to <strong>find</strong> something with an <strong>ID</strong> of <strong>foo</strong>. To fix the proplem, bring them into sync:</p>
<pre>wrapper.find('button#bar').simulate('click');
</pre>
<a class="anchor" id="react-in-webstorm"></a>
<h2>React in WebStorm</h2>
<ul>
<li><a href="http://bit.ly/webstorm-react">From JetBrains</a></li>
</ul>
<p><strong>NOTE</strong>: <em>Assuming you are working with ES6, JSX and React, from the menu select <strong>File | Settings | Languages and Frameworks | JavaScript</strong> and set the language version to <strong>React JSX</strong></em></p>
<a class="anchor" id="enzyme-mount-vs-shallow"></a>
<h2>Enzyme mount vs shallow</h2>
<p>Suppose one component nests another. For instance, suppose that your custom component <strong>MyComponent</strong> renders a second component called <strong>MyOtherComponent</strong>. Here is <strong>MyComponent&#39;s</strong> render method :</p>
<pre>class MyComponent extends Component {
  render() {
      return (
          <div>
              <MyOtherComponent />
          </div>
      );
  }
}
</pre>
<p>Here <strong>MyComponent</strong> does nothing but ask <strong>MyOtherComponent</strong> to render itself.</p>
<p>In cases like this, if you use Enzyme&#39;s <a href="https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md">shallow</a>, you will only see the output from <strong>MyComponent</strong>. During the test, it will seem as though <strong>MyOtherComponent</strong> does not exist, or at least does not render anthing. Indeed, that is often what you want. But sometimes, it is best to see the output from both <strong>MyComponent</strong> and <strong>MyOtherComponent</strong>. To do that, you use <strong>mount</strong> rather than <strong>shallow</strong>. We usually do this:</p>
<pre>import { shallow } from 'enzyme';
</pre>
<p>If you want to see output from both components, then do this:</p>
<pre>import { mount } from 'enzyme';
</pre>
<a class="anchor" id="react-links"></a>
<h2>React Links</h2>
<ul>
<li><a href="https://facebook.github.io/react/">React</a></li>
<li><a href="https://facebook.github.io/react-native/">React Native</a></li>
<li><a href="https://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/">JavaScript Versions</a></li>
<li>EcmaScript 6<ul>
<li><a href="https://github.com/lukehoban/es6features">Es6 Luke Hoban</a></li>
<li><a href="http://es6-features.org/#ClassInheritance">Es6 Quick View</a></li>
</ul>
</li>
<li>create-react-app<ul>
<li><a href="https://github.com/facebookincubator/create-react-app">Home Page on GitHub</a></li>
<li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md">Documentation</a></li>
<li><a href="https://github.com/vhf/free-programming-books/blob/master/javascript-frameworks-resources.md">ReactBooks</a></li>
</ul>
</li>
<li>Jest and Enzyme<ul>
<li><a href="http://airbnb.io/enzyme/">Enzyme</a></li>
</ul>
</li>
</ul>
<a class="anchor" id="enzyme-debug-class"></a>
<h2>Enzym Debug Class</h2>
<p>We have several debug functions that we often append to the top of our test files. This violates our DRY principle. As a result, I&#39;ve created the following simple class which we can reuse in multiple tests:</p>
<ul>
<li><a href="https://gist.github.com/charliecalvert/51daef341699943b07c9570c3ad2cbab">ElfEnzymeDebug</a></li>
</ul>
<p>We could also, at least in theory, add to this class over time as we discover more useful tests.</p>
</div></body></html>