<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>JavaScriptObjects</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap-theme.min.css"><!-- link(href='/libs/css/BootstrapIndex.css', rel='stylesheet', type='text/css')--><link href="/css/style.css" rel="stylesheet" type="text/css"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><script src="/components/jquery/dist/jquery.js"></script><script src="/components/angular/angular.js"></script><script src="/components/angular-route/angular-route.js"></script><script src="/components/bootstrap/dist/js/bootstrap.min.js"></script><!-- script(src='/libs/scripts/elvenware.js', type='text/javascript')--><script src="/libs/scripts/Control.js"></script><!-- script(src='http://localhost:35729/livereload.js')--></head><body><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/charlie/About.html">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/charlie/development/index.html">Strongly Typed</a></li><li><a href="/charlie/development/web/index.html">Web & Scripts</a></li><li><a href="/charlie/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/charlie/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>JavaScriptObjects</h1><p>Welcomes to JavaScriptObjects</p><ul><!--TOC_Start--><li><a href="#overview">Overview</a></li>
<li><a href="#createObjects">Creating Objects</a></li>
<li><a href="#object-literal">Object Literal Syntax</a></li>
<li><a href="#function-objects">Function Objects</a></li>
<li><a href="#new-operator">The new Operator</a></li>
<li><a href="#properties-and-methods">Properties and Methods</a></li>
<li><a href="#propIntro">Property Introduction</a></li>
<li><a href="#methodIntroduction">Method Introduction</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#multipleProperties">Objects with Multiple Properties</a></li>
<li><a href="#outside">Declare Properties Outside the Object Literal</a></li>
<li><a href="#enumerating-properties">Enumerating Properties</a></li>
<li><a href="#property-attributes">Property Attributes</a></li>
<li><a href="#defineproperty">DefineProperty</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#use-strict-and-methods">Use Strict and Methods</a></li>
<li><a href="#public-and-private-variables">Public and Private Variables</a></li>
<li><a href="#share-data-between-objects">Share Data Between Objects</a></li>
<li><a href="#object-maps">Object Maps</a></li>
<li><a href="#sorting">Sorting</a></li>
<li><a href="#properties-and-constants">Properties and Constants</a></li>
<li><a href="#dictionaries">Dictionaries</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#links">Links</a></li><!--TOC_End--></ul><h1 id="overview">Overview</h1>
<p>In this chapter we will start with a quick overview of the some built in JavaScript Objects such as Arrays. After covering the basics about these topics we will move on to our main subject, which is creating custom JavaScript Objects.</p>
<h1 id="createObjects">Creating Objects</h1>
<p>You can declare an object like this:</p>
<pre><code><span class="hljs-variable"><span class="hljs-keyword">var</span> myObject</span> = {};
</code></pre><p>This type of object declaration is called an <strong>object literal</strong>. You can compare this to using the new operator, which produces the same result:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
</code></pre><p>When you declare an object as we do <strong>myObject</strong>, we usually don&#39;t call <strong>new</strong> on it. As discussed above, the following two statements are essentially identical:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = {};
<span class="hljs-keyword">var</span> myObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
</code></pre><p>However, we prefer the first.</p>
<h1 id="object-literal">Object Literal Syntax</h1>
<p>As you know, the simplest possible JavaScript object declared using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals">object literal</a> syntax looks like this:</p>
<pre><code class="lang-javascript"><span class="hljs-variable"><span class="hljs-keyword">var</span> myObject</span> = {};
</code></pre>
<p>This is a slightly more complex object, again declared using object literal syntax:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> person = {
  firstName: <span class="hljs-string">'Suzie'</span>
};
</code></pre>
<p>The object shown above has is called <strong>person</strong>. It has one property called <strong>firstName</strong> of type string.</p>
<p>Here is a second way to declare the same object. First we create the object using object literal syntax, then we use dot notation to create the name property:</p>
<pre><code class="lang-javascript">var person = {}<span class="hljs-comment">;</span>
person.firstName = <span class="hljs-string">'Suzie'</span><span class="hljs-comment">;</span>
</code></pre>
<p>As far as we are concerned at this point, there is no significant difference between these two ways of declaring an object.</p>
<p>This is a method that is part of an object literal:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> person = {
    sayHello: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>);
    }
};
</code></pre>
<p>This method is not part of the <strong>person</strong> object but not part an object literal declaration:</p>
<pre><code class="lang-javascript">person.sayGoodbye: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Goodbye'</span>);
}
</code></pre>
<p><strong>NOTE</strong>: <em>Most properly constructed function return a value rather than simply writing something to the console. The <strong>sayHello</strong> method does not return a value because it is designed to be a very simple, if impractical, method.</em></p>
<h1 id="function-objects">Function Objects</h1>
<p>This is a function object:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> a: <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{}
};
</code></pre>
<p>In this chapter we are not concerned with this kind of object. See the <a href="http://www.elvenware.com/charlie/development/web/JavaScript/JavaScriptFunctions.html">JavaScript Functions</a> chapter for details on that subject.</p>
<h1 id="new-operator">The new Operator</h1>
<p>We should prefer object literals to the <strong>new</strong> operator. For instance:</p>
<table>
<thead>
<tr>
<th>Preferred</th>
<th>Not Preferred</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>var</strong> myArray = []</td>
<td><strong>var</strong> myArray = new Array()</td>
</tr>
<tr>
<td><strong>var</strong> myObject = {}</td>
<td><strong>var</strong> myObject = new Object()</td>
</tr>
<tr>
<td><strong>var</strong> myNumber = 3</td>
<td><strong>var</strong> myNumber = new Number(3)</td>
</tr>
<tr>
<td><strong>var</strong> myStr = &#39;Arf&#39;</td>
<td><strong>var</strong> myStr = new String(&#39;arf&#39;)</td>
</tr>
<tr>
<td><strong>var</strong> myBool = true</td>
<td><strong>var</strong> myBool = new Boolean(false)</td>
</tr>
<tr>
<td>=====================</td>
<td>===================================</td>
</tr>
</tbody>
</table>
<p>Crockford covers this issue in Appendix B of <strong>JavaScript, the Good Parts</strong>. He writes:</p>
<blockquote>
<p>JavaScript has a set of typed wrappers. For example:</p>
<p><strong>new Boolean(false)</strong></p>
<p>produces an object that has a valueOf method that returns the wrapped value. This turns out to be completely unnecessary and occasionally confusing.</p>
<p>Don&#39;t use new Boolean or new Number or new String.</p>
</blockquote>
<p>Also avoid new Object and new Array. Use {} and [] instead.</p>
<p>Crockford&#39;s Appendix B is on the web <a href="http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/bad-parts.html">here</a>.</p>
<p>Having said all this, I still do use <strong>new</strong> in one or two cases. In particular, I most often use <strong>new</strong> when creating my own objects using the module pattern.</p>
<p>This gets tricky, because Crockford follows up the text I quote above with advice that appears to say we should not use <strong>new</strong> even to create our own objects. I don&#39;t think that is what he meant to say, or if he did mean to say it, I don&#39;t agree. Much of the best code I&#39;ve seen uses <strong>new</strong> when creating custom objects.</p>
<p>Just to be clear, I agree with all I have quoted from Crockford above about <strong>Boolean</strong>, <strong>Array</strong>, <strong>Number</strong>, and <strong>String</strong>. And for creating empty <strong>Objects</strong>. Don&#39;t use <strong>new</strong> with them. But using <strong>Constructor</strong> objects and <strong>new</strong>, particularly in the module pattern, is a good idea. It brings many benefits, including help with the <strong>this</strong> operator.</p>
<p><strong>NOTE</strong>: <em>The confusion that often springs up around <strong>Constructor</strong> objects and the <strong>new</strong> keyword is a major reason to move to ES6 and its <strong>class</strong> syntax. I am, in fact, moving to ES6 in most of my new code. Unfortunately, that is not yet reflected in this documentation.</em></p>
<h1 id="properties-and-methods">Properties and Methods</h1>
<p>The next two section briefly outline properties and methods. Once you have had a glimpse of the basic syntax, I will circle back around and discuss both properties and methods in more depth.</p>
<ul>
<li><a href="#properties">Properties in Depth</a></li>
<li><a href="#methods">Methods</a></li>
</ul>
<h2 id="propIntro">Property Introduction</h2>
<p>Inside the curly braces of your object literal you can define your object. Objects are merely a list of name:value pairs:</p>
<pre><code>var myObject = {
<span class="hljs-attr">    a:</span> <span class="hljs-number">1</span>,
<span class="hljs-attr">    b:</span> <span class="hljs-number">2</span>,
<span class="hljs-attr">    c:</span> <span class="hljs-string">'three'</span>
};
</code></pre><p>Each name:value pair shown in the above example is called a property. In the first example, <strong>a</strong> is the property name, and <strong>1</strong> is the property value.</p>
<h2 id="methodIntroduction">Method Introduction</h2>
<p>Here is how to add a method to your object:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = {
    a: <span class="hljs-number">1</span>,
    b: <span class="hljs-number">2</span>,
    c: <span class="hljs-string">'three'</span>,
    four: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{}
};
</code></pre><p>Note that this function is just another key:value, or name:value pair:</p>
<pre><code><span class="hljs-keyword">name</span> | <span class="hljs-keyword">value</span>
four | <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {}
</code></pre><p>Besides properties and methods, objects can also contain other objects. Through a feature called a <strong>prototype</strong>, objects can implement inheritance.</p>
<p>Unless you specify otherwise, JavaScript objects can be modified at any time. In particular, anyone who can execute code in your runtime can add or delete methods or properties. EcmaScript 5 provides means of making objects immune to this kind of manipulation.</p>
<h2 id="properties">Properties</h2>
<p>As stated above, properties are name value pairs, where name is a string.</p>
<pre><code><span class="hljs-keyword">var</span> myObject = { <span class="hljs-string">'myProperty'</span>: <span class="hljs-number">12</span> };
</code></pre><p>The above code declares a simple object with a single property called <strong>myProperty</strong>. The value of <strong>myProperty</strong> is twelve. We talk of properties of this type as being key:value pairs. The <strong>key</strong> is <strong>myProperty</strong> and the <strong>value</strong> is <strong>12</strong>.</p>
<p>The quotes around a property name are optional if the name is a legal Javascript identifier:</p>
<pre><code><span class="hljs-variable"><span class="hljs-keyword">var</span> myObject</span> = { myProperty: <span class="hljs-number">12</span> };
</code></pre><p>You can access a property with either of two notations:</p>
<pre><code>myObject.myProperty<span class="hljs-comment">;</span>
myObject[<span class="hljs-string">'myProperty'</span>]<span class="hljs-comment">;</span>
</code></pre><p>You can then treat the property as you would explect. Here I try to run through the common permutations for accessing <strong>myProperty</strong>.</p>
<pre><code>var myObject = {
    myProperty : <span class="hljs-number">12</span>
}<span class="hljs-comment">;</span>

console.log(myObject.myProperty)<span class="hljs-comment">;</span>
console.log(myObject[<span class="hljs-string">"myProperty"</span>])

myObject[<span class="hljs-string">'myProperty'</span>] = <span class="hljs-number">3</span><span class="hljs-comment">;</span>
var valueA = myObject.myProperty<span class="hljs-comment">;</span>
console.log(valueA)<span class="hljs-comment">;</span>

myObject.myProperty = <span class="hljs-number">5</span><span class="hljs-comment">;</span>
var valueB = myObject[<span class="hljs-string">'myProperty'</span>]<span class="hljs-comment">;</span>
console.log(valueB)<span class="hljs-comment">;</span>
</code></pre><p>This syntax is less than ideal, however, since we are repeating the string <em>myProperty</em> multiple times. A useful solution would look like this:</p>
<pre><code>var myObject = {
    myProperty : <span class="hljs-number">12</span>
}<span class="hljs-comment">;</span>

var myProperty = <span class="hljs-string">"myProperty"</span><span class="hljs-comment">;</span>

console.log(myObject.myProperty)<span class="hljs-comment">;</span>
console.log(myObject[myProperty])<span class="hljs-comment">;</span>

myObject[myProperty] = <span class="hljs-number">3</span><span class="hljs-comment">;</span>
var valueA = myObject.myProperty<span class="hljs-comment">;</span>
console.log(valueA)<span class="hljs-comment">;</span>

myObject.myProperty = <span class="hljs-number">5</span><span class="hljs-comment">;</span>
var valueB = myObject[myProperty]<span class="hljs-comment">;</span>
console.log(valueB)<span class="hljs-comment">;</span>
</code></pre><p>I hesitated to show you this second solution as the first take because you might get confused by the expression <strong>myObject[myProperty]</strong>. In this code <strong>myProperty</strong> refers to the string declared near the top of the listing. Hungarian notation is usually not useful in JavaScript, but if we bring it back for a moment, our code would look like this:</p>
<pre><code>var myObject = {
    myProperty : <span class="hljs-number">12</span>
}<span class="hljs-comment">;</span>

var myPropertyStr = <span class="hljs-string">"myProperty"</span><span class="hljs-comment">;</span>

console.log(myObject.myProperty)<span class="hljs-comment">;</span>
console.log(myObject[myPropertyStr])<span class="hljs-comment">;</span>

myObject[myPropertyStr] = <span class="hljs-number">3</span><span class="hljs-comment">;</span>
var valueA = myObject.myProperty<span class="hljs-comment">;</span>
console.log(valueA)<span class="hljs-comment">;</span>

myObject.myProperty = <span class="hljs-number">5</span><span class="hljs-comment">;</span>
var valueB = myObject[myPropertyStr]<span class="hljs-comment">;</span>
console.log(valueB)<span class="hljs-comment">;</span>
</code></pre><p>Notice that we now declare the string that represents the name of our property like this:</p>
<p>var myPropertyStr = &quot;myProperty&quot;;</p>
<p>Hopefully that makes code like the following easier to read:</p>
<pre><code>var myPropertyStr = <span class="hljs-string">"myProperty"</span><span class="hljs-comment">;</span>

console.log(myObject.myProperty)<span class="hljs-comment">;</span>
console.log(myObject[myPropertyStr])<span class="hljs-comment">;</span>
</code></pre><p>In any case, regardless of which permuation of the program you use, the output looks like this:</p>
<pre><code>&gt;<span class="hljs-keyword">node</span> <span class="hljs-title">index</span>.js
<span class="hljs-number">12</span>
<span class="hljs-number">12</span>
<span class="hljs-number">3</span>
<span class="hljs-number">5</span>
</code></pre><ul>
<li><a href="(https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Objects/ObjectNameValue)">The source is in JsObjects</a></li>
</ul>
<p>Though both examples are legal, the first is much more common.</p>
<p><a href="BasicSyntax.html#sameProprties">Try it.</a></p>
<h2 id="multipleProperties">Objects with Multiple Properties</h2>
<p>To declare an object with multiple properties, separate them with commas:</p>
<pre><code><span class="hljs-variable"><span class="hljs-keyword">var</span> myObject</span> = {    
    myProperty01: <span class="hljs-number">12</span>,
    myProperty02: <span class="hljs-number">4</span>                   
};
</code></pre><p>Here is a JavaScript object with three properties, one of which is a function:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = {    
    myProperty01: <span class="hljs-number">12</span>,
    myProperty02: <span class="hljs-number">4</span>,
    myFunction: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 + <span class="hljs-keyword">this</span>.myProperty02;
    }                   
};
</code></pre><p>If you have more than one function, separate them with commas:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = {    
    myProperty01: <span class="hljs-number">12</span>,
    myProperty02: <span class="hljs-number">4</span>,
    addProperties: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 + <span class="hljs-keyword">this</span>.myProperty02;
    },
    multiplyProperties: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 * <span class="hljs-keyword">this</span>.myProperty02;
    }                   
};

<span class="hljs-built_in">console</span>.log(myObject.multiplyProperties());
</code></pre><p>Note that we call the function <strong>multiplyProperties</strong> by writing:</p>
<pre><code><span class="hljs-selector-tag">myObject</span><span class="hljs-selector-class">.multiplyProperties</span>()
</code></pre><p>In this case, it yields the result <strong>48</strong>, as shown in the program from JsObjects called ObjectDemo01:</p>
<pre><code>JsObjects<span class="hljs-regexp">/Syntax/</span>ObjectDemo01
</code></pre><p><strong>Note</strong> We use the keyword <strong>var</strong> when declaring <strong>myObject</strong> but not when we declare <strong>myProperty01</strong> or <strong>addProperties</strong>. This can be confusing to newcomers, but the rule is simple and relatively reasonable: the properties of an object are not declared with <strong>var</strong>.</p>
<h1 id="outside">Declare Properties Outside the Object Literal</h1>
<p>We can create an object using object literal syntax, then add properties and methods to it using dot notation:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myObject = {};

myObject.name = <span class="hljs-string">'Sarah'</span>;

myObject.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(operatorA, operatorB)</span> </span>{
  <span class="hljs-keyword">return</span> operatorA + operatorB;
}
</code></pre>
<h2 id="enumerating-properties">Enumerating Properties</h2>
<p>There are several ways to get a list of the properties on an object. Consider this object:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = {
    myProperty01 : <span class="hljs-number">12</span>,
    myProperty02 : <span class="hljs-number">4</span>,
    addProperties : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-string">'use strict'</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 + <span class="hljs-keyword">this</span>.myProperty02;
    },
    multiplyProperties : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-string">'use strict'</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 * <span class="hljs-keyword">this</span>.myProperty02;
    }
};
</code></pre><p>We can get the list of properties on the object:</p>
<pre><code><span class="hljs-built_in">var</span> <span class="hljs-built_in">keys</span> = Object.<span class="hljs-built_in">keys</span>(myObject);
</code></pre><p>The call to <strong>Object.keys</strong> returns a list of all the properties on <strong>myObject</strong>. As a result, <strong>keys</strong> now has the following properties:</p>
<pre><code>[<span class="hljs-string">"myProperty01"</span>, <span class="hljs-string">"myProperty02"</span>, <span class="hljs-string">"addProperties"</span>, <span class="hljs-string">"multiplyProperties"</span>]
</code></pre><p>We can also do this:</p>
<pre><code>for (<span class="hljs-keyword">property</span><span class="hljs-title"> </span><span class="hljs-keyword">in</span> myObject) {
    display(<span class="hljs-keyword">property</span><span class="hljs-title"></span>);
};
</code></pre><p>The for loop shown above yields the following output.</p>
<pre><code><span class="hljs-symbol">myProperty01</span>
<span class="hljs-symbol">myProperty02</span>
<span class="hljs-keyword">addProperties
</span><span class="hljs-keyword">multiplyProperties</span>
</code></pre><p>Because the world is a fussy place, it is usually considered best to do the following:</p>
<pre><code>for (<span class="hljs-keyword">property</span><span class="hljs-title"> </span><span class="hljs-keyword">in</span> myObject) {
    if (myObject.hasOwnProperty(<span class="hljs-keyword">property</span><span class="hljs-title"></span>)) {
        display(<span class="hljs-keyword">property</span><span class="hljs-title"></span>);
    }
};
</code></pre><p>If you <strong>use strict</strong> then it is an error to omit the <strong>if</strong> clause. The <strong>hasOwnProperty</strong> method returns only properties declared on an object, and not those properties inherited by an object. For instance, <strong>hasOwnProperty</strong> returns true for <strong>myProperty01</strong> but false for the inherited <strong>toString</strong> property. The object actually has both properties, but of the two, only <strong>myProperty01</strong> is an <strong>own</strong> property. And yes, <strong>own</strong> is a technical term.</p>
<p>Interestingly, and somewhat mysteriously from my point of view, our for loop returns the same output whether or not I call <strong>hasOwnProperty</strong>.</p>
<h2 id="property-attributes">Property Attributes</h2>
<p>Each property can be, in some circumstances:</p>
<ul>
<li>Enumerable (Can be discovered by enumeration with <strong>for x in obj</strong>)</li>
<li>Configurable (Can be deleted)</li>
<li>Writable (ReadWrite vs ReadOnly)</li>
</ul>
<p>You can use getOwnPropertyDescriptor to explore the attributes of a property:</p>
<pre><code>Object.getOwnPropertyDescriptor([object Name], [<span class="hljs-keyword">property</span><span class="hljs-title"> </span>Name])
</code></pre><p>For example:</p>
<pre><code><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.getOwnPropertyDescriptor</span>(<span class="hljs-selector-tag">myObject</span>, <span class="hljs-selector-tag">propName</span>);
</code></pre><p>To see the method in action, let&#39;s return to this simple object:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = {
        myProperty01: <span class="hljs-number">12</span>,
        myProperty02: <span class="hljs-number">4</span>,
        addProperties: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">            'use strict'</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 + <span class="hljs-keyword">this</span>.myProperty02;
        },
        multiplyProperties: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">            'use strict'</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 * <span class="hljs-keyword">this</span>.myProperty02;
        }    
    };
</code></pre><p>Let&#39;s create a simple method that will display some text both in an HTML page and at the console:</p>
<pre><code><span class="hljs-keyword">var</span> display = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-built_in">console</span>.log(value);
        $(<span class="hljs-string">"#debug"</span>).append(<span class="hljs-string">'&lt;li&gt;'</span> + value + <span class="hljs-string">'&lt;/li&gt;'</span>);
    };
</code></pre><p>Now let&#39;s explore the descriptor for each of myObject&#39;s properties:</p>
<pre><code><span class="hljs-keyword">var</span> getPropertyDescriptor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">propName</span>) </span>{
        <span class="hljs-keyword">var</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(myObject, propName);
        <span class="hljs-keyword">var</span> description = <span class="hljs-built_in">JSON</span>.stringify(descriptor);
        display(description);
    };

    <span class="hljs-keyword">var</span> getPropertyIsEnumerable = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">propName</span>) </span>{
        <span class="hljs-keyword">var</span> isEnumerable = myObject.propertyIsEnumerable(propName) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>;
        display(<span class="hljs-string">"enumerable: "</span> + isEnumerable);
    };

    $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        display(myObject.multiplyProperties());
        <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(myObject);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
            <span class="hljs-keyword">var</span> propName = keys[i];
            display(propName);
            getPropertyDescriptor(propName);
            getPropertyIsEnumerable(propName);
        }
    });
</code></pre><p>Notice how we get the list of properties on the object:</p>
<pre><code><span class="hljs-built_in">var</span> <span class="hljs-built_in">keys</span> = Object.<span class="hljs-built_in">keys</span>(myObject);
</code></pre><p>The call to <strong>Object.keys</strong> returns a list of all the properties on <strong>myObject</strong>.</p>
<p>The key call here is to <strong>getOwnPropertyDescriptor</strong>. However, I also call <strong>propertyIsEnumerable</strong> just so you can see that the method is available. Here is the output:</p>
<pre><code>48
<span class="hljs-keyword">myProperty01</span>
    {<span class="hljs-string">"value"</span>:<span class="hljs-number">12</span>,<span class="hljs-string">"writable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"enumerable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"configurable"</span>:<span class="hljs-keyword">true</span>}
    <span class="hljs-keyword">enumerable</span>: true
<span class="hljs-keyword">myProperty02</span>
    {<span class="hljs-string">"value"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"writable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"enumerable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"configurable"</span>:<span class="hljs-keyword">true</span>}
    <span class="hljs-keyword">enumerable</span>: true
<span class="hljs-keyword">addProperties</span>
    {<span class="hljs-string">"writable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"enumerable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"configurable"</span>:<span class="hljs-keyword">true</span>}
    <span class="hljs-keyword">enumerable</span>: true
<span class="hljs-keyword">multiplyProperties</span>
    {<span class="hljs-string">"writable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"enumerable"</span>:<span class="hljs-keyword">true</span>,<span class="hljs-string">"configurable"</span>:<span class="hljs-keyword">true</span>}
    <span class="hljs-keyword">enumerable</span>: true
</code></pre><p>This example is <a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Objects/ObjectDemo01/ObjectDemo01.js">available in JsObjects</a>.</p>
<h1 id="defineproperty">DefineProperty</h1>
<p>The <strong>defineProperty</strong> method is a fancy version of a standard JavaScript property. Here is what we normally do:</p>
<pre><code>foo.myProperty = <span class="hljs-number">3</span><span class="hljs-comment">;</span>
</code></pre><p>By using <strong>defineProperty</strong> we get what we have above, plus some additional features such as <strong>eumerable</strong> and <strong>configurable</strong>. You can also make a property read only.</p>
<p>Here is how to expose a readonly property called <strong>length</strong>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SimpleQueue</span><span class="hljs-params">()</span> </span>{
    dataStore = [];

    Object.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"length"</span>, {
        <span class="hljs-keyword">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> dataStore.length;
            },
            enumerable: <span class="hljs-literal">true</span>,
            configurable: <span class="hljs-literal">true</span>
    });

        SimpleQueue.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        etc...
</code></pre><p>After adding the <strong>length</strong> property, you can now access it in your tests like this:</p>
<p>var len = simpleQueue.length;<br>
for (var i = 0; i &lt; len; i++) { simpleQueue.dequeue(); }</p>
<p>In the code shown above, we use a relatively new feature of JavaScript called a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">property</a>. There are several ways to use properties. In this case we define a read-only property implemented primarily in the <strong>get</strong> function. If you want to jump ahead and see what else can be done, you can visit the <a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Properties">Properties</a> folder in JsObjects.</p>
<p>By the way, the code shown above works exactly the same way if you are using the Modular pattern:</p>
<pre><code><span class="hljs-keyword">var</span> SimpleQueue = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">var</span> dataStore = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SimpleQueue</span><span class="hljs-params">()</span> </span>{
        dataStore = [];

        Object.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"length"</span>, {
            <span class="hljs-keyword">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> dataStore.length;
            },
            enumerable: <span class="hljs-literal">true</span>,
            configurable: <span class="hljs-literal">true</span>
        });
    }

    SimpleQueue.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    etc...
</code></pre><p>My tests look exactly the same whether I use a standard constructor function or the modular pattern. Though we normally try to avoid <strong>this</strong>, creating properties in a constructor is one place where it is relatively safe to use <strong>this</strong>.)</p>
<p>In a queue, there are other places, such as <strong>back</strong> and <strong>front</strong>, where you could use properties. Doing so is optional, but if you want to learn a little more now, rather than later, then go ahead....</p>
<p>Newcomers to JavaScript: Don&#39;t worry too much about the Modular pattern unless you are comfortable with it. The main thing for you here is that there are several tips as to how to put together your <strong>queue</strong> class.</p>
<h1 id="methods">Methods</h1>
<p>A more indepth discussion of methods will be added here in the future.</p>
<h2 id="use-strict-and-methods">Use Strict and Methods</h2>
<p>In the following example, we add the words &#39;use strict&#39;; to a function:</p>
<pre><code><span class="hljs-keyword">var</span> myObject = {    
    myProperty01: <span class="hljs-number">12</span>,
    myProperty02: <span class="hljs-number">4</span>,
    myFunction: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 + <span class="hljs-keyword">this</span>.myProperty02;
    }                   
};
</code></pre><p>This object has two properties and one function. The function adds the two properties together and returns the result.</p>
<p>By adding &#39;use strict&#39; we force the JavaScript language to reject some coding conventions that worked in the past. The general idea is to remove features from the language that have not proved to be useful. If you define strict, then any attempt to use those features will raise an error. In the future, it is likely that strict will be turned on by default. Strict goes a long way toward mitigating some of the most egregious problems inherent in the poorly designed JavaScript architecture.</p>
<p>In particular, it used to be legal to declare a variable without using the keyword <strong>var</strong>:</p>
<pre><code>myVariable = <span class="hljs-number">3</span>; <span class="hljs-comment">// Bad</span>
  <span class="hljs-variable"><span class="hljs-keyword">var</span> myVariable</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// Good</span>
</code></pre><p>Omitting <strong>var</strong> will throw an error when <strong>strict</strong> is turned on. This and other features of <strong>strict</strong> are designed to keep you from accessing the global object unnecessarily.</p>
<p>Strict mode also throws exceptions in cases that would otherwise fail silently. For instance, if you try to change a property that has its writable attribute set to false.</p>
<p>Strict will also usually keep you from using <strong>eval</strong> or even including the word in your code.</p>
<p>Another old JavaScript feature that goes away in strict mode is <strong>with</strong>.</p>
<p>Here are some other, less important, benefits of strict mode:</p>
<ul>
<li>It introduces some optimizations</li>
<li>It prevents you from employing syntax that is likely to conflict with a future version of the language that has not been implemented yet.</li>
</ul>
<h1 id="public-and-private-variables">Public and Private Variables</h1>
<p>Here are a few comments on public and private variables in objects:</p>
<pre><code><span class="hljs-keyword">var</span> Point = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x1, y1</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-comment">// Private variables</span>
    <span class="hljs-keyword">var</span> x = x1;
    <span class="hljs-keyword">var</span> y = y1;

    <span class="hljs-comment">// private method</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Snake"</span>; };

    <span class="hljs-comment">// public methods</span>
    <span class="hljs-keyword">this</span>.hiss = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Hiss "</span> + bar(); };
    <span class="hljs-keyword">this</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> x + y;
    };

};

<span class="hljs-comment">// Public method</span>

<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>);
    <span class="hljs-keyword">var</span> el2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content2'</span>);
    <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);    
    el.innerHTML = point.add();    
    el2.innerHTML = point.hiss();
};
</code></pre><p>In this code x and y are private variables. Here is how the code would look if we wanted to work with public variables:</p>
<pre><code><span class="hljs-keyword">var</span> Point = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x1, y1</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-comment">// Public variables</span>
    <span class="hljs-keyword">this</span>.x = x1;
    <span class="hljs-keyword">this</span>.y = y1;

    <span class="hljs-comment">// private method</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Snake"</span>; };

    <span class="hljs-comment">// public methods</span>
    <span class="hljs-keyword">this</span>.hiss = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Hiss "</span> + bar(); };
    <span class="hljs-keyword">this</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y;
    };

};

<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>);
    <span class="hljs-keyword">var</span> el2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content2'</span>);
    <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
    alert(point.x);
    el.innerHTML = point.add();    
    el2.innerHTML = point.hiss();
};
</code></pre><p>Notice that in this new version, we had to change the add function to use this.x and this.y rather than the bare x and y. We can further modify the code to declare the <strong>add</strong> method using prototype:</p>
<pre><code><span class="hljs-keyword">var</span> Point = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x1, y1</span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-comment">// Public variables</span>
    <span class="hljs-keyword">this</span>.x = x1;
    <span class="hljs-keyword">this</span>.y = y1;

    <span class="hljs-comment">// private method</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Snake"</span>; };

    <span class="hljs-comment">// public methods</span>
    <span class="hljs-keyword">this</span>.hiss = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Hiss "</span> + bar(); }

};

<span class="hljs-comment">// Public method</span>
Point.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y;
};

<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>);
    <span class="hljs-keyword">var</span> el2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content2'</span>);
    <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);    
    el.innerHTML = point.add();    
    el2.innerHTML = point.hiss();
};
</code></pre><p>This would not have worked had the variables x and y been private. In that case, the add method would not have been able to access the private variables x and y. It can, however, access the public properties this.x and this.y.</p>
<h1 id="share-data-between-objects">Share Data Between Objects</h1>
<p>Suppose you have two variables called playerX and playerY that you want two objects to share. One way to handle the situation is to declare a single object with two properties called <strong>playerX</strong> and <strong>playerY</strong>. You can then share the object between the two objects. Changes made to the shared object will be seen by both objects that share the data.</p>
<p>Consider this object:</p>
<pre><code>ELF.own.Player = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-keyword">var</span> that = {};
    that.playerX = <span class="hljs-number">1</span>;
    that.playerY = <span class="hljs-number">2</span>;

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Player</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">new</span> ELF.own.ShowPlayer(that);
        $(<span class="hljs-string">'#buttonChangePlayer'</span>).click(changePlayer);
    }

    <span class="hljs-keyword">var</span> changePlayer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        that.playerX += <span class="hljs-number">1</span>;
        that.playerY += <span class="hljs-number">2</span>;
    };

    <span class="hljs-keyword">return</span> Player;
})();
</code></pre><p>And here is the object that wants to consume playerX and playerY:</p>
<pre><code><span class="hljs-keyword">var</span> ELF = {};
ELF.own = {};

ELF.own.ShowPlayer = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-string">'use strict'</span>;

    <span class="hljs-keyword">var</span> sharedData = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ShowPlayer</span>(<span class="hljs-params">initData</span>) </span>{
        sharedData = initData;
        $(<span class="hljs-string">'#buttonShowPlayer'</span>).click(showPlayerXY);
    }

    <span class="hljs-keyword">var</span> showPlayerXY = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        $(<span class="hljs-string">'#test01'</span>).html(<span class="hljs-string">'X = '</span> + sharedData.playerX + <span class="hljs-string">' Y = '</span> + sharedData.playerY);
    };

    <span class="hljs-keyword">return</span> ShowPlayer;
})();
</code></pre><p>In the first object I declare the data to be shared:</p>
<pre><code><span class="hljs-keyword">var</span> <span class="hljs-literal">that</span> = {};
    <span class="hljs-literal">that</span>.playerX = <span class="hljs-number">1</span>;
    <span class="hljs-literal">that</span>.playerY = <span class="hljs-number">2</span>;
</code></pre><p>Then I share the data with the second object when the second object is created:</p>
<pre><code><span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ELF</span><span class="hljs-selector-class">.own</span><span class="hljs-selector-class">.ShowPlayer</span>(<span class="hljs-selector-tag">that</span>);
</code></pre><p>You can make the variable passed to the second object global within that second object:</p>
<pre><code><span class="hljs-keyword">var</span> sharedData = <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ShowPlayer</span><span class="hljs-params">(initData)</span> </span>{
        sharedData = initData;
    }
</code></pre><p>Now any changes made to that.playerX by either object will be seen by both objects. In other words, it is passed by reference, not by value. The method that changes the data is called <strong>changePlayer</strong>, and the method that detects the change is called <strong>showPlayerXY</strong>.</p>
<p>To see this in practice, look at:</p>
<pre><code><span class="hljs-regexp">/JsObjects/</span>JavaScripts<span class="hljs-regexp">/Objects/</span>ShareVariables01
</code></pre><h2 id="object-maps">Object Maps</h2>
<p>After all our talk about if..else and <strong>switch</strong> statements it is worth noting that JavaScript provides a third mechanism that is arguable a much better solution to this kind of problem. Consider the following example:</p>
<pre><code>var funcBranch = function(<span class="hljs-keyword">state</span>Abbreviation) {

    var <span class="hljs-keyword">state</span>Map = {
        'AL': <span class="hljs-number">4800736</span>,
        'CA': <span class="hljs-number">38053956</span>,
        'TX': <span class="hljs-number">25901361</span>,
        'WA': <span class="hljs-number">6830038</span>
    }

    console.<span class="hljs-keyword">log</span>('The population of ' + <span class="hljs-keyword">state</span>Abbreviation + ' = ' + <span class="hljs-keyword">state</span>Map[<span class="hljs-keyword">state</span>Abbreviation]);
};
</code></pre><p>In this code we create a small object called stateMap. We can then pull out the value we want by simply writing the following simple expression:</p>
<pre><code><span class="hljs-keyword">state</span>Map[<span class="hljs-keyword">state</span>Abbreviation]
</code></pre><p>If, for instance, stateAbbreviation were equal to &#39;WA&#39;, then this expression would return 6830038. This code is concise, easy to read, and it performs well.</p>
<p>Note that you could perform more complex operations by setting up an object that contains functions:</p>
<pre><code><span class="hljs-keyword">var</span> stateMap = {
    <span class="hljs-string">'AL'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">4800736</span> /<span class="hljs-number">100</span>;
    },
    <span class="hljs-string">'CA'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">38053956</span> / <span class="hljs-number">100</span>;
    },
    etc...
}
</code></pre><p>This makes the solution <em>functionally</em> equivalent to a switch statement, since each option can consist of a series of statements. For instance you could write something like this:</p>
<pre><code><span class="hljs-keyword">var</span> funcBranch2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stateAbbreviation</span>) </span>{
        <span class="hljs-keyword">var</span> stateMap2 = {
            <span class="hljs-string">'AL'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-number">4800736</span> /<span class="hljs-number">100</span>;
            }(),
            <span class="hljs-string">'CA'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-number">38053956</span> / <span class="hljs-number">100</span>;
            }(),
            <span class="hljs-string">'TX'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-number">25901361</span> / <span class="hljs-number">100</span>;
            }(),

            <span class="hljs-string">'WA'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-number">6830038</span> / <span class="hljs-number">100</span>;
            }()
        }

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The population of '</span> + stateAbbreviation + <span class="hljs-string">' = '</span> + stateMap2[stateAbbreviation]);        
    };
</code></pre><p>If that is just too esoteric for your tastes, then you can write:</p>
<pre><code><span class="hljs-keyword">var</span> funcBranch2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stateAbbreviation</span>) </span>{
    <span class="hljs-keyword">var</span> stateMap2 = {
        <span class="hljs-string">'AL'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">4800736</span> /<span class="hljs-number">100</span>;
        },
        <span class="hljs-string">'CA'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">38053956</span> / <span class="hljs-number">100</span>;
        },
        <span class="hljs-string">'TX'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">25901361</span> / <span class="hljs-number">100</span>;
        },

        <span class="hljs-string">'WA'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">6830038</span> / <span class="hljs-number">100</span>;
        }
    }

    <span class="hljs-keyword">var</span> bar = stateMap2[stateAbbreviation];
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The population of '</span> + stateAbbreviation + <span class="hljs-string">' = '</span> + bar());
};
</code></pre><p>It&#39;s really just a question of when you want the function to execute. The first case saves you a bit of code, but it is arguable going to a bit hard for some people to read.</p>
<p>The example program is on GitHub, in JsObjects:</p>
<p><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Syntax/Branching01">JsObjects/JavaScript/Syntax/Branching01</a></p>
<h2 id="sorting">Sorting</h2>
<p>Here is code for sorting an array called <strong>presidents</strong> by first name:</p>
<pre><code><span class="hljs-keyword">var</span> sort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    presidents.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
        <span class="hljs-keyword">if</span> (a.firstName &gt; b.firstName) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.firstName &lt; b.firstName) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    });
};
</code></pre><h1 id="properties-and-constants">Properties and Constants</h1>
<p>See this example:</p>
<ul>
<li><a href="Constants.html">Constants</a></li>
</ul>
<h1 id="dictionaries">Dictionaries</h1>
<p>JavaScript Dictionaries are Associative Arrays. JavaScript objects are a comma separated list of key value pairs:</p>
<pre><code>var myObject = {
<span class="hljs-attr">    a:</span> <span class="hljs-number">1</span>,
<span class="hljs-attr">    b:</span> <span class="hljs-number">2</span>,
<span class="hljs-attr">    c:</span> <span class="hljs-string">'three'</span>
};
</code></pre><p>The begin with an open curly brace and end with a close curly brace and a semicolon.</p>
<p>In myObject, <strong>a</strong>, <strong>b</strong> and <strong>c</strong> are all <strong>keys</strong> and <strong>1</strong>, <strong>2</strong> and <strong>&#39;three&#39;</strong> are <strong>values</strong>.</p>
<p>If a <strong>value</strong> is a function then we call it a method:</p>
<pre><code><span class="hljs-keyword">var</span> objectWithMethod = {
    a: <span class="hljs-number">1</span>,
    b: <span class="hljs-number">2</span>,
    getThree: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }
};
</code></pre><h1 id="classes">Classes</h1>
<p>There is no such thing as a JavaScript class. Instead, JavaScript has objects. You can&#39;t declare the class for a JavaScript object.</p>
<p>To the degree that we can talk coherently about classes in JavaScript, we can do so by focusing on their prototype. All the members of a class share the same prototype. If two objects have the same prototype, then they are members of the same class.</p>
<p>Two constructors with quite different contents are nonetheless members of the same class if they have the same prototype. (Example needed. Did I lose it, I thought I had one?)</p>
<p>By convention, objects and functions that need to be called with the <strong>new</strong> operator begin with a capital letter, while methods and functions begin with lower case letters.</p>
<h1 id="links">Links</h1>
<p>A surprising amount of my work is making sure that I am teaching you things that matter, that are used widely and are likely to be used widely in the future. Once you start digging into this world, you will find that things like git, express, node, WebStorm, the bash shell, Jade (or at least various forms of HTML templates), are all used a lot. They are mainstream technologies in the web world.</p>
<p>One of the best ways to stay current is to follow the leaders in this world. They include:</p>
<ul>
<li><a href="http://addyosmani.com/blog/">Addy Osmani</a></li>
<li><a href="http://ejohn.org/">John Resig</a></li>
<li>Almost anyone who <a href="http://superherojs.com/">SuperHeroes</a> links to.</li>
<li>Yahuda Katz</li>
<li><a href="http://javascript.crockford.com/">Crockford</a></li>
<li><a href="http://www.nczonline.net/">Nicholas Zachas</a></li>
</ul>
<p>And many more. Of course, they will not always agree with me. That would not be possible, especially in a world that is changing so fast. But if you read what those folks say and think, then you can&#39;t go too far wrong. It is still an artform to choose what is best when top folks like that disagree, but even if they pick wrong in terms of where we are headed, they still pick smart.</p>
<p>And of course Anders Helsberg&#39;s TypeScript is important, as is everything that Anders has done, from Pascal, to Delphi to C#.</p>
<ul>
<li><a href="http://bjorn.tipling.com/advanced-objects-in-javascript">JavaScript Objects Overview</a></li>
</ul>
</div></body></html>