<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>JavaScriptFunctions</title><link href="/css/first-style.css" rel="stylesheet"><link rel="shortcut icon" href="/images/favicon.png"><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-1.12.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Latest compiled and minified CSS --><script src="/js/elven-help.js"></script></head><body><nav class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Elvenware</a></div><div class="navbar-collapse collapse" id="navbar"><ul class="nav navbar-nav"><li class="trigger-collapse" ng-class="{ active: isActive('/')}"><a href="/">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div></nav><div class="container"><figure><img class="elf-normal" alt="Elvenware" src="/images/elvenwarelogo.png"/></figure><h1>JavaScriptFunctions</h1><p>Welcome to JavaScriptFunctions</p><ul><!--TOC_Start--><li><a href="#javaScriptFunctions">JavaScript Functions</a></li>
<li><a href="#functional">Functional</a></li>
<li><a href="#what-are-functions">What are Functions</a></li>
<li><a href="#function-types">Types of Functions</a></li>
<li><a href="#simple-functions">Simple Functions</a></li>
<li><a href="#two-ways-to-declare-functions">Two Ways to Declare Functions</a></li>
<li><a href="#arguments-and-parameters">Arguments and Parameters</a></li>
<li><a href="#function-this">The <em>this</em> Keyword</a></li>
<li><a href="#functions-and-variables">Functions and Variables</a></li>
<li><a href="#functions-and-objects">Functions and Objects</a></li>
<li><a href="#strict-mode">Strict Mode</a></li>
<li><a href="#callbacks">Callbacks: Passing Functions as Parameters</a></li>
<li><a href="#callFunction">Calling a JavaScript Function from a Declaration</a></li>
<li><a href="#compareObjFunc">Comparing JavaScript objects and JavaScript functions</a></li>
<li><a href="#properties-and-inheritance">Properties and Inheritance</a></li>
<li><a href="#this-and-that">This and That</a></li><!--TOC_End--></ul></div><div class="container"><a class="anchor" id="javaScriptFunctions"></a>
<h1>JavaScript Functions</h1>
<p>Functions play a central role in the JavaScript language. They are easy to use, but hard to fully understand.</p>
<p>When in doubt, go back to the <a href="index.html">index</a>.</p>
<a class="anchor" id="functional"></a>
<h2>Functional</h2>
<p>JavaScript is sometimes described as having features found in a functional language. It is not a pure functional language, but it shares some features of functional languages.</p>
<p>Though &quot;functional programming&quot; is a technical term with certain specific
meanings, for now, we can simply say that JavaScript is a functional
language in the sense that functions are the basic building blocks of well
written JavaScript code. Functions are first class citizens of JavaScript because they can be:</p>
<ul>
<li>assigned to variables</li>
<li>passed to as parameters to function</li>
<li>returned from functions</li>
<li>stored in a data structure.</li>
</ul>
<p>JavaScript functions can have properties and methods. They rely heavily on callbacks and closures, both of which are are made possible by JavaScript&#39;s remarkable implementation of functions.</p>
<p>There is no single way to invoke a function. In fact, they can be invoked in four different ways:</p>
<ul>
<li>As functions</li>
<li>As methods</li>
<li>As constructors</li>
<li>With the methods <strong>apply</strong> and <strong>call</strong></li>
</ul>
<p>Each of these invocation methods has distinct features, particularly in regard to the <strong>this</strong> operator.</p>
<p>Functions play a role in JavaScript similar to that
played by objects in a language like C# or Java. They are the building blocks of the language.</p>
<p><strong>NOTE</strong>: <em>If your mind is full with the wonders of a langauge like C#,
there is good reason for your opinion. But consider this: the move to
add LINQ to C# was in part an attempt to give C# some of the features
that have long been built into JavaScript. Many of these &quot;LINQ like&quot;
features of JavaScript derive from the central and powerful role played
by JavaScript functions. In other words, it is not always that one
language is innately superior to another language, but rather that each
has its own virtues.</em></p>
<a class="anchor" id="what-are-functions"></a>
<h2>What are Functions</h2>
<p>Functions are unique in that they can be invoked, they can be executed.</p>
<p>Somewhat unexpectedly, functions are like any other value in JavaScript. In particular, functions are <strong>objects</strong>. In particular, functions are instances of the built-in JavaScript <strong>Function</strong> object.</p>
<p>Because functions are objects, you can do many of the same things with them that you can do with a <strong>string,</strong> <strong>number</strong>or <strong>object</strong>. For instance, you can:</p>
<ul>
<li>Store them in a variable</li>
<li>Put them in an <strong>array</strong></li>
<li>Pass them to a <strong>function</strong>, or return them from a function.</li>
</ul>
<p>Because functions are objects, you can do the same things with them that
you can do with any other object. For instance, you can give them properties
and methods. Note that functions also have:</p>
<ul>
<li>a <strong>constructor</strong>, which is a particularly powerful tool.</li>
<li>a <strong>prototype</strong> property.</li>
</ul>
<p>We will discuss <strong>prototypes</strong> in more depth later on in this document. The key
point to grasp at this point is simply that all functions automatically get
a constructor, which points at themselves, and an empty <strong>prototype</strong>.</p>
<a class="anchor" id="function-types"></a>
<h2>Types of Functions</h2>
<p>There are several styles of functions. The simplest:</p>
<pre>function fulano() {}  // Simple function

var fulano = function() {}; // Anonymous function assigned to a variable

function Fulano() {} // Function constructor. Capital letter means call it with new.

var myObject = {
   prop: 1,             // Property inside an object
   fulano: function() { } // Function as a method of an object
};

function Fulano() {
  var bar  = function() {}; // function inside a function constructor
  Fulano.prototype.foo = function() {};  // Function on a prototype
}
</pre>
<p>As <a href="#function-this">explained later</a>, these various ways of invoking a function alter the value of the <strong>this</strong> keyword inside the function.</p>
<a class="anchor" id="simple-functions"></a>
<h2>Simple Functions</h2>
<p>Here is one way to write a JavaScript function:</p>
<pre>function Test01() {
    var name = "Test01";
    $("#Test01").html(name);
}
</pre>
<p>This declaration has the following parts:</p>
<ul>
<li>The keyword <strong>function</strong></li>
<li>A name, which in this case is <strong>Test01</strong></li>
<li>A parameter list, which in this case is empty. The parameter list
appears between an open and close paranthesis: ()</li>
<li>An implementation, which appears between curly braces: {}. In this
case we declare a variable, and then use jQuery to show its value in
a web page.</li>
</ul>
<a class="anchor" id="two-ways-to-declare-functions"></a>
<h2>Two Ways to Declare Functions</h2>
<p>Here is a second way to declare a function. This time we will store an
anonymous function in a variable called <strong>test01</strong>:</p>
<pre>var test01 = function() {
   var name = "Test01";
   $("#Test01").html(name);
};
</pre>
<p>There is little practical difference between assigning a function to a
variable as shown here, or the creating functions as shown above. When
assigned to a variable, as shown above, the <strong>name</strong> field of the function
object is not filled out. When you declare a function as shown earlier, then
the name filed is filled out.</p>
<p>Consider the following program:</p>
<pre>var variable00;
var func01 = function() {};
function func02() {}

console.log("variable00: " + variable00);
console.log("func01.name: " + func01.name);
console.log("type of func01.name: " + typeof func01.name);
console.log("func02.name: " + func02.name);
</pre>
<p>Here is the output:</p>
<pre>variable00: undefined
func01.name:
type of func01.name: string
func02.name: func02
</pre>
<p>Notice that <strong>func01</strong> is assigned to a variable, and <strong>func02</strong> is a
standard function. Hence we see that <strong>func01</strong> has no <strong>name</strong> while
<strong>func02</strong> has a name.</p>
<p>You can find the source for this example on GitHub:</p>
<p><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Syntax/Functions01">JsObjects/JavaScript/Syntax/Function01</a></p>
<a class="anchor" id="arguments-and-parameters"></a>
<h2>Arguments and Parameters</h2>
<p>A function can be passed parameters and can return a value:</p>
<pre>function multiply(a, b) {
    return a * b;
}
</pre>
<p>This function differs from the first sample in that it takes two
parameters, called a and b. Here is a somewhat more verbose version of
the same function. This second verison has more descriptive parameters
called <strong>operandA</strong> and <strong>operandB</strong>:</p>
<pre>function multiply(operandA, operandB) {
    return operandA * operandB;
}
</pre>
<p>Notice that we don&#39;t declare the types of the parameters, nor the type
of the return value. There is no type checking on these parameters. If
we omit a parameter when invoking the function then that parameter will
have the value <strong>undefined</strong>. If we pass in too many parameters when
calling a function, then the extra parameters will simply be ignored.</p>
<p>Each function is implicitly passed an object called <strong>arguments</strong>. Suppose
you declare a method that looks like this:</p>
<pre>function add() {
}
</pre>
<p>Suppose further that you call it like this:</p>
<pre>add(12, 15);
</pre>
<p>Even though you did not specify any parameters for the function, you can
nevertheless access the arguments that are passed in to it:</p>
<pre>function add() {
    if (arguments.length === 2) {
        return arguments[0] + arguments[1];
    } else if (arguments.length === 1) {
        return arguments[0] * 2;
    } else {
        throw('You must pass in either one or two parameters.');
    }
}
</pre>
<p>Here is a complete example:</p>
<pre>function UserException(message) {
   this.message = message;
   this.name = "UserException";
}

function add() {
    if (arguments.length === 2) {
        return arguments[0] + arguments[1];
    } else if (arguments.length === 1) {
        return arguments[0] * 2;
    } else {
        throw new UserException('You must pass in either one or two parameters.');
    }
}


console.log(add(2));
console.log(add(2, 3));
console.log(add());
</pre>
<p>The source is here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Syntax/FunctionArguments">JsObjects</a></li>
</ul>
<a class="anchor" id="function-this"></a>
<h2>The <em>this</em> Keyword</h2>
<p>The <strong>this</strong> keyword in JavaScript is often called the function context. If you
are used to C# or other object oriented langauges, you may have certain
preconceived ideas about the <strong>this</strong> operator which will prevent you from
understanding the role <strong>this</strong> plays in JavaScript.</p>
<p>The key point to grasp is that the function context changes depending on how you invoke a function.
The change occurs not because of the way you declare a function, but because of the way you invoke it. In particular, there are four
ways to invoke a JavaScript function:</p>
<ul>
<li>As a standalone function</li>
<li>As method of an object</li>
<li>As a constructor</li>
<li>Via <strong>call</strong> or <strong>apply()</strong></li>
</ul>
<p>If you are working in a web browser, and you invoke a simple standalone function, then the <strong>this</strong>
object will usually be the global <strong>window</strong> object that is part of the browser:</p>
<pre>function runMe() { return this; }
var functionContext = runMe();
</pre>
<p>In the code shown above, functionContext will be the <strong>window</strong> object.</p>
<p>Consider this code:</p>
<pre>    var myObject = {
        runMe: function() {
            return this;
        }
    }

    var functionContext = myObject.runMe();
</pre>
<p>In the code shown above, functionContext will be <strong>myObject</strong>.</p>
<p>And finally, let&#39;s look at this example:</p>
<pre>    function RunMe() {
        console.log(this);
    }

    var functionContext = new RunMe();
</pre>
<p>In this last example, we are creating a constructor by invoking the <strong>new</strong>
operator. In this case, functionContext is <strong>RunMe</strong>.</p>
<p>Here are all three cases pulled together in a single program from JsObjects
calld ObjectThis:</p>
<pre>    function runMe() { return this; }

    var myObject = {
        runMe: function () {
            return this;
        }
    }

    function RunMe() {
        $('#test03').append(this instanceof RunMe);
    }

    $(document).ready(function() {
        "use strict";
        var functionContext = runMe();
        $('#test01').append(functionContext === window);

        var functionContext2 = myObject.runMe();
        $('#test02').append(functionContext2 === myObject);

        var functionContext3 = new RunMe();
        $('#test04').append(functionContext3 instanceof RunMe);   
    });
</pre>
<p>In <strong>strict</strong> mode, <strong>this</strong> is set to undefined rather than the global object when invoking a standalone method without calling <strong>new</strong>:</p>
<pre>function hello01() {
    console.log(this);
}

hello01(); // global object

function hello02() {
    "use strict";
    console.log(this);
}

hello02(); // undefined
</pre>
<a class="anchor" id="functions-and-variables"></a>
<h2>Functions and Variables</h2>
<p>There is no difference from the callers point of view between these two declarations:</p>
<pre>function saveScore() { }
var saveScore = function() {};
</pre>
<p>One is a function named <strong>saveScore</strong> and the other is a variable called
<strong>saveScore</strong> that references an anonymous function. You can
call them both like this:</p>
<pre>saveScore();
</pre>
<p>The differences is that the first one has a property called <strong>name</strong> that is
set to the value <strong>saveScore</strong>, while the second has a property called
<strong>name</strong> that is set to an empty string.</p>
<p><strong>NOTE</strong>: To see the difference in the name property of the two versions of
saveScore, take a look at the Functions01 example from
<strong>JsObjects/JavaScript/Syntax</strong>. Note also that declaration with an
anonymous function ends with a semicolon and the other does not.</p>
<p>If you are setting up a callback, then you just pass in a variable which is
the name of a function:</p>
<pre>$("#Button01").click(myButtonClickHandler);
</pre>
<p>In this case, we don&#39;t call the function, that is we don&#39;t write this:</p>
<pre>$("#Button01").click(myButtonClickHandler());
</pre>
<p>We just pass in its name, as shown in the first of the two examples shown
above.</p>
<p>All this is a bit confusing to new comers because they are not used to
languages where functions are first class members of the language. A
JavaScript function has all the power of any other object or variable.
That&#39;s why the following are the same:</p>
<pre>function saveScore() { }
var saveScore = function() {};
</pre>
<p>It just doesn&#39;t matter whether you are calling a function or a variable that
points at a function. Both are objects, and both are treated the same.</p>
<a class="anchor" id="functions-and-objects"></a>
<h2>Functions and Objects</h2>
<p>Each function that you declare in JavaScript is an object. When you look
at the following code, you might therefore be forgiven for supposing
that <strong>name</strong> is a field of Test01, and that a call to print that name
would work. In fact, <strong>name</strong> is a private field of the object, and
therefore cannot be seen by an instance of Test01. The <strong>description</strong>
property, shown below, is a public member of Test01, and it will be
accessible from an instance of the object.</p>
<pre>var Test01 = function()
{
   var name = "Test01";
}

Test01.prototype.description="This is a test object";

var Test02 = function()
{
    var test01 = new Test01();
    $("#Description01").html(test01.description);
    $("#Name01").html(test01.name);
}
</pre>
<p>When Test02 is called, the code shown above prints out the string &quot;This
is a test object&quot; but it does not print out the words &quot;Test01.&quot; That is
because the property <strong>description</strong> is visible to an instance of
<strong>Test01</strong>, but the field <strong>name</strong> is unknown.</p>
<p>To make name a public field of the object, write code that qualifies the
instance of <strong>nameStr</strong>with the keyword <strong>this</strong>:</p>
<pre>var Test01 = function()
{
    this.nameStr = "Test01";
}

Test01.prototype.description="This is a test object";

var Test02 = function()
{
    var test01 = new Test01();
    $("#Description01").html(test01.description);
    $("#Name01").html(test01.nameStr);
}
</pre>
<p>Now the code shown above behaves as expected, and inserts both
<strong>nameStr</strong> and <strong>description</strong> into the appropriate tags in our HTML.</p>
<p>Like Extensions methods in C#, you can use Prototype to change the way
existing classes work. In the following example, we will add a method
called Decorate to the built-in JavaScript String class:</p>
<pre>String.prototype.decorate = function() {
 return "-***-" + this + "-***-";
}
</pre>
<p>Now when you create a string, you can call its decorate method:</p>
<pre>this.testDecoration = function() {
    var testStr = "All my strings can be decorated";
    $("#testPlain").html(testStr);
    $("#testDecorate").html(testStr.decorate());
}
</pre>
<p><a href="BasicSyntax.html#decorate">Click here to try decorating a string</a>.</p>
<a class="anchor" id="strict-mode"></a>
<h2>Strict Mode</h2>
<p>General changes:</p>
<ul>
<li>Changes some silent errors to visible errors</li>
<li>Helps the compiler optimize code</li>
<li>Helps you write more secure code</li>
<li>Prepares the way for future versions of JavaScript. Helps you write code that will be compatible with ES6</li>
</ul>
<p>A few of the Details:</p>
<ul>
<li>All variables must be declared (use var)<ul>
<li>var a = 2; // correct</li>
<li>a = 2; // wrong</li>
</ul>
</li>
<li>The <strong>with</strong> statement is not allowed</li>
<li>Octal syntax is forbidden</li>
<li>Functions outside objects have this set to undefined</li>
<li>ReadOnly properties are honored</li>
<li>Objects can be sealed</li>
<li>Eval works in its own scope, not local or global scope</li>
<li>Language is safer with strict.</li>
</ul>
<a class="anchor" id="callbacks"></a>
<h2>Callbacks: Passing Functions as Parameters</h2>
<p>Callbacks are very common in JavaScript. In other languages, they are often considered esoteric, but in JavaScript they happen all the time.</p>
<p><strong>NOTE</strong>: <em>Callbacks are the key to understanding asynchronous processing in JavaScript. If we are in a browser and make a call to the server, then we don&#39;t know when, or even if, the call will return. As a result, we don&#39;t make the call synchronously. That is, we don&#39;t wait around for the call to return. Instead, we make the call, and then continue on processing code. When the call returns, we are notified. This is known as an asynchronous call, and in JavaScript we handle these calls with callbacks. Since we make lots of calls to the server in a typical JavaScript program, our ability to understand callbacks becomes key to our ability to understand even basic Web programming.</em></p>
<p>JavaScript considers functions to be first class citizens of the language. This means that you can easily assign them to variables, and pass them around to other functions. Other languages usually provide support for function pointers of function objects, but the syntax is often awkward or challenging to use. In JavaScript, you can simply treat a function like any other type, such as a <strong>Number</strong>, <strong>String</strong> or <strong>Boolean</strong>.</p>
<p><strong>NOTE</strong>: <em>Because functions in JavaScript are so flexible, many consider JavaScript to be a <a href="http://en.wikipedia.org/wiki/Functional_programming">functional</a> programming language. Functional programming is enormously powerful, and also quite different from the type of <a href="http://en.wikipedia.org/wiki/Imperative_programming">imperative</a> programming done in Java and C#. Ultimately, the flexibility of JavaScript functions will enable you to write your code in a <strong>functional</strong> style that is quite different from what you write when using more traditional languages. This is not the place to explore this topic in depth, but you should at least be aware of the power of functions in JavaScript, and the way that they shape our approach to the language. Functional programming is a type of <a href="http://en.wikipedia.org/wiki/Declarative_programming">declarative programming</a>.</em></p>
<p>Here is an example of how to use callbacks in JavaScript:</p>
<pre>/**
 * @author Charlie
 */

function hello(func) {
    $("#test02").html("It works! ");
    func();
}

$(document).ready(function() {
  "use strict";


  $("#test01").html("Document Read called");

  hello(function() {
      $("#test03").html("It's a nine!");
  });

});
</pre>
<p>The complete example is here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Objects/ObjectFunctionBasics02">JsObjects Objects ObjectFunctionBasics02</a></li>
</ul>
<p>In this example, we pass an anonymous function to the method <strong>hello</strong>. As you can see, <strong>hello</strong> takes a single parameter called func:</p>
<pre>function hello(func) {
</pre>
<p>When we call <strong>hello</strong> we pass in an anonymous function, a bit like this:</p>
<pre>    var helloParameter = function() {
          $("#test03").html("It's a nine!");
    }

    hello(helloParameter);
</pre>
<p>But in JavaScript we get a special dispensation, as it were, and don&#39;t even have to declare the variable that points at our function. Instead, we can just pass it in directly as an anonymous function:</p>
<pre>    hello(function() {
        $("#test03").html("It's a nine!");
    });
</pre>
<p>We call the function <strong>anonymous</strong> because it has no name:</p>
<pre>function() {
    $("#test03").html("It's a nine!");
}
</pre>
<p>Compare the above to a standard function with a name:</p>
<pre>    function writeNine() {
        $("#test03").html("It's a nine!");
    }
</pre>
<p>If callbacks and anonymous functions are unclear, think about them some more. If these subjects are still unclear, get up, take a 1 minute walk, then come back and think about it all again. Download the example and step through it. Come to terms with this syntax. You will never really understand JavaScript until you understand code of this type.</p>
<p><strong>Aside</strong>: <em>Do JavaScript programmers dream callbacks? Of course!</em></p>
<p>Here is another example designed to drive home the points outlined above:</p>
<pre>/**
 * @author Charlie
 */

var Converter = (function() {

    // Private variable
    var x = 0;

    // Constructor
    function Converter(initX) {
        x = initX;
    }

    // Private method
    function square(value) {
        return value * value;        
    }

    // Public methods
    Converter.prototype.convert = function(func) {
        var result = square(x);
        return func(result);      
    };

    return Converter;
})();

$(document).ready(function() {"use strict";

    var converter = new Converter(2);

    var feet = converter.convert(function(miles) {
        return miles * 5280;
    });

    var yards = converter.convert(function(miles) {
        return miles * (5280 / 3);
    });

    $("#feet").html(feet);
    $("#yards").html(yards);
});
</pre>
<p>The source is here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Objects/ObjectDemoCallback03">JsObjects ObjectDemoCallback</a></li>
</ul>
<a class="anchor" id="callFunction"></a>
<h2>Calling a JavaScript Function from a Declaration</h2>
<p>The following code demonstrates the differences between assigning a method to a variable and assigning the result of a function call to a variable. Notice the extra parentheses at the end of the getNine02. This
causes the function to be called at the time of the assignment. This means that getNine02 ends up a being a <strong>number</strong>, while getNine01 ends up being <strong>function object</strong>.</p>
<p>In the <strong>getNine02</strong> example, the open parenthesis before the word function is syntactical sugar. It does not have any other function other than to tell us that this function is going to be called immediately with the closing set of parentheses. If one is reading a long function, we want to be told up front that it is going to be called immediately. There is no good way to do that, so a convention has been developed of adding parentheses before the word function to serve as a hint that the function will be called immediately.</p>
<pre>    /**
     * @author Charlie
     */

    // getNine is assigned a function that returns the number 9
    var getNine01 = function() {
        return 9;
    }

    /*
     * getNine02 is set to the number 9. Notice the
     * the parentheses at the end of the statement.
     * They force the function to be called during the
     * assignment
     */
    var getNine02 = (function() {
        return 9;    
    })();

    $(document).ready(function() {
      "use strict";

      // We call getNine01() because it is a function
      var result01 = getNine01();
      $("#test01").html(result01);

      // Get Nine02 is not a function, but a simple number
      // Hence it is not called. Notice there are no parentheses
      var result02 = getNine02;
      $("#test02").html(result02);
    });
</pre>
<a class="anchor" id="compareObjFunc"></a>
<h2>Comparing JavaScript objects and JavaScript functions</h2>
<p>Previously in this document, in the section on objects, we declared a
simple object that looks like this:</p>
<pre>var myObject = {                
    myProperty01: 12,
    myProperty02: 4,
    myFunction01: function() {
        return this.myProperty01 + this.myProperty02;                
    }                
);
</pre>
<p>We call it like this:</p>
<pre>myObject.myFunction01()
</pre>
<p>This is very nice, but it does not give us the option to create private
methods.</p>
<p>Here is what the same object would look like if declared as a function:</p>
<pre>function myFunction02() {   
    'use strict';

    var myField01 = 3;
    var myField02 = 2;
    var nestedFunction = function() {
        return myField01 + myField02;  
    };

    return nestedFunction();
}
</pre>
<p>We call it like this:</p>
<pre>myFunction02()
</pre>
<p>Let&#39;s call this the Simple Function pattern. This is very nice, but it
does not gives us the option to create public methods. As you can see,
if I want to call <strong>nestedFunction</strong>, I need to call it from inside of
<strong>myFunction02</strong>. This is less than optimal in some cases.</p>
<p>Here is a third technique that uses the <strong>prototype</strong> function syntax,
and gives us public methods, but no useful private methods:</p>
<pre>var MyFunction03 = function() {
    'use strict';       
};

MyFunction03.prototype.field01 = 2;
MyFunction03.prototype.field02 = 4;
MyFunction03.prototype.nestedFunction = function() {
    'use strict';    
    return this.field01 + this.field02;    
};
</pre>
<p>We call it like this:</p>
<pre>var myFunction03 = new MyFunction03();
myFunction03.nestedFunction();
</pre>
<p>This is very nice, but it does not give us private methods. Note also,
that it forces us to call <strong>new</strong> when we create the object. If we don&#39;t
call new, then nestedFunction will not be visible when we try to use the
object. In other words, our public method won&#39;t be truly public.</p>
<p>And here finally, is a fourth way of writing the same object. We call
this the module pattern. It provides both public methods and private
methdos, private fields, and it gives us a constructor for initializing
the fields. It&#39;s syntax is more verbose, but it gives us everything we
need. Also, the syntax, though a bit verbose, is similar to the class
declarations in other curley brace languages such as C#.</p>
<pre>var MyFunction04 = (function() {
    'use strict';

    var field01 = 0,
    field02 = 0;

    function MyFunction04(initField01, initField02) {
        field01 = initField01;
        field02 = initField02;
    }

    MyFunction04.prototype.nestedFunction = function() {
        return field01 + field02;
    };    

    return MyFunction04;
}());
</pre>
<p>We call it like this:</p>
<pre>var myFunction04 = new MyFunction04(1, 2);
myFunction04.nestedFunction();
</pre>
<p>This is the best solution.</p>
<p>Now go back and look at the original object pattern. Compare it to the
one we have created. Notice that they are two different ways of saying
the same thing, only the module pattern is more flexible, and more
powerful.</p>
<p>Get the Source:</p>
<ul>
<li><a href="/charlie/downloads/JavaScriptObjectPatterns.zip">JavaScriptObjectPatterns.zip</a></li>
</ul>
<a class="anchor" id="properties-and-inheritance"></a>
<h2>Properties and Inheritance</h2>
<p>Inheritance is done most often through the <strong>prototype</strong> property. Declare a base object:</p>
<pre>var BaseObject = (function() {
    'use strict';

    function BaseObject() {
    }

    BaseObject.prototype.firstName = "Qux";

    return BaseObject;
}());
</pre>
<p>Now define the child object:</p>
<pre>var ChildObject = (function() {
    'use strict';

    function ChildObject() {
    }

    ChildObject.prototype = new BaseObject();

    ChildObject.prototype.lastName = "Garply";

    return ChildObject;
}());
</pre>
<p>The key line is this:</p>
<pre>ChildObject.prototype = new BaseObject();
</pre>
<p>This means that the child will inherit all the properties that are part of the parents prototype. BaseObject, in its turn, automatically inherits all the properties from the built in Object. That means that ChildObject inherits them also.</p>
<p>Now test the code:</p>
<pre>var childObject = new ChildObject();
console.log(childObject.firstName);
console.log(childObject.lastName);
</pre>
<p>As you can see, the child inherits the <strong>fistName</strong> property from the parent.
The working example is <a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Objects/Inheritance01/SimpleInheritance00.js">here</a>.</p>
<p>Notice that these objects use <strong>PascalCase</strong>, that is, the initial letter in their name is a Capital. Like this: <strong>ChildObject</strong>. Not <strong>camelCase</strong> like this: <strong>childObject</strong>.</p>
<p>When we use Pascal case for the first letter of an object, we are saying that must be called with new:</p>
<pre>var childObject = new ChildObject();
</pre>
<p>If we want to use the protype property, then we must instantiate the object with <strong>new</strong>. In other words, prototypal inheritance in JavaScript only works with constructor objects. That is, it only works with objects instantiated with <strong>new</strong>.</p>
<a class="anchor" id="this-and-that"></a>
<h2>This and That</h2>
<p>One of the real weak points in JavaScript is the <strong>this</strong> keyword. It is designed to allow an object to have access to its own properties and methods. That is common enough. The catch, however, is that this does not always point at what you think it should point at. In particular, in callbacks and the special case of callbacks called event handlers, the <strong>this</strong> keyword typically points at the object that made the call, or at the global <strong>window</strong> object. To get around this problem, and to allow an object to have access to itself when in a callback, we do this:</p>
<pre>var MyObject = function() {
  var that;
  var foo;

  function MyConstructor() {
     that = this;
  }

  function MyCallback() {
    that.foo = 'baz';
  }
}
</pre>
<p>This is hard to grasp at first mostly because it does not seem possible that JavaScript should have such a serious flaw in the language. If <strong>MyCallBack</strong> is part of <strong>MyObject</strong> then inside of <strong>MyCallback</strong> this ought to point to <strong>MyObject</strong>. But this is not necessarily the case, and as a result, we do the craziness with the that variable.</p>
<p>In general, the recommendation is not to use this outside of the constructor. Every place else, it is a danger to itself and others. We spend a lot of time learning how to write code that has no use for either this or that. But sometimes, we have no choice, and use that.</p>
<p>Here is another way to look at the same problem. Private methods and some callbacks cannot always properly access the <strong>this</strong> property that belongs to the object of which they are members. As a result, we must develop a work around. To solve the problem we typically declare <strong>this</strong> as <strong>that</strong>.</p>
<pre>function MyFunc() {

    var that = this;
    this.data = 3;

    function privateFunc() {
        console.log(that.data);
    }

    function myEvenHandler(event) {
        console.log(that.data);
    }
}
</pre>
<p>Please understand that this is just a convention. But it is a common convention. An experienced
JavaScript developer who sees <strong>that</strong> in your code expects it to be pointing to the <strong>this</strong>
property for the enclosing object.</p>
</div></body></html>