<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>JavaScriptFunctions</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap-theme.min.css"><!-- link(href='/libs/css/BootstrapIndex.css', rel='stylesheet', type='text/css')--><link href="/css/style.css" rel="stylesheet" type="text/css"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><script src="/components/jquery/dist/jquery.js"></script><script src="/components/angular/angular.js"></script><script src="/components/angular-route/angular-route.js"></script><script src="/components/bootstrap/dist/js/bootstrap.min.js"></script><!-- script(src='/libs/scripts/elvenware.js', type='text/javascript')--><!-- script(src="/libs/scripts/Control.js")--><!-- script(src='http://localhost:35729/livereload.js')--></head><body><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/about">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/development/index.html">Strongly Typed</a></li><li><a href="/development/web/index.html">Web & Scripts</a></li><li><a href="/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>JavaScriptFunctions</h1><p>Welcomes to JavaScriptFunctions</p><ul><!--TOC_Start--><li><a href="#javaScriptFunctions">Overview</a></li>
<li><a href="#what-are-functions">What are Functions</a></li>
<li><a href="#function-types">Types of Functions</a></li>
<li><a href="#simple-functions">Simple Functions</a></li>
<li><a href="#two-ways-to-declare-functions">Two Ways to Declare Functions</a></li>
<li><a href="#arguments-and-parameters">Arguments and Parameters</a></li>
<li><a href="#function-this">The <em>this</em> Keyword</a></li>
<li><a href="#functions-and-variables">Functions and Variables</a></li>
<li><a href="#functions-and-objects">Functions and Objects</a></li>
<li><a href="#strict-mode">Strict Mode</a></li>
<li><a href="#callbacks">Callbacks: Passing Functions as Parameters</a></li>
<li><a href="#callFunction">Calling a JavaScript Function from a Declaration</a></li>
<li><a href="#compareObjFunc">Comparing JavaScript objects and JavaScript functions</a></li>
<li><a href="#properties-and-inheritance">Properties and Inheritance</a></li>
<li><a href="#this-and-that">This and That</a></li><!--TOC_End--></ul><h2 id="javaScriptFunctions">Overview</h2>
<p>Functions play a central role in the JavaScript language. They are easy to use, but hard to fully understand.</p>
<p>JavaScript is sometimes described as having features found in a
functional language. It is not a pure functional language, but it
shares some features of functional languages.</p>
<p>Though &quot;functional programming&quot; is a technical term with certain specific
meanings, for now, we can simply say that JavaScript is a functional
language in the sense that functions are the basic building blocks of well
written JavaScript code. Functions are first class citizens of JavaScript because they can be:</p>
<ul>
<li>assigned to variables</li>
<li>passed to as parameters to function</li>
<li>returned from functions</li>
<li>stored in a data structure.</li>
</ul>
<p>JavaScript functions can have properties and methods. They rely heavily on callbacks and closures, both of which are are made possible by JavaScript&#39;s remarkable implementation of functions.</p>
<p>There is no single way to invoke a function. In fact, they can be invoked in four different ways:</p>
<ul>
<li>As functions</li>
<li>As methods</li>
<li>As constructors</li>
<li>With the methods <strong>apply</strong> and <strong>call</strong></li>
</ul>
<p>Each of these invocation methods has distinct features, particularly in regard to the <strong>this</strong> operator.</p>
<p>Functions play a role in JavaScript similar to that
played by objects in a language like C# or Java. They are the building blocks of the language.</p>
<p><strong>NOTE</strong>: <em>If your mind is full with the wonders of a langauge like C#,
there is good reason for your opinion. But consider this: the move to
add LINQ to C# was in part an attempt to give C# some of the features
that have long been built into JavaScript. Many of these &quot;LINQ like&quot;
features of JavaScript derive from the central and powerful role played
by JavaScript functions. In other words, it is not always that one
language is innately superior to another language, but rather that each
has its own virtues.</em></p>
<h2 id="what-are-functions">What are Functions</h2>
<p>Functions are unique in that they can be invoked, they can be executed.</p>
<p>Somewhat unexpectedly, functions are like any other value in JavaScript. In particular, functions are <strong>objects</strong>. In particular, functions are instances of the built-in JavaScript <strong>Function</strong> object.</p>
<p>Because functions are objects, you can do many of the same things with them that you can do with a <strong>string,</strong> <strong>number</strong>or <strong>object</strong>. For instance, you can:</p>
<ul>
<li>Store them in a variable</li>
<li>Put them in an <strong>array</strong></li>
<li>Pass them to a <strong>function</strong>, or return them from a function.</li>
</ul>
<p>Because functions are objects, you can do the same things with them that
you can do with any other object. For instance, you can give them properties
and methods. Note that functions also have:</p>
<ul>
<li>a <strong>constructor</strong>, which is a particularly powerful tool.</li>
<li>a <strong>prototype</strong> property.</li>
</ul>
<p>We will discuss <strong>prototypes</strong> in more depth later on in this document. The key
point to grasp at this point is simply that all functions automatically get
a constructor, which points at themselves, and an empty <strong>prototype</strong>.</p>
<h2 id="function-types">Types of Functions</h2>
<p>There are several styles of functions. The simplest:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fulano</span><span class="hljs-params">()</span> </span>{}  <span class="hljs-comment">// Simple function</span>

<span class="hljs-keyword">var</span> fulano = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{}; <span class="hljs-comment">// Anonymous function assigned to a variable</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fulano</span><span class="hljs-params">()</span> </span>{} <span class="hljs-comment">// Function constructor. Capital letter means call it with new.</span>

<span class="hljs-keyword">var</span> myObject = {
   prop: <span class="hljs-number">1</span>,             <span class="hljs-comment">// Property inside an object</span>
   fulano: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ } <span class="hljs-comment">// Function as a method of an object</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fulano</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> bar  = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{}; <span class="hljs-comment">// function inside a function constructor</span>
  Fulano.prototype.foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};  <span class="hljs-comment">// Function on a prototype</span>
}
</code></pre>
<p>As <a href="#function-this">explained later</a>, these various ways of invoking a function alter the value of the <strong>this</strong> keyword inside the function.</p>
<h2 id="simple-functions">Simple Functions</h2>
<p>Here is one way to write a JavaScript function:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test01</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Test01"</span>;
    $(<span class="hljs-string">"#Test01"</span>).html(name);
}
</code></pre>
<p>This declaration has the following parts:</p>
<ul>
<li>The keyword <strong>function</strong></li>
<li>A name, which in this case is <strong>Test01</strong></li>
<li>A parameter list, which in this case is empty. The parameter list
appears between an open and close paranthesis: ()</li>
<li>An implementation, which appears between curly braces: {}. In this
case we declare a variable, and then use jQuery to show its value in
a web page.</li>
</ul>
<h2 id="two-ways-to-declare-functions">Two Ways to Declare Functions</h2>
<p>Here is a second way to declare a function. This time we will store an
anonymous function in a variable called <strong>test01</strong>:</p>
<pre><code><span class="hljs-keyword">var</span> test01 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
   <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Test01"</span>;
   $(<span class="hljs-string">"#Test01"</span>).html(name);
};
</code></pre><p>There is little practical difference between assigning a function to a
variable as shown here, or the creating functions as shown above. When
assigned to a variable, as shown above, the <strong>name</strong> field of the function
object is not filled out. When you declare a function as shown earlier, then
the name filed is filled out.</p>
<p>Consider the following program:</p>
<pre><code><span class="hljs-keyword">var</span> variable00;
<span class="hljs-keyword">var</span> func01 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func02</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"variable00: "</span> + variable00);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"func01.name: "</span> + func01.name);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"type of func01.name: "</span> + <span class="hljs-keyword">typeof</span> func01.name);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"func02.name: "</span> + func02.name);
</code></pre><p>Here is the output:</p>
<pre><code>variable00: undefined
func01<span class="hljs-selector-class">.name</span>:
type of func01<span class="hljs-selector-class">.name</span>: string
func02<span class="hljs-selector-class">.name</span>: func02
</code></pre><p>Notice that <strong>func01</strong> is assigned to a variable, and <strong>func02</strong> is a
standard function. Hence we see that <strong>func01</strong> has no <strong>name</strong> while
<strong>func02</strong> has a name.</p>
<p>You can find the source for this example on GitHub:</p>
<p><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Syntax/Functions01">JsObjects/JavaScript/Syntax/Function01</a></p>
<h2 id="arguments-and-parameters">Arguments and Parameters</h2>
<p>A function can be passed parameters and can return a value:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">return</span> a * b;
}
</code></pre><p>This function differs from the first sample in that it takes two
parameters, called a and b. Here is a somewhat more verbose version of
the same function. This second verison has more descriptive parameters
called <strong>operandA</strong> and <strong>operandB</strong>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span><span class="hljs-params">(operandA, operandB)</span> </span>{
    <span class="hljs-keyword">return</span> operandA * operandB;
}
</code></pre><p>Notice that we don&#39;t declare the types of the parameters, nor the type
of the return value. There is no type checking on these parameters. If
we omit a parameter when invoking the function then that parameter will
have the value <strong>undefined</strong>. If we pass in too many parameters when
calling a function, then the extra parameters will simply be ignored.</p>
<p>Each function is implicitly passed an object called <strong>arguments</strong>. Suppose
you declare a method that looks like this:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>{
}
</code></pre><p>Suppose further that you call it like this:</p>
<pre><code><span class="hljs-keyword">add(12, </span><span class="hljs-number">15</span>)<span class="hljs-comment">;</span>
</code></pre><p>Even though you did not specify any parameters for the function, you can
nevertheless access the arguments that are passed in to it:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span>(<span class="hljs-string">'You must pass in either one or two parameters.'</span>);
    }
}
</code></pre><p>Here is a complete example:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserException</span>(<span class="hljs-params">message</span>) </span>{
   <span class="hljs-keyword">this</span>.message = message;
   <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"UserException"</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserException(<span class="hljs-string">'You must pass in either one or two parameters.'</span>);
    }
}


<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">2</span>));
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));
<span class="hljs-built_in">console</span>.log(add());
</code></pre><p>The source is here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Syntax/FunctionArguments">JsObjects</a></li>
</ul>
<h2 id="function-this">The <em>this</em> Keyword</h2>
<p>The <strong>this</strong> keyword in JavaScript is often called the function context. If you
are used to C# or other object oriented langauges, you may have certain
preconceived ideas about the <strong>this</strong> operator which will prevent you from
understanding the role <strong>this</strong> plays in JavaScript.</p>
<p>The key point to grasp is that the function context changes depending on how you invoke a function.
The change occurs not because of the way you declare a function, but because of the way you invoke it. In particular, there are four
ways to invoke a JavaScript function:</p>
<ul>
<li>As a standalone function</li>
<li>As method of an object</li>
<li>As a constructor</li>
<li>Via <strong>call</strong> or <strong>apply()</strong></li>
</ul>
<p>If you are working in a web browser, and you invoke a simple standalone function, then the <strong>this</strong>
object will usually be the global <strong>window</strong> object that is part of the browser:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runMe</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
<span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-title">Context</span> = <span class="hljs-title">runMe</span>(<span class="hljs-params"></span>)</span>;
</code></pre><p>In the code shown above, functionContext will be the <strong>window</strong> object.</p>
<p>Consider this code:</p>
<pre><code>    <span class="hljs-keyword">var</span> myObject = {
        runMe: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }
    }

    <span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-title">Context</span> = <span class="hljs-title">myObject</span>.<span class="hljs-title">runMe</span>(<span class="hljs-params"></span>)</span>;
</code></pre><p>In the code shown above, functionContext will be <strong>myObject</strong>.</p>
<p>And finally, let&#39;s look at this example:</p>
<pre><code>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RunMe</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">var</span> functionContext = <span class="hljs-keyword">new</span> RunMe();
</code></pre><p>In this last example, we are creating a constructor by invoking the <strong>new</strong>
operator. In this case, functionContext is <strong>RunMe</strong>.</p>
<p>Here are all three cases pulled together in a single program from JsObjects
calld ObjectThis:</p>
<pre><code>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runMe</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }

    <span class="hljs-keyword">var</span> myObject = {
        runMe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RunMe</span>(<span class="hljs-params"></span>) </span>{
        $(<span class="hljs-string">'#test03'</span>).append(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> RunMe);
    }

    $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">        "use strict"</span>;
        <span class="hljs-keyword">var</span> functionContext = runMe();
        $(<span class="hljs-string">'#test01'</span>).append(functionContext === <span class="hljs-built_in">window</span>);

        <span class="hljs-keyword">var</span> functionContext2 = myObject.runMe();
        $(<span class="hljs-string">'#test02'</span>).append(functionContext2 === myObject);

        <span class="hljs-keyword">var</span> functionContext3 = <span class="hljs-keyword">new</span> RunMe();
        $(<span class="hljs-string">'#test04'</span>).append(functionContext3 <span class="hljs-keyword">instanceof</span> RunMe);   
    });
</code></pre><p>In <strong>strict</strong> mode, <strong>this</strong> is set to undefined rather than the global object when invoking a standalone method without calling <strong>new</strong>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello01</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
}

hello01(); <span class="hljs-comment">// global object</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello02</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    "use strict"</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
}

hello02(); <span class="hljs-comment">// undefined</span>
</code></pre><h2 id="functions-and-variables">Functions and Variables</h2>
<p>There is no difference from the callers point of view between these two declarations:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveScore</span><span class="hljs-params">()</span> </span>{ }
<span class="hljs-keyword">var</span> saveScore = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};
</code></pre><p>One is a function named <strong>saveScore</strong> and the other is a variable called
<strong>saveScore</strong> that references an anonymous function. You can
call them both like this:</p>
<pre><code>saveScore()<span class="hljs-comment">;</span>
</code></pre><p>The differences is that the first one has a property called <strong>name</strong> that is
set to the value <strong>saveScore</strong>, while the second has a property called
<strong>name</strong> that is set to an empty string.</p>
<p><strong>NOTE</strong>: To see the difference in the name property of the two versions of
saveScore, take a look at the Functions01 example from
<strong>JsObjects/JavaScript/Syntax</strong>. Note also that declaration with an
anonymous function ends with a semicolon and the other does not.</p>
<p>If you are setting up a callback, then you just pass in a variable which is
the name of a function:</p>
<pre><code><span class="hljs-variable">$(</span><span class="hljs-string">"#Button01"</span>).click(myButtonClickHandler);
</code></pre><p>In this case, we don&#39;t call the function, that is we don&#39;t write this:</p>
<pre><code><span class="hljs-variable">$(</span><span class="hljs-string">"#Button01"</span>).click(myButtonClickHandler());
</code></pre><p>We just pass in its name, as shown in the first of the two examples shown
above.</p>
<p>All this is a bit confusing to new comers because they are not used to
languages where functions are first class members of the language. A
JavaScript function has all the power of any other object or variable.
That&#39;s why the following are the same:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveScore</span><span class="hljs-params">()</span> </span>{ }
<span class="hljs-keyword">var</span> saveScore = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};
</code></pre><p>It just doesn&#39;t matter whether you are calling a function or a variable that
points at a function. Both are objects, and both are treated the same.</p>
<h2 id="functions-and-objects">Functions and Objects</h2>
<p>Each function that you declare in JavaScript is an object. When you look
at the following code, you might therefore be forgiven for supposing
that <strong>name</strong> is a field of Test01, and that a call to print that name
would work. In fact, <strong>name</strong> is a private field of the object, and
therefore cannot be seen by an instance of Test01. The <strong>description</strong>
property, shown below, is a public member of Test01, and it will be
accessible from an instance of the object.</p>
<pre><code><span class="hljs-keyword">var</span> Test01 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
</span>{
   <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Test01"</span>;
}

Test01.prototype.description=<span class="hljs-string">"This is a test object"</span>;

<span class="hljs-keyword">var</span> Test02 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">var</span> test01 = <span class="hljs-keyword">new</span> Test01();
    $(<span class="hljs-string">"#Description01"</span>).html(test01.description);
    $(<span class="hljs-string">"#Name01"</span>).html(test01.name);
}
</code></pre><p>When Test02 is called, the code shown above prints out the string &quot;This
is a test object&quot; but it does not print out the words &quot;Test01.&quot; That is
because the property <strong>description</strong> is visible to an instance of
<strong>Test01</strong>, but the field <strong>name</strong> is unknown.</p>
<p>To make name a public field of the object, write code that qualifies the
instance of <strong>nameStr</strong>with the keyword <strong>this</strong>:</p>
<pre><code><span class="hljs-keyword">var</span> Test01 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">this</span>.nameStr = <span class="hljs-string">"Test01"</span>;
}

Test01.prototype.description=<span class="hljs-string">"This is a test object"</span>;

<span class="hljs-keyword">var</span> Test02 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">var</span> test01 = <span class="hljs-keyword">new</span> Test01();
    $(<span class="hljs-string">"#Description01"</span>).html(test01.description);
    $(<span class="hljs-string">"#Name01"</span>).html(test01.nameStr);
}
</code></pre><p>Now the code shown above behaves as expected, and inserts both
<strong>nameStr</strong> and <strong>description</strong> into the appropriate tags in our HTML.</p>
<p>Like Extensions methods in C#, you can use Prototype to change the way
existing classes work. In the following example, we will add a method
called Decorate to the built-in JavaScript String class:</p>
<pre><code><span class="hljs-built_in">String</span>.prototype.decorate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-keyword">return</span> <span class="hljs-string">"-***-"</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">"-***-"</span>;
}
</code></pre><p>Now when you create a string, you can call its decorate method:</p>
<pre><code><span class="hljs-keyword">this</span>.testDecoration = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> testStr = <span class="hljs-string">"All my strings can be decorated"</span>;
    $(<span class="hljs-string">"#testPlain"</span>).html(testStr);
    $(<span class="hljs-string">"#testDecorate"</span>).html(testStr.decorate());
}
</code></pre><p><a href="BasicSyntax.html#decorate">Click here to try decorating a string</a>.</p>
<h2 id="strict-mode">Strict Mode</h2>
<p>General changes:</p>
<ul>
<li>Changes some silent errors to visible errors</li>
<li>Helps the compiler optimize code</li>
<li>Helps you write more secure code</li>
<li>Prepares the way for future versions of JavaScript. Helps you write code that will be compatible with ES6</li>
</ul>
<p>A few of the Details:</p>
<ul>
<li>All variables must be declared (use var)<ul>
<li>var a = 2; // correct</li>
<li>a = 2; // wrong</li>
</ul>
</li>
<li>The <strong>with</strong> statement is not allowed</li>
<li>Octal syntax is forbidden</li>
<li>Functions outside objects have this set to undefined</li>
<li>ReadOnly properties are honored</li>
<li>Objects can be sealed</li>
<li>Eval works in its own scope, not local or global scope</li>
<li>Language is safer with strict.</li>
</ul>
<h2 id="callbacks">Callbacks: Passing Functions as Parameters</h2>
<p>Callbacks are very common in JavaScript. In other languages, they are often considered esoteric, but in JavaScript they happen all the time.</p>
<p><strong>NOTE</strong>: <em>Callbacks are the key to understanding asynchronous processing in JavaScript. If we are in a browser and make a call to the server, then we don&#39;t know when, or even if, the call will return. As a result, we don&#39;t make the call synchronously. That is, we don&#39;t wait around for the call to return. Instead, we make the call, and then continue on processing code. When the call returns, we are notified. This is known as an asynchronous call, and in JavaScript we handle these calls with callbacks. Since we make lots of calls to the server in a typical JavaScript program, our ability to understand callbacks becomes key to our ability to understand even basic Web programming.</em></p>
<p>JavaScript considers functions to be first class citizens of the language. This means that you can easily assign them to variables, and pass them around to other functions. Other languages usually provide support for function pointers of function objects, but the syntax is often awkward or challenging to use. In JavaScript, you can simply treat a function like any other type, such as a <strong>Number</strong>, <strong>String</strong> or <strong>Boolean</strong>.</p>
<p><strong>NOTE</strong>: <em>Because functions in JavaScript are so flexible, many consider JavaScript to be a <a href="http://en.wikipedia.org/wiki/Functional_programming">functional</a> programming language. Functional programming is enormously powerful, and also quite different from the type of <a href="http://en.wikipedia.org/wiki/Imperative_programming">imperative</a> programming done in Java and C#. Ultimately, the flexibility of JavaScript functions will enable you to write your code in a <strong>functional</strong> style that is quite different from what you write when using more traditional languages. This is not the place to explore this topic in depth, but you should at least be aware of the power of functions in JavaScript, and the way that they shape our approach to the language. Functional programming is a type of <a href="http://en.wikipedia.org/wiki/Declarative_programming">declarative programming</a>.</em></p>
<p>Here is an example of how to use callbacks in JavaScript:</p>
<pre><code><span class="hljs-comment">/**
 * @author Charlie
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">func</span>) </span>{
    $(<span class="hljs-string">"#test02"</span>).html(<span class="hljs-string">"It works! "</span>);
    func();
}

$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">  "use strict"</span>;


  $(<span class="hljs-string">"#test01"</span>).html(<span class="hljs-string">"Document Read called"</span>);

  hello(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      $(<span class="hljs-string">"#test03"</span>).html(<span class="hljs-string">"It's a nine!"</span>);
  });

});
</code></pre><p>The complete example is here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Objects/ObjectFunctionBasics02">JsObjects Objects ObjectFunctionBasics02</a></li>
</ul>
<p>In this example, we pass an anonymous function to the method <strong>hello</strong>. As you can see, <strong>hello</strong> takes a single parameter called func:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span><span class="hljs-params">(func)</span> </span>{
</code></pre><p>When we call <strong>hello</strong> we pass in an anonymous function, a bit like this:</p>
<pre><code>    <span class="hljs-keyword">var</span> helloParameter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          $(<span class="hljs-string">"#test03"</span>).html(<span class="hljs-string">"It's a nine!"</span>);
    }

    hello(helloParameter);
</code></pre><p>But in JavaScript we get a special dispensation, as it were, and don&#39;t even have to declare the variable that points at our function. Instead, we can just pass it in directly as an anonymous function:</p>
<pre><code>    hello(<span class="hljs-name">function</span>() {
        $(<span class="hljs-string">"#test03"</span>).html(<span class="hljs-string">"It's a nine!"</span>)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
</code></pre><p>We call the function <strong>anonymous</strong> because it has no name:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    $(<span class="hljs-string">"#test03"</span>).html(<span class="hljs-string">"It's a nine!"</span>);
}
</code></pre><p>Compare the above to a standard function with a name:</p>
<pre><code>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeNine</span>(<span class="hljs-params"></span>) </span>{
        $(<span class="hljs-string">"#test03"</span>).html(<span class="hljs-string">"It's a nine!"</span>);
    }
</code></pre><p>If callbacks and anonymous functions are unclear, think about them some more. If these subjects are still unclear, get up, take a 1 minute walk, then come back and think about it all again. Download the example and step through it. Come to terms with this syntax. You will never really understand JavaScript until you understand code of this type.</p>
<p><strong>Aside</strong>: <em>Do JavaScript programmers dream callbacks? Of course!</em></p>
<p>Here is another example designed to drive home the points outlined above:</p>
<pre><code><span class="hljs-comment">/**
 * @author Charlie
 */</span>

<span class="hljs-keyword">var</span> Converter = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

    <span class="hljs-comment">// Private variable</span>
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Converter</span>(<span class="hljs-params">initX</span>) </span>{
        x = initX;
    }

    <span class="hljs-comment">// Private method</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value * value;        
    }

    <span class="hljs-comment">// Public methods</span>
    Converter.prototype.convert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
        <span class="hljs-keyword">var</span> result = square(x);
        <span class="hljs-keyword">return</span> func(result);      
    };

    <span class="hljs-keyword">return</span> Converter;
})();

$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-string">"use strict"</span>;

    <span class="hljs-keyword">var</span> converter = <span class="hljs-keyword">new</span> Converter(<span class="hljs-number">2</span>);

    <span class="hljs-keyword">var</span> feet = converter.convert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">miles</span>) </span>{
        <span class="hljs-keyword">return</span> miles * <span class="hljs-number">5280</span>;
    });

    <span class="hljs-keyword">var</span> yards = converter.convert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">miles</span>) </span>{
        <span class="hljs-keyword">return</span> miles * (<span class="hljs-number">5280</span> / <span class="hljs-number">3</span>);
    });

    $(<span class="hljs-string">"#feet"</span>).html(feet);
    $(<span class="hljs-string">"#yards"</span>).html(yards);
});
</code></pre><p>The source is here:</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/Objects/ObjectDemoCallback03">JsObjects ObjectDemoCallback</a></li>
</ul>
<h2 id="callFunction">Calling a JavaScript Function from a Declaration</h2>
<p>The following code demonstrates the differences between assigning a method to a variable and assigning the result of a function call to a variable. Notice the extra parentheses at the end of the getNine02. This
causes the function to be called at the time of the assignment. This means that getNine02 ends up a being a <strong>number</strong>, while getNine01 ends up being <strong>function object</strong>.</p>
<p>In the <strong>getNine02</strong> example, the open parenthesis before the word function is syntactical sugar. It does not have any other function other than to tell us that this function is going to be called immediately with the closing set of parentheses. If one is reading a long function, we want to be told up front that it is going to be called immediately. There is no good way to do that, so a convention has been developed of adding parentheses before the word function to serve as a hint that the function will be called immediately.</p>
<pre><code class="lang-javascript">    <span class="hljs-comment">/**
     * @author Charlie
     */</span>

    <span class="hljs-comment">// getNine is assigned a function that returns the number 9</span>
    <span class="hljs-keyword">var</span> getNine01 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;
    }

    <span class="hljs-comment">/*
     * getNine02 is set to the number 9. Notice the
     * the parentheses at the end of the statement.
     * They force the function to be called during the
     * assignment
     */</span>
    <span class="hljs-keyword">var</span> getNine02 = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;    
    })();

    $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">      "use strict"</span>;

      <span class="hljs-comment">// We call getNine01() because it is a function</span>
      <span class="hljs-keyword">var</span> result01 = getNine01();
      $(<span class="hljs-string">"#test01"</span>).html(result01);

      <span class="hljs-comment">// Get Nine02 is not a function, but a simple number</span>
      <span class="hljs-comment">// Hence it is not called. Notice there are no parentheses</span>
      <span class="hljs-keyword">var</span> result02 = getNine02;
      $(<span class="hljs-string">"#test02"</span>).html(result02);
    });
</code></pre>
<h2 id="compareObjFunc">Comparing JavaScript objects and JavaScript functions</h2>
<p>Previously in this document, in the section on objects, we declared a
simple object that looks like this:</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-keyword">var</span> myObject = {                
    myProperty01: <span class="hljs-number">12</span>,
    myProperty02: <span class="hljs-number">4</span>,
    myFunction01: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myProperty01 + <span class="hljs-keyword">this</span>.myProperty02;                
    }                
);
</code></pre>
<p>We call it like this:</p>
<pre><code>myObject.myFu<span class="hljs-symbol">nction01</span><span class="hljs-comment">()</span>
</code></pre><p>This is very nice, but it does not give us the option to create private
methods.</p>
<p>Here is what the same object would look like if declared as a function:</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction02</span>(<span class="hljs-params"></span>) </span>{   
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-keyword">var</span> myField01 = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> myField02 = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> nestedFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> myField01 + myField02;  
    };

    <span class="hljs-keyword">return</span> nestedFunction();
}
</code></pre>
<p>We call it like this:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">myFunction02</span><span class="hljs-params">()</span></span>
</code></pre><p>Let&#39;s call this the Simple Function pattern. This is very nice, but it
does not gives us the option to create public methods. As you can see,
if I want to call <strong>nestedFunction</strong>, I need to call it from inside of
<strong>myFunction02</strong>. This is less than optimal in some cases.</p>
<p>Here is a third technique that uses the <strong>prototype</strong> function syntax,
and gives us public methods, but no useful private methods:</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-keyword">var</span> MyFunction03 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;       
};

MyFunction03.prototype.field01 = <span class="hljs-number">2</span>;
MyFunction03.prototype.field02 = <span class="hljs-number">4</span>;
MyFunction03.prototype.nestedFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.field01 + <span class="hljs-keyword">this</span>.field02;    
};
</code></pre>
<p>We call it like this:</p>
<pre><code><span class="hljs-keyword">var</span> myFunction03 = <span class="hljs-keyword">new</span> MyFunction03();
myFunction03.nestedFunction();
</code></pre><p>This is very nice, but it does not give us private methods. Note also,
that it forces us to call <strong>new</strong> when we create the object. If we don&#39;t
call new, then nestedFunction will not be visible when we try to use the
object. In other words, our public method won&#39;t be truly public.</p>
<p>And here finally, is a fourth way of writing the same object. We call
this the module pattern. It provides both public methods and private
methdos, private fields, and it gives us a constructor for initializing
the fields. It&#39;s syntax is more verbose, but it gives us everything we
need. Also, the syntax, though a bit verbose, is similar to the class
declarations in other curley brace languages such as C#.</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-keyword">var</span> MyFunction04 = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-keyword">var</span> field01 = <span class="hljs-number">0</span>,
    field02 = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFunction04</span>(<span class="hljs-params">initField01, initField02</span>) </span>{
        field01 = initField01;
        field02 = initField02;
    }

    MyFunction04.prototype.nestedFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> field01 + field02;
    };    

    <span class="hljs-keyword">return</span> MyFunction04;
}());
</code></pre>
<p>We call it like this:</p>
<pre><code class="lang-%7B.code%7D"><span class="hljs-keyword">var</span> myFunction04 = <span class="hljs-keyword">new</span> MyFunction04(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
myFunction04.nestedFunction();
</code></pre>
<p>This is the best solution.</p>
<p>Now go back and look at the original object pattern. Compare it to the
one we have created. Notice that they are two different ways of saying
the same thing, only the module pattern is more flexible, and more
powerful.</p>
<p>Get the Source:</p>
<ul>
<li><a href="/charlie/downloads/JavaScriptObjectPatterns.zip">JavaScriptObjectPatterns.zip</a></li>
</ul>
<h2 id="properties-and-inheritance">Properties and Inheritance</h2>
<p>Inheritance is done most often through the <strong>prototype</strong> property. Declare a base object:</p>
<pre><code><span class="hljs-keyword">var</span> BaseObject = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BaseObject</span>(<span class="hljs-params"></span>) </span>{
    }

    BaseObject.prototype.firstName = <span class="hljs-string">"Qux"</span>;

    <span class="hljs-keyword">return</span> BaseObject;
}());
</code></pre><p>Now define the child object:</p>
<pre><code><span class="hljs-keyword">var</span> ChildObject = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildObject</span>(<span class="hljs-params"></span>) </span>{
    }

    ChildObject.prototype = <span class="hljs-keyword">new</span> BaseObject();

    ChildObject.prototype.lastName = <span class="hljs-string">"Garply"</span>;

    <span class="hljs-keyword">return</span> ChildObject;
}());
</code></pre><p>The key line is this:</p>
<pre><code><span class="hljs-type">ChildObject</span>.proto<span class="hljs-keyword">type</span> = new <span class="hljs-type">BaseObject</span>();
</code></pre><p>This means that the child will inherit all the properties that are part of the parents prototype. BaseObject, in its turn, automatically inherits all the properties from the built in Object. That means that ChildObject inherits them also.</p>
<p>Now test the code:</p>
<pre><code><span class="hljs-keyword">var</span> childObject = <span class="hljs-keyword">new</span> ChildObject();
<span class="hljs-built_in">console</span>.log(childObject.firstName);
<span class="hljs-built_in">console</span>.log(childObject.lastName);
</code></pre><p>As you can see, the child inherits the <strong>fistName</strong> property from the parent.
The working example is <a href="https://github.com/charliecalvert/JsObjects/blob/master/JavaScript/Objects/Inheritance01/SimpleInheritance00.js">here</a>.</p>
<p>Notice that these objects use <strong>PascalCase</strong>, that is, the initial letter in their name is a Capital. Like this: <strong>ChildObject</strong>. Not <strong>camelCase</strong> like this: <strong>childObject</strong>.</p>
<p>When we use Pascal case for the first letter of an object, we are saying that must be called with new:</p>
<pre><code><span class="hljs-keyword">var</span> childObject = <span class="hljs-keyword">new</span> ChildObject();
</code></pre><p>If we want to use the protype property, then we must instantiate the object with <strong>new</strong>. In other words, prototypal inheritance in JavaScript only works with constructor objects. That is, it only works with objects instantiated with <strong>new</strong>.</p>
<h2 id="this-and-that">This and That</h2>
<p>One of the real weak points in JavaScript is the <strong>this</strong> keyword. It is designed to allow an object to have access to its own properties and methods. That is common enough. The catch, however, is that this does not always point at what you think it should point at. In particular, in callbacks and the special case of callbacks called event handlers, the <strong>this</strong> keyword typically points at the object that made the call, or at the global <strong>window</strong> object. To get around this problem, and to allow an object to have access to itself when in a callback, we do this:</p>
<pre><code><span class="hljs-keyword">var</span> MyObject = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> that;
  <span class="hljs-keyword">var</span> foo;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyConstructor</span><span class="hljs-params">()</span> </span>{
     that = <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyCallback</span><span class="hljs-params">()</span> </span>{
    that.foo = <span class="hljs-string">'baz'</span>;
  }
}
</code></pre><p>This is hard to grasp at first mostly because it does not seem possible that JavaScript should have such a serious flaw in the language. If <strong>MyCallBack</strong> is part of <strong>MyObject</strong> then inside of <strong>MyCallback</strong> this ought to point to <strong>MyObject</strong>. But this is not necessarily the case, and as a result, we do the craziness with the that variable.</p>
<p>In general, the recommendation is not to use this outside of the constructor. Every place else, it is a danger to itself and others. We spend a lot of time learning how to write code that has no use for either this or that. But sometimes, we have no choice, and use that.</p>
<p>Here is another way to look at the same problem. Private methods and some callbacks cannot always properly access the <strong>this</strong> property that belongs to the object of which they are members. As a result, we must develop a work around. To solve the problem we typically declare <strong>this</strong> as <strong>that</strong>.</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFunc</span>(<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.data = <span class="hljs-number">3</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">privateFunc</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(that.data);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myEvenHandler</span>(<span class="hljs-params">event</span>) </span>{
        <span class="hljs-built_in">console</span>.log(that.data);
    }
}
</code></pre><p>Please understand that this is just a convention. But it is a common convention. An experienced
JavaScript developer who sees <strong>that</strong> in your code expects it to be pointing to the <strong>this</strong>
property for the enclosing object.</p>
</div></body></html>