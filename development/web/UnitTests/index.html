<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>index</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="components/bootstrap/dist/css/bootstrap-theme.min.css"><link href="/libs/css/BootstrapIndex.css" rel="stylesheet" type="text/css"><link href="/css/style.css" rel="stylesheet" type="text/css"><script src="components/jquery/dist/jquery.js"></script><script src="components/angular/angular.js"></script><script src="components/angular-route/angular-route.js"></script><script src="components/bootstrap/dist/js/bootstrap.min.js"></script><script src="/libs/scripts/elvenware.js" type="text/javascript"></script><script src="/libs/scripts/Control.js"></script></head><body ng-app="elfApp"><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/about">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/development/index.html">Strongly Typed</a></li><li><a href="/development/web/index.html">Web & Scripts</a></li><li><a href="/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>index</h1><p>Welcomes to index</p><ul><!--TOC_Start--><li><a href="#unit-tests">Unit Tests</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#structure">Structure</a></li>
<li><a href="#the-code">The Code</a></li>
<li><a href="#types_of_assertions">Types of Assertions</a></li>
<li><a href="#async">Async Tests</a></li>
<li><a href="#callbacks-and-async-test">Callbacks and Async Test</a></li>
<li><a href="#private-methods">Private Methods</a></li>
<li><a href="#mocha-and-unit-tests-with-node">Mocha and Unit Tests with Node</a></li><!--TOC_End--></ul><h1 id="unit-tests">Unit Tests</h1>
<h2 id="examples">Examples</h2>
<p>Click the links below to see a unit test in action.</p>
<ul>
<li><a href="Basics.html">Basics</a></li>
<li><a href="Jasmine.html">Jasmine</a></li>
<li><a href="Mocha.html">Mocha</a></li>
<li><a href="TestCanvasCode.html">TestCanvasCode</a></li>
<li><a href="Grunt.html">Grunt</a></li>
<li><a href="Protractor.html">Protractor</a>;</li>
<li><a href="#types_of_assertions">Types of Assertions</a></li>
<li><a href="#async">Async and Ajax Tests</a></li>
</ul>
<p>The code shown here depends on QUnit. You can download the source here:</p>
<ul>
<li><a href="http://docs.jquery.com/QUnit">http://docs.jquery.com/QUnit</a></li>
</ul>
<h2 id="structure">Structure</h2>
<p>Whether you are using qUnit, Jasmine, or some other library, the 
basic structure of your program stays the same. Sometimes naming 
conventions change. For instance, Jasmine prefers the word Spec 
rather than test, but the basic structure does not change. </p>
<p>Suppose we have four files in our project:</p>
<ul>
<li>index.html</li>
<li>index.js</li>
<li>TestIndex.js</li>
<li>TestIndex.html</li>
</ul>
<p>Now which html files link in which JavaScript files? Put your code
together with a structure like this:</p>
<ul>
<li>The file <strong>index.html</strong> links in <strong>index.js</strong></li>
<li>Then <strong>TestIndex.html</strong> links in both <strong>index.js</strong> and <strong>TestIndex.js</strong>, plus your unit test library.</li>
</ul>
<p>There is no duplication of code. The code to be tested appears only 
in <strong>index.js</strong>. There is no need to copy it to another location.</p>
<p>I&#39;ll give a moderately more complex example. The names I 
supply are meant to be generic, and not to apply to a particular 
project. In other words, you might not call a file <strong>MyObject01.js</strong>, 
by something more specific, like <strong>Calculator.js</strong>:</p>
<ul>
<li><strong>index.html</strong>: This file is for the end user and has no tests in it.</li>
<li><strong>MyObject01.js</strong>: One JavaScript object used by <strong>index.html</strong></li>
<li><strong>MyObject02.js</strong>: A second JavaScript object used by <strong>index.html</strong></li>
<li><strong>TestMyObject01.html</strong>: Run tests for <strong>MyObject01.js</strong></li>
<li><strong>TestMyObject02.html</strong>: Run tests for <strong>MyObject02.js</strong></li>
<li><strong>TestMyObject01.js</strong>: Tests for <strong>MyObject01.js</strong></li>
<li><strong>TestMyObject02.js</strong>: Tests for <strong>MyObject02.js</strong></li>
</ul>
<p>Both <strong>index.html</strong> and <strong>TestMyObject01.html</strong> 
should link in <strong>MyObject01.js</strong>. While <strong>TestMyObject01.html</strong> 
should also link in <strong>TestMyObject01.js</strong>:</p>
<ul>
<li><p>index.html</p>
<ul>
<li>MyObject01.js</li>
</ul>
</li>
<li><p>TestMyObject01.html</p>
<ul>
<li>MyObject01.js</li>
<li>TestMyObject.js</li>
</ul>
</li>
</ul>
<p>It is <strong>TestMyObject01.html</strong> and <strong>TestMyObject02.html</strong> that 
contain the links to the Jasmine files in your Library directory.</p>
<p>There is a school of thought that says that unit tests should be 
called <strong>specs</strong>, since they double as specifications for your 
objects. If you want to call the files MyObject01Spec.html, or 
MyObject01.spec.html** instead of TestMyObject01.html, then that is 
fine, but I am not yet totally onboard with this second naming 
convention, though it is common in the Jasmine world.</p>
<h2 id="the-code">The Code</h2>
<p>The HTML shown below hosts a unit testing framework called QUnit. which
is designed to help you test your JavaScript. It works just like an
other unit testing framework, but some of the syntax is a bit unique due
to the advanced use of makes of some rather esoteric JavaScript
features.</p>
<p>Note that they code includes both <strong>qunit.js</strong> and <strong>qunit.css</strong>. You
can download these files form the QUnit site:</p>
<ul>
<li><a href="http://docs.jquery.com/QUnit">http://docs.jquery.com/QUnit</a></li>
</ul>
<p>In the code shown here, note the inclusion of tags with id&#39;s that follow
the pattern qunit-XXX. For instance, you can find qunit-fixture,
qunit-header, etc. This code provides that hooks that qunit uses when it
displays the results of a test. QUnit does what any other unit testing
framework does: it calls your methods and gives you a chance to confirm
that they behave as expected. In addition, QUnit also reports the
results of these tests in an HTML file. The code below is an example of
such a file, the qunit_XXX hooks are the controls that get filled in
with the reports on the results of your tests. To get a better idea of
how it works, run one of the examples linked in the previous section.</p>
<pre><code class="lang-{.code}">&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
  &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;
  &lt;title&gt;QUnit Unit Test Basics&lt;/title&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../../../libs/qunit/qunit.css&quot; type=&quot;text/css&quot; /&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;../../../libs/qunit/qunit.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;../Scripts/testCode.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id=&quot;qunit-fixture&quot;&gt;
    Dependencies here
  &lt;/div&gt;


    &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;


  &lt;div&gt;
    &lt;input type=&quot;button&quot; value=&quot;Run Test&quot; onclick=&quot;runTests()&quot; /&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The most important element is qunit-banner. This is the element that is
lit up with either green, if the test succeeds, or red, if it fails.
Note that there is a control to display there user agent.</p>
<p>Instead of the two \<DIV\> blocks with the ID of QUnit and
QUnit-Fixture, you can use an alternative technique not used very often
any longer:</p>
<pre><code>    &lt;h1 id=&quot;qunit-header&quot;&gt;Using QUnit&lt;/h1&gt; 
    &lt;h2 id=&quot;qunit-banner&quot;&gt;&lt;/h2&gt; 
    &lt;h2 id=&quot;qunit-userAgent&quot;&gt;&lt;/h2&gt; 
    &lt;ol id=&quot;qunit-tests&quot;&gt;&lt;/ol&gt;
</code></pre><p>The first technique, however, is better and provides support for more
features in most cases. Just to be clear, it looks like this:</p>
<pre><code>    &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;
</code></pre><p>And here is some JavaScript for testCode.js. This is the code where the
actual unit test resides. In particular, if you click the button defined
in the HTML shown above, then the JavaScript runTest() function is
called.</p>
<pre><code class="lang-{.code}">function runTest()
{
    module(&quot;Basic Unit Test&quot;);

    test(&quot;Division&quot;, function () { 
        var actual = add(3, 7);
        var expected = 10;
        equals(actual, expected,
        &#39;Expected 2 as the result, result was: &#39; + add(4, 2));
    });


    test(&quot;Trial&quot;, function () {
        equals(2, 2, &#39;Is two equal to 2&#39;);
    });
}

function add(a,b)
{
    return a + b;
}

// Imitate C# string formatting (from StackOverflow)
String.prototype.format = function() 
{
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) 
    { 
        return typeof args[number] != &#39;undefined&#39; ? args[number] : match;
    });
};
</code></pre>
<p>Let&#39;s take a look at one of the tests:</p>
<pre><code>    test(&quot;Trial&quot;, function () {
        equals(2, 2, &#39;Is two equal to 2&#39;);
    });
</code></pre><p>We signal that we want to execute a unit test by calling qunit <strong>test</strong> function:</p>
<pre><code>    test();
</code></pre><p>We pass in two parameters. The first is the name we want to give to this 
particular test:</p>
<pre><code>    test(&quot;Trial&quot;, ...);
</code></pre><p>The second parameter is a callback inside of which we will run our test:</p>
<pre><code>    test(&quot;Trial&quot;, function () { ... });
</code></pre><p>There are a series of qunit assertions with names like <strong>equal</strong> or <strong>ok</strong>
that we can use to run our actual test. In this code, we test to make sure
that two equals two:</p>
<pre><code>    test(&quot;Trial&quot;, function () {
        equals(2, 2);
    });
</code></pre><p>Finally, if we wish, we can include a string that can be displayed when the test
is run to explain what success or failure for the test actually means.</p>
<pre><code>    test(&quot;Trial&quot;, function () {
        equals(2, 2, &#39;Is two equal to 2&#39;);
    });
</code></pre><p>The bit about <a href="http://docs.jquery.com/QUnit/module">modules</a> is a way to
group tests into categories. If you look at the output for basics tests,
you will see the string &quot;Basic Unit Test.&quot; This is there because we
include it in a <strong>module</strong> statement in function <strong>runTest</strong>:</p>
<pre><code class="lang-{.code}">module(&quot;Basic Unit Test&quot;);
</code></pre>
<h2 id="types_of_assertions">Types of Assertions</h2>
<p>The following assertions are available:</p>
<ul>
<li>equal</li>
<li>ok</li>
<li>throws</li>
<li>notEqual</li>
<li>deepEqual</li>
<li>notDeepEqual</li>
<li>strictEqual</li>
<li>notStrictEqual</li>
</ul>
<p>More information is available here:</p>
<p><a href="http://api.qunitjs.com/category/assert/">Qunit Docs</a></p>
<h2 id="async">Async Tests</h2>
<ul>
<li><a href="TestAjax.html">TestAjax.html</a></li>
</ul>
<p>Here is some simple code for running Ajax tests. This code uses the
qunit <strong>asyncTest</strong> method. The document ready method is used to call
the test twice, once with a valid URL, and once with an invalid URL.
Note that we call the qunit <strong>start()</strong> method after the callback is
called:</p>
<pre><code class="lang-{.code}">$(&#39;document&#39;).ready(function()
{
    ajaxTestGood(&quot;/cgi-bin/SimpleXml.py&quot;);
    ajaxTestGood(&quot;/cgi-bin/NoGood.py&quot;);
});

function ajaxTestGood(url)
{
    asyncTest(&quot;ajaxTestGood&quot;, function() {
        $.ajax(
        {
            type: &quot;GET&quot;,
            url: url,
            dataType: &quot;xml&quot;,
            cache: &#39;False&#39;,
            success: function (xml) 
            {       
                ok(true, url);
                start();
            },
            error:  function(request, ajaxOptions, thrownError)
            {
                ok(false, url);
                start();
            }
        });
    });
}
</code></pre>
<p>Here is the <strong>wrong way</strong> to write a test:</p>
<pre><code class="lang-{.code}">$(&#39;document&#39;).ready(function()
{
    ajaxTestBad();
    $(&#39;#debug&#39;).append(&#39;&lt;li&gt;Document Ready Called&lt;/li&gt;&#39;);
});

function ajaxTestBad()
{
    test(&quot;Bad Ajax!&quot;, function() {
        $(&#39;#debug&#39;).append(&#39;&lt;li&gt;Bar Test called&lt;/li&gt;&#39;); 
        $.ajax(
        {
            type: &quot;GET&quot;,
            url: &quot;/cgi-bin/SimpleXmla.py&quot;,
            dataType: &quot;xml&quot;,
            cache: &#39;False&#39;,
            success: function (xml) 
            {       
                $(&#39;#debug&#39;).append(&#39;&lt;li&gt;Success&lt;/li&gt;&#39;); 
                ok(true);
            },
            error:  function(request, ajaxOptions, thrownError)
            {
                $(&#39;#debug&#39;).append(&#39;&lt;li&gt;Failure&lt;/li&gt;&#39;); 
                ok(false);
            }
        });
    });
}
</code></pre>
<p>The problem with above code is that we are not using asyncTest, or,
alternatively, calling a series of stop and start statements. Because we
don&#39;t make those calls, this code may sometimes report success even when
the test fails.</p>
<p>This has nothing to do with its problems, but note that as a bonus, this
code assumes that there is a UL element in the HTML where we can post
little debug statements. Writing debug statements like this can be
useful, and perhaps I should not have combined an example of using them
with code that is clearly labeled as the wrong way to do something. The
problem here is not the debug statements, which can be useful, it is the
missing call to asyncTest that is causing problems. There are strategies
you can employ to make code like this work, but the best solution is to
use asyncTest.</p>
<ul>
<li><a href="http://docs.jquery.com/QUnit/asyncTest#nameexpectedtest">AsyncTest</a></li>
<li><a href="http://docs.jquery.com/QUnit/stop">stop</a></li>
<li><a href="http://docs.jquery.com/QUnit/start">start</a></li>
</ul>
<h3 id="callbacks-and-async-test">Callbacks and Async Test</h3>
<p>Callbacks can be combined with calls to <strong>asyncTest</strong> to give you some
powerful testing capabilities. </p>
<p>An <strong>asyncTest</strong> is just like a regular call to <strong>test</strong> that starts with
a call to <strong>stop()</strong> and that then calls <strong>start()</strong> when you are ready to
result. The call to <strong>stop</strong> puts the qunit testing system on hold until a
callback or other asyncrhonous event completes. Then you can call <strong>start</strong>
to get things moving again. <strong>asyncTest</strong> makes this process simpler by
calling <strong>stop</strong> for you. Now all you need to is call <strong>start</strong> once the
asynchronous process has completed and you are ready to proceed. </p>
<p>In this call I use <strong>asyncTest</strong> rather than <strong>test.</strong>At the same time, I 
pass in an anonymous function which is the callback:</p>
<pre><code>    asyncTest(&quot;testTwo&quot;, function() {    
       testDisplay.showDebugTest(&quot;Test Two started&quot;);
       presidents.getPresidents(function() {
           testDisplay.showDebugTest(&quot;Test Two Callback&quot;);
           len = testDisplay.rowData.length;
           ok(len &gt; 0, &quot;Len was: &quot; + len);
           start();
           testDisplay.showDebugTest(&quot;Test restarted&quot;);
       });
   });
</code></pre><p>Then in <strong>getPresidents</strong>, I make use of the anonymous function as a
callback:</p>
<pre><code>Presidents.prototype.getPresidents = function(callback) {
   that.clearResponse(&quot;Get Presidents called&quot;);
   presidentMode=true;    
   request = $.ajax(
   {
       type: &quot;get&quot;,
       url: &#39;/history&#39;,
       cache: false,
       dataType: &quot;json&quot;,
       success: function (data) {
           $(data).each(function() {
               $(this).each(function() {
                   display.displayRow(this);    
               });                
           });
           $(&quot;input[name=responseGroup]:radio&quot;).click(that.radioSelection);
           $(&quot;input[name=responseGroup]:radio:first&quot;).attr(&#39;checked&#39;, true);
           that.radioSelection();
           if (typeof(callback) == &#39;function&#39;) {
               display.showDebug(&quot;Callback coming&quot;);
               callback();
           }
       },
       error: display.showError
   });
};
</code></pre><p>Notice that the callback is only called if it is actually passed in:</p>
<pre><code>if (typeof(callback) == &#39;function&#39;) {
     display.showDebug(&quot;Callback coming&quot;);
       callback();
}
</code></pre><p>If the argument is not passed in, then the call is never made. If it is
present, which it will be during the tests, then it executes and the
test is executed:</p>
<pre><code>len = testDisplay.rowData.length;
ok(len &gt; 0, &quot;Len was: &quot; + len);
start();
</code></pre><p>Notice the call to <strong>start</strong>. This is necessary because the test was
temporarily halted waiting for the callback to execute. Once it
executes, then we must start the test machinery running once more, which
we do by calling <strong>start</strong>().</p>
<h2 id="private-methods">Private Methods</h2>
<p>Should we test private methods? One traditional answer is that we test only 
public functions (Name.prototype.whatever).</p>
<p>However, qunit is very flexible, and it is possible to test private 
functions without too much fuss. One solution is shown below. Suppose
you have a private method called <strong>getRoll</strong> that returns a number between
1 and 100. You want to write a test that proves that the results it
returns are between 1 and 100. You can add a public method that contains
a unit test to the class:</p>
<pre><code>ELF.own.Scores = (function() {
    &#39;use strict&#39;;

    function Scores() {
    }    

    var getRoll = function() {
        return Math.floor(Math.random() * 100) + 1;
    };

    Scores.prototype.unitTests = function() {
        test(&quot;ScoresUnitTests&quot;, function() {
            var actual = getRoll();
            ok(actual &lt; 101 &amp;&amp; actual &gt; 0, &quot;Get Roll in range&quot;);
        });
    }

    return Scores;
}());
</code></pre><p>Then in the unit test code youcan call your unit test:</p>
<pre><code>function myTests() {&#39;use strict&#39;;

    module(&quot;Normal test&quot;);

    asyncTest(&quot;Test01&quot;, function() {
        ok(1 === 1);    
    });

    module(&quot;Private test&quot;);

    var privateTest = function() {
        var testScore = new ELF.own.Scores();
         testScore.unitTests();
    };

    privateTest();
}
</code></pre><p>This would be a way to run one or more tests of private methods inside an 
object. Clearly we are inserting code into the object that would not be used 
in a shipping product. Using Templates we could have a version of our code 
that had such methods, and other versions which did not. </p>
<p>In general, the subject of unit testing private methods is an area of 
controversy. For instance, the whole point of private methods is that they 
can change when you need to change them. If you start testing them, aren&#39;t 
you just locking something in place that should be fluid? The controversy 
can be found nearly everywhere unit testing is discussed. </p>
<h2 id="mocha-and-unit-tests-with-node">Mocha and Unit Tests with Node</h2>
<p>You can use a tool called <a href="http://visionmedia.github.io/mocha/">Mocha</a> to 
run tests with node. This enables us to run tests from the command line 
without using qunit and a browser. It is not that Mocha is better or worse 
than qUnit, it is simply an alternative to qUnit.</p>
<pre><code>npm install -g mocha
</code></pre><p>The above command installs mocha in a globally available folder. Now you don&#39;t
have to worry about running npm install mocha each time you use it. When using
some libraries global npm installs are not a good idea, and in some cases it
is optional. But with Mocha, you should use the -g (global) install option.</p>
<p>Now create a directory called test:</p>
<pre><code>mkdir test
</code></pre><p>Inside that directory, create a file called <strong>test.js</strong> with the following,
hello world style, code:</p>
<pre><code>var assert = require(&quot;assert&quot;);

describe(&quot;Test01&quot;, function() {
    it (&quot;Is 3 equal to 3&quot;,  function() {
        assert.equal(3, 3);
    });
});
</code></pre><p>To run the test, just type <strong>mocha</strong> from inside the test folder.</p>
<ul>
<li><a href="http://visionmedia.github.io/mocha/">http://visionmedia.github.io/mocha/</a></li>
</ul>
</div></body></html>