<!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width initial-scale=1.0"><title>Jasmine</title><link rel="shortcut icon" href="/charlie/images/favicon.png"><!-- Latest compiled and minified CSS--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap.min.css"><!-- Optional theme--><link rel="stylesheet" href="/components/bootstrap/dist/css/bootstrap-theme.min.css"><!-- link(href='/libs/css/BootstrapIndex.css', rel='stylesheet', type='text/css')--><link href="/css/style.css" rel="stylesheet" type="text/css"><link href="/css/highlight/googlecode.css" rel="stylesheet" type="text/css"><script src="/components/jquery/dist/jquery.js"></script><script src="/components/angular/angular.js"></script><script src="/components/angular-route/angular-route.js"></script><script src="/components/bootstrap/dist/js/bootstrap.min.js"></script><!-- script(src='/libs/scripts/elvenware.js', type='text/javascript')--><script src="/libs/scripts/Control.js"></script><!-- script(src='http://localhost:35729/livereload.js')--></head><body><div class="navbar navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Elvenware</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="/index.html">Home</a></li><li><a href="/about">About</a></li><li class="dropdown"><a href="#/" data-toggle="dropdown" class="dropdown-toggle">Dropdown<b class="caret"></b></a><ul class="dropdown-menu"><li class="dropdown-header">Core Code</li><li><a href="/charlie/development/index.html">Strongly Typed</a></li><li><a href="/charlie/development/web/index.html">Web & Scripts</a></li><li><a href="/charlie/development/cloud/index.shtml">Cloud</a></li><li class="divider"></li><li class="dropdown-header">OS and Tools</li><li><a href="/os/index.html">OS</a></li><li><a href="/charlie/development/database/index.html">Database</a></li><li><a href="/books/index.html">My Writing</a></li><li class="divider"></li><li class="dropdown-header">Art</li><li><a href="/charlie/Art/index.html">Poems & Photos</a></li><li><a href="/books/reading/index.html">Book Reviews</a></li><li><a href="/spirit/index.html">Spiritual</a></li><li class="divider"></li><li class="dropdown-header">Links</li><li><a href="/charlie/links.html">My Links</a></li><li><a href="http://www.github.com/charliecalvert">GitHub</a></li><li><a href="http://sourceforge.net/projects/elvenware/">Sourceforge</a></li></ul></li></ul></div><!-- /.nav-collapse--></div></div><div class="container"><figure><img alt="Elvenware" src="/charlie/images/elvenwarelogo.png"/></figure><h1>Jasmine</h1><p>Welcomes to Jasmine</p><ul><!--TOC_Start--><li><a href="#jasmine">Jasmine</a></li>
<li><a href="#jasmine-basics">Jasmine Basics</a></li>
<li><a href="#jasmine-server">Jasmine Server</a></li>
<li><a href="#reporter">Reporter</a></li>
<li><a href="#focused-tests">Focused Tests</a></li>
<li><a href="#async">Async</a></li>
<li><a href="#spyon">SpyOn</a></li>
<li><a href="#spyon-ajax">SpyOn Ajax</a></li>
<li><a href="#install-jasmine-node">Install Jasmine-node</a></li>
<li><a href="#create-route">Create Route</a></li>
<li><a href="#basic-jasmine-node">Basic Jasmine-Node</a></li>
<li><a href="#run-the-test-">Run the test:</a></li>
<li><a href="#permanently-delete-from-git-repository">Permanently Delete from Git Repository</a></li>
<li><a href="#before-each">Before Each</a></li><!--TOC_End--></ul><h1 id="jasmine">Jasmine</h1>
<p>Jasmine is a unit testing tool for JavaScript. There are many
examples of how to use it in JsObjects.</p>
<ul>
<li><a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/UnitTests">Jasmine on JsObjects</a></li>
</ul>
<h2 id="jasmine-basics">Jasmine Basics</h2>
<p>In this project we use Jasmine to compose a test suite called &quot;Angular Basic Tests.&quot; We put code like the following in <strong>test/spec/test.js</strong>:</p>
<pre><code class="lang-javascript">describe(<span class="hljs-string">'Angular Basic Tests'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
});
</code></pre>
<p>This code sets up a Jasmine Test Suite called &#39;Angular Basic Tests&#39;. We group related tests inside Jasmine test suites. In particular, we will place two things inside these suite:</p>
<ul>
<li>Our tests.</li>
<li>Code to set up and tear down the environment in which we want our suites to run</li>
</ul>
<p><strong>NOTE</strong>: <em>Tests are sometimes called specs, which is short for specification. This is particular true in Behavior Driven Testing.</em></p>
<p>Our tests begin with a call to the function <strong>it()</strong>:</p>
<pre><code class="lang-javascript">describe(<span class="hljs-string">'Angular Basic Tests'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;

    it(<span class="hljs-string">'expects true to be true'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        expect(<span class="hljs-literal">true</span>).toBe(<span class="hljs-literal">true</span>);
    });
});
</code></pre>
<p>The <strong>it</strong> method takes two parameters:</p>
<ul>
<li>A string specifying the purpose of the test.</li>
<li>A callback.</li>
</ul>
<p>Inside the callback we use the built in <strong>expect</strong> method. Our tests usually check boolean conditions. In this case, we test whether <strong>true</strong> is equal to <strong>true</strong>. In unit testing, we try to create methods that can be verified with boolean statements. For instance, we can use a boolean statement to confirm that a method called <strong>add</strong> returns the value <strong>5</strong> when passed <strong>3</strong> and <strong>2</strong>.</p>
<p>We frequently also include methods that set up the environment in which our tests run. These set up methods include calls to the Jasmine <strong>beforeEach()</strong> and <strong>afterEach()</strong> methods. Those methods are called before and after each test.</p>
<pre><code class="lang-javascript">describe(<span class="hljs-string">'Angular Basic Tests'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">  'use strict'</span>;

  <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>;

  beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    name = <span class="hljs-string">'Sally'</span>;
  });

  it(<span class="hljs-string">'expects true to be true'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    expect(<span class="hljs-literal">true</span>).toBe(<span class="hljs-literal">true</span>);
  });

  it(<span class="hljs-string">"is just a function, so it can contain any code"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    name = name + <span class="hljs-string">' Coder'</span>
    expect().toEqual(<span class="hljs-string">'Sally Coder'</span>);
  });
});
</code></pre>
<p>In the above code, we use a <strong>beforeEach</strong> method to ensure that name is set to &#39;Sally&#39; before each test is run. Even if one of the tests modifies the string, the <strong>beforeEach</strong> method will reinitialize it to &#39;Sally&#39;.</p>
<h2 id="jasmine-server">Jasmine Server</h2>
<p>This section shows how to set Jasmine up to do server side tests. We will discuss setting Jasmine up for the client elsewhere.</p>
<p>Install jasmine globally:</p>
<pre><code class="lang-bash">npm <span class="hljs-keyword">install</span> -<span class="hljs-keyword">g</span> jasmine
</code></pre>
<p>Create the <strong>/spec/support/jasmine.json</strong> file. It should contain something like this:</p>
<pre><code class="lang-javascript">{
  "<span class="hljs-attr">spec_dir</span>": <span class="hljs-string">"spec"</span>,
  "<span class="hljs-attr">spec_files</span>": [
    <span class="hljs-string">"**/test*.js"</span>
  ]
}
</code></pre>
<p>This bit of JSON tells Jasmine that our tests are in a directory called <strong>spec</strong> and that each file that contains tests begins with the word <strong>test</strong>. For instance: <strong>test-basic.js</strong> or <strong>test-state-parser.js</strong>.</p>
<p>Here is an example test suite called <strong>test-basic.js</strong> to put in your spec directory:</p>
<pre><code class="lang-javascript">describe('Object Basics with Require', function() {

    it('proves true is true', function() {
        expect(<span class="hljs-name">true</span>).toBe(<span class="hljs-name">true</span>)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>

    it('proves that one is smaller than two', function() {
        expect(<span class="hljs-number">1</span>).toBeLessThan(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>

})<span class="hljs-comment">;</span>
</code></pre>
<p>This test suite contains two simple tests. One tests that <strong>true</strong> is equal to <strong>true</strong>, the other that 1 is smaller than 2.</p>
<h2 id="reporter">Reporter</h2>
<p>To run your test, type the following:</p>
<pre><code>jasmine
</code></pre><p>However, it is nice to have a good reporter set up. I like the jasmine-spec-reporter:</p>
<pre><code><span class="hljs-title">npm</span> install jasmine-spec-reporter <span class="hljs-comment">--save-dev</span>
</code></pre><p>Create a file called <strong>jasmine-runner.js</strong> that looks like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Jasmine = <span class="hljs-keyword">require</span>(<span class="hljs-string">'jasmine'</span>);
<span class="hljs-keyword">var</span> SpecReporter = <span class="hljs-keyword">require</span>(<span class="hljs-string">'jasmine-spec-reporter'</span>);
<span class="hljs-keyword">var</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};

<span class="hljs-keyword">var</span> jrunner = <span class="hljs-keyword">new</span> Jasmine();
jrunner.configureDefaultReporter({
    <span class="hljs-keyword">print</span>: noop
}); <span class="hljs-comment">// remove default reporter logs</span>
jasmine.getEnv().addReporter(<span class="hljs-keyword">new</span> SpecReporter()); <span class="hljs-comment">// add jasmine-spec-reporter</span>
jrunner.loadConfigFile(); <span class="hljs-comment">// load jasmine.json configuration</span>
jrunner.execute();
</code></pre>
<p>Run it with either of the following commands:</p>
<pre><code class="lang-bash"><span class="hljs-keyword">node</span> <span class="hljs-title">jasmine-runner</span>.js
nodemon jasmine-runner.js
</code></pre>
<p>You can put the command shown above, or some variant on it, in your <strong>package.json</strong> file:</p>
<pre><code class="lang-javascript"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"test"</span>: <span class="hljs-string">"node jasmine-runner.js"</span>
},
</code></pre>
<p>Now you can type <strong>npm test</strong> to run your tests.</p>
<p>##Jasmine Spy</p>
<p>The <a href="https://github.com/charliecalvert/JsObjects/tree/master/JavaScript/UnitTests/JasmineSpyOn">JasmineSpy</a> program demonstrates how to:</p>
<ul>
<li>Use Jasmine to test async calls</li>
<li>SpyOn to create mock objects</li>
</ul>
<h2 id="focused-tests">Focused Tests</h2>
<p>Use the new <em>focused specs</em> feature from Jasmine 2.1 to work with one suite at a time. To do this, change <strong>describe</strong> to <strong>fdescribe</strong> or <strong>it</strong> to <strong>fit</strong>. It you make a suite with <strong>fdescribe</strong>, then just that one suite will run and the others won&#39;t clutter your screen:</p>
<ul>
<li><a href="http://jasmine.github.io/2.1/focused_specs.html">Focused Spec Examples</a></li>
<li><a href="https://blog.pivotal.io/labs/labs/new-key-features-jasmine-2-1">Focused Spec Announcement for Jasmine 2.1</a></li>
</ul>
<p>Don&#39;t forget to add this to <strong>karma.conf.js</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-attribute">reporters</span>: ['spec'],

<span class="less"><span class="hljs-selector-tag">specReporter</span>: {
    <span class="hljs-attribute">suppressSkipped</span>: true <span class="hljs-comment">// do not print information about skipped tests</span>
},

<span class="hljs-attribute">plugins</span>: [
    <span class="hljs-string">'karma-jasmine'</span>,
    <span class="hljs-string">'karma-spec-reporter'</span>,
    etc...
]</span>
</code></pre>
<h2 id="async">Async</h2>
<p>The Async calls use done:</p>
<pre><code>it(<span class="hljs-string">"Integration test makes a real AJAX request"</span>, function(<span class="hljs-name">done</span>) {
    textLoader.loadFile(<span class="hljs-string">"Sources.html"</span>, function(<span class="hljs-name">responseText</span>) {
        var bar = $(<span class="hljs-name">responseText</span>).filter('#paragraph04').html()<span class="hljs-comment">;</span>
        expect(<span class="hljs-name">bar</span>).toBe('Fine time.')<span class="hljs-comment">;</span>
        done()<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre><p>Looking at the function above, do you see that the test is past <strong>done</strong>
as a parmater? Notice also that it calls <strong>done()</strong> when it is finished.
The call to done notifies Jasmine that your callback is complete.</p>
<h2 id="spyon">SpyOn</h2>
<p>Create a mock object and instrument the object so that you can learn
key facts such as:</p>
<ul>
<li>Was the mock object called?</li>
<li><p>What parameters were passed to the mock object</p>
<p>  it(&quot;Tests that loadFile is called with Sources.html&quot;, function() {</p>
<pre><code>  <span class="hljs-comment">// get is stubbed and never really called</span>
  spyOn($, <span class="hljs-string">"get"</span>);
  textLoader.loadFile(<span class="hljs-string">"Sources.html"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
      <span class="hljs-built_in">console</span>.log(data);
  });
  expect($.get).toHaveBeenCalledWith(<span class="hljs-string">"Sources.html"</span>,     jasmine.any(<span class="hljs-built_in">Function</span>));
</code></pre><p>  });</p>
</li>
</ul>
<p>Here we use SpyOn to mock <strong>jQuery.get()</strong>:</p>
<pre><code>spyOn(<span class="hljs-variable">$,</span> <span class="hljs-string">"get"</span>);
</code></pre><p>Once we have mocked it, we cn ask questions, such what parameters was it called
with:</p>
<pre><code>expect($.<span class="hljs-keyword">get</span>).toHaveBeenCalledWith(<span class="hljs-string">"Sources.html"</span>,     jasmine.any(<span class="hljs-built_in">Function</span>));
</code></pre><p>Our question here is simple: <em>Was <em>*get</em></em> called with two parameters. The first
a string, the second a function. We expect the first parameter, the string, to
be &quot;Sources.html&quot;.</p>
<p>When we mock an object, it is never called. Instead it is stubbed. A fake object
is put in its place.</p>
<h2 id="spyon-ajax">SpyOn Ajax</h2>
<p>Like this:</p>
<pre><code class="lang-javascript">beforeEach(<span class="hljs-name">function</span>() {
    spyOn($, 'ajax').and.callFake(<span class="hljs-name">function</span>(<span class="hljs-name">ajaxObject</span>) {
        ajaxObject.success(<span class="hljs-name">deliciousLinks</span>)<span class="hljs-comment">;</span>
        return {
            fail: function() {}
        }<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>Or like this:</p>
<pre><code class="lang-javascript">spyOn($, <span class="hljs-string">'getJSON'</span>).<span class="hljs-keyword">and</span>.callFake(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(url, success)</span></span> {
    success(bitlyLinks);
    <span class="hljs-keyword">return</span> {
        fail: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {}
    };
});
</code></pre>
<p>Or, if you want to go all the way, handling, <strong>success</strong>, <strong>done</strong>, <strong>fail</strong> and <strong>always</strong>, then like this:</p>
<pre><code class="lang-javascript">beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> {
    spyOn($, <span class="hljs-string">'getJSON'</span>).<span class="hljs-keyword">and</span>.callFake(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(url, params, success)</span></span> {
        success(tweets);
        <span class="hljs-keyword">return</span> {
            done: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> {
                <span class="hljs-keyword">return</span> {
                    fail: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> {
                        <span class="hljs-keyword">return</span> {
                                always: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> {
                            }
                        }
                    }
                }
            }
        };
    });
});
</code></pre>
<p>The latter is for calls like this that have <strong>success</strong>, <strong>done</strong>, <strong>fail</strong> and <strong>always</strong> function:</p>
<pre><code class="lang-javascript">searchFull: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span>;
    <span class="hljs-keyword">var</span> searchQuery = $(<span class="hljs-string">'#searchQuery'</span>).val();
    $.getJSON(<span class="hljs-string">'/search'</span>, {
        <span class="hljs-string">'q'</span>: searchQuery
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        $(<span class="hljs-string">'#tweetData'</span>).html(<span class="hljs-built_in">JSON</span>.stringify(result, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>));
        elfTwitter.clearControls();
        $.each(result.statuses, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, tweet</span>) </span>{
            <span class="hljs-keyword">if</span> (tweet.entities.urls.length &gt; <span class="hljs-number">0</span>) {
                elfTwitter.appendUrl(<span class="hljs-string">'#tweetList'</span>, index, tweet.text, tweet.entities.urls[<span class="hljs-number">0</span>].url);
            } <span class="hljs-keyword">else</span> {
                elfTwitter.renderTable(tweet.text, tweet.user.name);
                $(<span class="hljs-string">'#tweetList'</span>).append(<span class="hljs-string">'&lt;li&gt;'</span> + tweet.text + <span class="hljs-string">'&lt;/li&gt;'</span>);
            }
        });
    }).done(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'second success'</span>);
        })
        .fail(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jqxhr, textStatus, error</span>) </span>{
            <span class="hljs-keyword">var</span> err = textStatus + <span class="hljs-string">', '</span> + error;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Request Failed: '</span> + err);
            <span class="hljs-built_in">console</span>.log(jqxhr);
            $(<span class="hljs-string">'#displayContainer'</span>).html(jqxhr.responseText);
        })
        .always(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Always'</span>);
        });
},
</code></pre>
<h1 id="install-jasmine-node">Install Jasmine-node</h1>
<pre><code>sudo npm install -g jasmine-<span class="hljs-keyword">node</span><span class="hljs-title"></span>
</code></pre><p>You will also want to install request locally:</p>
<pre><code>npm <span class="hljs-keyword">install</span> request
</code></pre><p>Or</p>
<pre><code>npm install request --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span>
</code></pre><h1 id="create-route">Create Route</h1>
<p>Create a simple route you want to test:</p>
<pre><code>app.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/hello'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request, response)</span> </span>{ <span class="hljs-string">'use strict'</span>;
    response.send(<span class="hljs-string">'Hi there.'</span>);
});
</code></pre><h1 id="basic-jasmine-node">Basic Jasmine-Node</h1>
<p>Save the following as <strong>Tests/SimpleSpec.js</strong>:</p>
<pre><code>var request = require('request')<span class="hljs-comment">;</span>

describe(<span class="hljs-string">"A suite"</span>, function() {
    it(<span class="hljs-string">"should respond with hello world"</span>, function(<span class="hljs-name">done</span>) {
        request(<span class="hljs-string">"http://localhost:30025/hello"</span>, function(<span class="hljs-name">error</span>, response, body) {
            expect(<span class="hljs-name">body</span>).toEqual(<span class="hljs-string">"Hi there."</span>)<span class="hljs-comment">;</span>
            done()<span class="hljs-comment">;</span>
        })<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre><p>Your tests must be saved in a file that has spec as the last four
letters in the name. For instance: FooSpec.js is good. SpecFoo.js
is not good.</p>
<h1 id="run-the-test-">Run the test:</h1>
<p>Now run start your server running in one shell:</p>
<pre><code><span class="hljs-keyword">node</span> <span class="hljs-title">Server</span>.js
</code></pre><p>Then open a second shell and run your tests:</p>
<pre><code>jasmine-<span class="hljs-keyword">node</span> <span class="hljs-title">Tests</span>/
</code></pre><h1 id="permanently-delete-from-git-repository">Permanently Delete from Git Repository</h1>
<p>A tool called BFG can make permanently deleting files from a repository
fairly easy.</p>
<ul>
<li><a href="http://www.elvenware.com/charlie/development/cloud/Git.html#permanent-delete">Elvenware Git</a></li>
</ul>
<h2 id="before-each">Before Each</h2>
<p><strong>beforeEach</strong> methods load before each test is run. <strong>afterEach</strong> methods are loaded after each test is run.</p>
<p>This <strong>beforeEach</strong> statement loads your angular module:</p>
<pre><code class="lang-javascript">beforeEach(<span class="hljs-name">module</span>('elfApp'))<span class="hljs-comment">;</span>
</code></pre>
<p>Specically, it loads the module that you define like this in <strong>app.js</strong> and use in <strong>main.js</strong> and <strong>about.js</strong>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myModule = angular.<span class="hljs-built_in">module</span>(<span class="hljs-string">'elfApp'</span>, [<span class="hljs-string">'ngRoute'</span>]);
</code></pre>
<p>This <strong>beforeEach</strong> loads you HTML fixture:</p>
<pre><code class="lang-javascript">beforeEach(<span class="hljs-name">function</span>() {
    jasmine.getFixtures().fixturesPath = 'base/spec/fixtures/'<span class="hljs-comment">;</span>
    loadFixtures('renewable.html')<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>This before each does three things:</p>
<pre><code class="lang-javascript">beforeEach(inject(<span class="hljs-keyword">function</span>(<span class="hljs-number">_</span>$compile<span class="hljs-number">_</span>, <span class="hljs-number">_</span>$rootScope<span class="hljs-number">_</span>, <span class="hljs-number">_</span>$templateCache<span class="hljs-number">_</span>, <span class="hljs-number">_</span>$controller<span class="hljs-number">_</span>) {
    scope = <span class="hljs-number">_</span>$rootScope<span class="hljs-number">_</span>.$new();
    $compile = <span class="hljs-number">_</span>$compile<span class="hljs-number">_</span>;
    $templateCache = <span class="hljs-number">_</span>$templateCache<span class="hljs-number">_</span>;

    mainController = <span class="hljs-number">_</span>$controller<span class="hljs-number">_</span>(<span class="hljs-string">'MainController'</span>, {
        $scope: scope
    });
}));
</code></pre>
<p>First, it gets the scope that you are using in your application. I believe that this is a global scope object for the entire app, and this line narrows the scope down to work only with the scope of your controller:</p>
<pre><code class="lang-javascript">mainController = <span class="hljs-number">_</span>$controller<span class="hljs-number">_</span>(<span class="hljs-string">'MainController'</span>, {
    $scope: scope
});
</code></pre>
<p>The above code also loads your controller.</p>
<p>These line gets the compile and templateCache, both of which are needed to process our fixture so that it is converted from an angular template to live HTML that contains resolved references to scope variables:</p>
<pre><code class="lang-javascript">$compile = <span class="hljs-number">_</span>$compile<span class="hljs-number">_</span>;
$templateCache = <span class="hljs-number">_</span>$templateCache<span class="hljs-number">_</span>;
</code></pre>
<p>There are also beforeEach and afterEach calls to load <strong>$httpBackend</strong>:</p>
<pre><code class="lang-javascript">beforeEach(inject(<span class="hljs-keyword">function</span>(<span class="hljs-number">_</span>$compile<span class="hljs-number">_</span>, <span class="hljs-number">_</span>$rootScope<span class="hljs-number">_</span>, <span class="hljs-number">_</span>$httpBackend<span class="hljs-number">_</span>, <span class="hljs-number">_</span>$controller<span class="hljs-number">_</span>) {
    scope = <span class="hljs-number">_</span>$rootScope<span class="hljs-number">_</span>.$new();
    var $compile = <span class="hljs-number">_</span>$compile<span class="hljs-number">_</span>;
    $httpBackend = <span class="hljs-number">_</span>$httpBackend<span class="hljs-number">_</span>;
    mainController = <span class="hljs-number">_</span>$controller<span class="hljs-number">_</span>(<span class="hljs-string">'MainController'</span>, {
        $scope: scope
    });
}));

afterEach(<span class="hljs-keyword">function</span>() {
    $httpBackend.verifyNoOutstandingExpectation();
    $httpBackend.verifyNoOutstandingRequest();
});
</code></pre>
<p>The beforeEach shown above is the same as the ones we looked at before, except it does not get the compile and templateCache for handling fixtures, and instead it gets httpBackend. We use <strong>httpBackend</strong> for mocking calls to the server. Instead of aclled $http.get directly, we use httpBackend calls such as this to mock or fake the call to the server. Instead of making a real call, we just return pre-defined data:</p>
<pre><code class="lang-javascript">var requestHandler = $httpBackend
    .<span class="hljs-keyword">when</span>(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'data/Renewable.json'</span>)
    .respond(PUT THE MOCK DATA HERE);

$httpBackend.expectGET(<span class="hljs-string">'data/Renewable.json'</span>);
scope.getRenewable();
$httpBackend.flush();
expect(scope.renewable[<span class="hljs-number">0</span>].Year).toEqual(<span class="hljs-string">'2017'</span>);
</code></pre>
<p>The <strong>afterEach</strong> code will raise an error if your set up a call to <strong>httpBackend</strong> but don&#39;t ever execute it by calling <strong>httpBackend.flush()</strong>.</p>
</div></body></html>