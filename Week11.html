<h1>Week 11 - Overviews</h1>

<h2>Major Topics</h2>

<ul>
<li>Position Page and Maps</li>
<li>MongoDb </li>
</ul>

<h2>Tables</h2>

<table>
<thead>
<tr>
  <th>Item</th>
  <th style="text-align:right;">Value</th>
</tr>
</thead>
<tr>
  <td>Air Conditioner</td>
  <td style="text-align:right;">$1600</td>
</tr>
<tr>
  <td><del>Phone</del></td>
  <td style="text-align:right;">$12</td>
</tr>
<tr>
  <td><em>Pipe</em></td>
  <td style="text-align:right;">$1</td>
</tr>
</table>


<h2>Fenced Code Blocks</h2>

<pre><code class="javascript">var foo = function() {
   console.log("bar");
}</code></pre>

<p>You can also specify options. Markdown.Extra was given the following options <br>
for this editor.</p>

<pre><code class="javascript">  Markdown.Extra.init(converter1, {
    extensions: "all",
    highlighter: "prettify"
  });</code></pre>

<h2>Using the Public Directory</h2>

<p>It is easy to link in standard HTML files to an Express program that uses  <br>
Jade. Just create a standard HTML file with a name like <strong>game.html</strong>:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;MyFile&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>This file can be placed in the <strong>public</strong> directory.</p>

<p>In an express application, if you want to link in <em>ordinary</em> HTML files like <br>
<strong>Game.html</strong>, you should place them in the <strong>public</strong> directory:</p>

<pre><code>public/Game.html
</code></pre>

<p>Don&#8217;t put them in the views directory. Don&#8217;t link to them with use statements <br>
like this:</p>

<pre><code>app.get('/Game.html', routes.Game); 
</code></pre>

<p>Instead, just link to them like any other ordinary HTML file:</p>

<pre><code>&lt;a href='Game.html'&gt;Game.html&lt;/a&gt;</code></pre>

<p>Or if you are in a Jade template, write something like this, where I include the <br>
li just to provide context:</p>

<pre><code>  li
    a(href='/Game.html') Game</code></pre>

<h2>Global Namespace</h2>

<p>I am still not settled on this issue, but your solution looks reasonable and  <br>
I like the look of the common.js answer in the link you found.</p>

<p>Common={ <br>
  util: require(&#8216;util&#8217;), <br>
  fs:   require(&#8216;fs&#8217;), <br>
  path: require(&#8216;path&#8217;)};</p>

<p>module.exports =Common;</p>

<p>This is a combination of points b and c that we were discussing above. We  <br>
were talking about doing this:</p>

<pre><code>exports.dbName = 'foo';
</code></pre>

<p>Or doing this:</p>

<pre><code>var myData = {};
myData.dbName = 'barfoo';</code></pre>

<p>But their suggestion is to combine them:</p>

<pre><code>var myData = {};
myData.dbName = 'barfoo';

exports.data = myData;</code></pre>

<p>This makes sense to me. I&#8217;ll try to work with these ideas some and come in  <br>
with some kind of reasonable solution for class this evening.</p>

<p>It is always best to limit the scope of variables as much as possible. When  <br>
we can, we should completely encapuslate each object so that it shares no  <br>
data with other objects. Next best is to have one object share data only  <br>
with other objects that have to see it. Say, data is declared in object A,  <br>
and shared only with Object B or Objects B and C. Objects D, E, F, G, etc  <br>
cannot see the variable at all.</p>

<p>But I concede that there are times when we want to share some few variables  <br>
or routines <strong>*<em>with</em>*</strong> *<strong><em>the</em>*</strong> entire rest of our program. Then we can use a solution  <br>
like <strong>*<em>the</em>*</strong> one we are discussing. That should be rare though.</p>

<p>Always we should put at most one, and only one, variable in <strong>*<em>the</em>*</strong> Global  <br>
namespace maintained by <strong>*<em>the</em>*</strong> JavaScript runtime. </p>

<h2>Properly Reporting Errors <strong>*<em>with</em>*</strong> DbCouch</h2>

<p>One of <strong>*<em>the</em>*</strong> key moments when working <strong>*<em>with</em>*</strong> a CouchDb database is <strong>*<em>the</em>*</strong> moment <br>
you try to create <strong>*<em>the</em>*</strong> database. Let&#8217;s use that as an example of how to <br>
properly report errors. Consider this method:</p>

<pre><code>app.get('/create', function(request, response) {
    'use strict';
    console.log('create called.');
    nano.db.create(dbName, function(err, body) {
        if (!err) {
            console.log(body);
        } else {
            console.log(err.reason);
            reportErrorPrivate(err);
            response.send({ 'Result' : err.reason });
        }
    });</code></pre>

<p>Notice <strong>*<em>the</em>*</strong> error handler block:</p>

<pre><code>    } else {
        console.log(err.reason);
        reportErrorPrivate(err);
        response.send({ 'Result' : err.reason });
    }</code></pre>

<p>It first prints out <strong>*<em>the</em>*</strong> error <strong>reason</strong> property:</p>

<pre><code>reason: 'Name: \'prog28208_Calvert\'. Only lowercase characters (a-z),
digits (0-9), and any of ****the**** characters _, $, (, ), +, -, and / are allowed. 
Must begin ****with**** a letter.',</code></pre>

<p>This explanation is fairly easy to understand. In other words, <strong>*<em>the</em>*</strong> err.reason <br>
property is one way to get at <strong>*<em>the</em>*</strong> heart of what is wrong without having  <br>
visually parse a lot of complex text.</p>

<p>I then call <strong>*<em>the</em>*</strong> reportErrorPrivate method, that looks like this:</p>

<pre><code>    var reportErrorPrivate = function(error) {
        console.log('==========================')
        console.log('Error: ' + error.error);
        console.log('Status Code: ' + error['status_code']);
        console.log('Reason: ' + error.reason);
        console.log('Description: ' + error.description); 
    }</code></pre>

<p>This method prints ouf <strong>*<em>the</em>*</strong> error, status_code, reason and description properties <br>
of <strong>*<em>the</em>*</strong> CouchDb error message. This is most of <strong>*<em>the</em>*</strong> important information in <strong>*<em>the</em>*</strong> <br>
error message, <strong>*<em>with</em>*</strong> *<strong><em>the</em>*</strong> exception of <strong>*<em>the</em>*</strong> stack trace. <strong>*<em>The</em>*</strong> problem <strong>*<em>with</em>*</strong> printing <br>
out <strong>*<em>the</em>*</strong> stack trace, of course, is that it long and relatively had to read, at <br>
least in <strong>*<em>the</em>*</strong> sense that it takes up a lot screen space.</p>

<p>If, after all this, you are still having trouble understanding <strong>*<em>the</em>*</strong> error message, <br>
you could edit <strong>*<em>the</em>*</strong> code and log <strong>*<em>the</em>*</strong> entire error structure:</p>

<pre><code>console.log(error);
</code></pre>

<p>Finally <strong>*<em>the</em>*</strong> code in our original method sends <strong>*<em>the</em>*</strong> error.reason property back <br>
to <strong>*<em>the</em>*</strong> client so that <strong>*<em>the</em>*</strong> user can see what has happened. You might not want to <br>
do this if you releasing code to end users, but it is very helpful while you  <br>
are developing your code.</p>

<h2>More on Errors</h2>

<p>I&#8217;m getting <strong>*<em>the</em>*</strong> following error:</p>

<pre><code>readJson called: [object Object]
Exiting Get readJson
{ [Error: missing]
  name: 'Error',
  scope: 'couch',
  status_code: 404,
  'status-code': 404,</code></pre>

<p>This doesn&#8217;t tell me quite as much as I need to find your error. Here is your method:</p>

<pre><code>app.get('/readJson', function(request, response) {
    console.log('readJson called: ' + request.query)
    var prog = nano.db.use(dbName);

    prog.get(request.query.docName, function(error, existing) {
        if(!error) { 
            console.log(existing);
            response.send(existing);
        }  else {
            console.log(error);
            response.send(500, error);
        }
    });
    console.log('Exiting Get readJson');
});</code></pre>

<p>Let&#8217;s focus on this line (which in your code is missing <strong>*<em>the</em>*</strong> semicolon):</p>

<pre><code>console.log('readJson called: ' + request.query);
</code></pre>

<p>It produces this output:</p>

<pre><code>readJson called: [object Object]
</code></pre>

<p>This doesn&#8217;t really tell us much. To improve <strong>*<em>the</em>*</strong> output, use JSON.stringify:</p>

<pre><code>console.log('readJson called: ' + JSON.stringify(request.query))
</code></pre>

<p>Now we get this output:</p>

<pre><code>readJson called: {"docName":"Hero"}</code></pre>

<p>This is much more informative. It is also helpful to report which method  <br>
is printing an error when you are in a callback:</p>

<pre><code>console.log('readJson error: '  + JSON.stringify(error, null, 4));
</code></pre>

<p>Even better would be to incorporate <strong>*<em>the</em>*</strong> *<em>reportError</em>* method we  <br>
discussed on Saturday:</p>

<pre><code>var reportErrorPrivate = function(error) {
        console.log('==========================')
        console.log('Error: ' + error.error);
        console.log('Status Code: ' + error['status_code']);
        console.log('Reason: ' + error.reason);
        console.log('Description: ' + error.description); 
    }</code></pre>

<p>So <strong>*<em>the</em>*</strong> refactored version of your code might look like this:</p>

<pre><code>app.get('/readJson', function(request, response) {
    console.log('readJson called: ' + JSON.stringify(request.query))
    var prog = nano.db.use(dbName);

    prog.get(request.query.docName, function(error, existing) {
        if(!error) { 
            console.log(existing);
            response.send(existing);
        }  else {
            console.log('readJson error');
            reportError(error);
            response.send(500, { "Result": error.reason });
        }
    });
    console.log('Exiting Get readJson');
});</code></pre>

<h2>Ajax Error Handling</h2>

<pre><code>    function( jqXHR, ajaxOptions, thrownError) {
        ok(false,  jqXHR.responseText + ' ' +  jqXHR.statusText);
        start();
    }
});</code></pre>

<p>More information:</p>

<ul>
<li><a href="http://api.jquery.com/jQuery.ajax/#jqXHR">This is a link to api.jquery.com/jQuery.ajax/#jqXHR</a></li>
</ul>

<h2>CouchDb and Reading and Writing Bitmaps</h2>

<p>You can place a bitmap in <strong>*<em>the</em>*</strong> database exactly as you place any <br>
other attachment. You can read data out as you would other attachments, <br>
but you probably just want to save <strong>*<em>the</em>*</strong> results to discuss rather than <br>
send it on to clients via base64. </p>

<p>Examples:</p>

<pre><code>JsObjects\Data\CouchUtils\CouchImage01
JsObjects\Data\CouchUtils\CouchRead02
</code></pre>

<p>You can also read an image directly from your CouchDb data store. For <br>
instance, you might use a URL that looks like this:</p>

<pre><code>http://localhost:5984/couchdocs01/cscGarden.png/cscGarden.png</code></pre>

<p>I&#8217;ve modified <strong>*<em>the</em>*</strong> original example so that so all <strong>*<em>the</em>*</strong> images now go  <br>
into a CouchDb document called <strong>images</strong>. In other words, <strong>images</strong> <br>
now has multiple attachments.</p>

<h2>Reading and Writing from CouchDb Attach Example</h2>

<p>See:</p>

<pre><code>JsObjects/Data/CouchUtils
HtmlCssJavaScript/UnitTestCouchDb02
</code></pre>

<h2>Express Tips</h2>

<p>Create an Express Server:</p>

<pre><code>express --sessions --css stylus myapp02
</code></pre>

<p>Copy in a .project file. Open <strong>*<em>the</em>*</strong> .project file in notepad++ and edit <br>
<strong>*<em>the</em>*</strong> name element. Then import <strong>*<em>the</em>*</strong> project into Eclipse.</p>

<p>npm link express <br>
npm link jade <br>
npm link stylus</p>

<p>Set up your Two Pages in Stylus: home page, page02. You will need to <br>
edit layout.jade file, index.jade file, and create a page02.jade file. <br>
Then add in <strong>*<em>the</em>*</strong> following code to app.js and index.js:</p>

<pre><code>app.get('/page02', routes.page02);
</code></pre>

<p>And also in index.js:</p>

<pre><code>exports.page02 = function(req, res){
  res.render('page02', { title: 'Page02' });
};</code></pre>

<p>Set up a link to your Game.html file, or whatever you call the  <br>
main page of your game. Copy your game into the public directory. <br>
And then run it. You will probably have to mess with the Images <br>
directory and get that set up.</p>

<p>Next try to tackle the handlebars importing.</p>

<!-- GUID: 6c390b6f-3c3c-4466-4127-1e529acb2328 -->